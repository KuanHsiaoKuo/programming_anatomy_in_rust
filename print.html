<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Programming Anatomy In Rust</title>
        <meta name="robots" content="noindex"/>
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust为例分享学习编程常考虑的方方面面">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="style.css">
        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/layer1_underlying_abstract.html"><strong aria-hidden="true">1.</strong> Layer1: 底层抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/1_virtual_memory/virtual_memory.html"><strong aria-hidden="true">1.1.</strong> 虚拟内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/1_virtual_memory/memory_manage_safety.html"><strong aria-hidden="true">1.1.1.</strong> 内存管理与内存安全</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/1_virtual_memory/ownership_scope_lifetime.html"><strong aria-hidden="true">1.1.2.</strong> 所有权、作用域与生命周期</a></li></ol></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/type_system.html"><strong aria-hidden="true">1.2.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/primitive_types.html"><strong aria-hidden="true">1.2.1.</strong> 基础内置类型</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/collections.html"><strong aria-hidden="true">1.2.2.</strong> 集合类型</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/user_defined_types.html"><strong aria-hidden="true">1.2.3.</strong> 自定义类型</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html"><strong aria-hidden="true">1.2.4.</strong> 泛型、特征及特征对象</a></li></ol></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/language_grammar.html"><strong aria-hidden="true">1.3.</strong> 语言语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/keywords_glossary.html"><strong aria-hidden="true">1.3.1.</strong> 词法结构扫盲</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/binding_match.html"><strong aria-hidden="true">1.3.2.</strong> 绑定、赋值与匹配</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/logical_decision_loops.html"><strong aria-hidden="true">1.3.3.</strong> 逻辑判断与循环♻️</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/statements_expressions.html"><strong aria-hidden="true">1.3.4.</strong> 语句与表达式</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer2_design_abstract/layer2_design_abstract.html"><strong aria-hidden="true">2.</strong> Layer2: 设计抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/4_programming_paradigm.html"><strong aria-hidden="true">2.1.</strong> 编程范式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/fp.html"><strong aria-hidden="true">2.1.1.</strong> 函数式编程</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/oop.html"><strong aria-hidden="true">2.1.2.</strong> 面向对象编程</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/gp.html"><strong aria-hidden="true">2.1.3.</strong> 泛型编程</a></li></ol></li><li class="chapter-item expanded "><a href="layer2_design_abstract/5_design_pattern/5_design_pattern.html"><strong aria-hidden="true">2.2.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/6_module_manage.html"><strong aria-hidden="true">2.3.</strong> 模块管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/module_relate.html"><strong aria-hidden="true">2.3.1.</strong> 模块使用</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/cargo_basic.html"><strong aria-hidden="true">2.3.2.</strong> Cargo基础</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/cargo_plugins.html"><strong aria-hidden="true">2.3.3.</strong> Cargo扩展</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer3_task_abstract/layer3_task_abstract.html"><strong aria-hidden="true">3.</strong> Layer3: 任务抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/7_concurrency.html"><strong aria-hidden="true">3.1.</strong> 并发编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/io_models.html"><strong aria-hidden="true">3.1.1.</strong> 系统IO模型</a></li><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/1_multi_models/multi_models.html"><strong aria-hidden="true">3.1.2.</strong> 多线程模型</a></li><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/2_async_models/async_models.html"><strong aria-hidden="true">3.1.3.</strong> 异步模型</a></li></ol></li><li class="chapter-item expanded "><a href="layer3_task_abstract/8_meta_programming/8_meta_programming.html"><strong aria-hidden="true">3.2.</strong> 元编程</a></li></ol></li><li class="chapter-item expanded "><a href="layer4_protocol_abstract/layer4_protocol_abstract.html"><strong aria-hidden="true">4.</strong> Layer4: 协议抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer4_protocol_abstract/9_multilingual_programming/9_multilingual_programming.html"><strong aria-hidden="true">4.1.</strong> 跨语言编程</a></li><li class="chapter-item expanded "><a href="layer4_protocol_abstract/10_computer_network/10_computer_network.html"><strong aria-hidden="true">4.2.</strong> 计算机网络</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/layer5_ecosystem.html"><strong aria-hidden="true">5.</strong> Layer5: 生态环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/learning_resource.html"><strong aria-hidden="true">5.1.</strong> 学习资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/1_books/books.html"><strong aria-hidden="true">5.1.1.</strong> 书籍整理</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/2_courses/courses.html"><strong aria-hidden="true">5.1.2.</strong> 线上课程</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/3_blogs/blogs.html"><strong aria-hidden="true">5.1.3.</strong> 博客文章</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/4_videos/videos.html"><strong aria-hidden="true">5.1.4.</strong> 在线视频</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/5_projects/projects.html"><strong aria-hidden="true">5.1.5.</strong> 开源项目</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/2_lang_update/lang_update.html"><strong aria-hidden="true">5.2.</strong> 官方动态</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/3_community/community.html"><strong aria-hidden="true">5.3.</strong> 社区热点</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/4_academic/academic.html"><strong aria-hidden="true">5.4.</strong> 学术讨论</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/open_source.html"><strong aria-hidden="true">5.5.</strong> 开源观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/underlying.html"><strong aria-hidden="true">5.5.1.</strong> 底层开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/command/command.html"><strong aria-hidden="true">5.5.1.1.</strong> 命令行工具</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/data/data.html"><strong aria-hidden="true">5.5.1.2.</strong> 数据处理</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/embedded/embedded.html"><strong aria-hidden="true">5.5.1.3.</strong> 嵌入式</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/os/os.html"><strong aria-hidden="true">5.5.1.4.</strong> 系统开发</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/performance/performance.html"><strong aria-hidden="true">5.5.1.5.</strong> 性能工具</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network.html"><strong aria-hidden="true">5.5.2.</strong> 网络相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/cloud/cloud.html"><strong aria-hidden="true">5.5.2.1.</strong> 云原生</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/frontend/frontend.html"><strong aria-hidden="true">5.5.2.2.</strong> 前端基建</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network/network.html"><strong aria-hidden="true">5.5.2.3.</strong> 网络基建</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/web/web.html"><strong aria-hidden="true">5.5.2.4.</strong> web开发</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/3_media/media.html"><strong aria-hidden="true">5.5.3.</strong> 多媒体</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/3_media/av/av.html"><strong aria-hidden="true">5.5.3.1.</strong> 音视频处理</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/3_media/game/game.html"><strong aria-hidden="true">5.5.3.2.</strong> 游戏开发</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/other.html"><strong aria-hidden="true">5.5.4.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/lang-with-rust/lang_with_rust.html"><strong aria-hidden="true">5.5.4.1.</strong> Rust与其他语言</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/scientific-research/scientific_research.html"><strong aria-hidden="true">5.5.4.2.</strong> 科学艺术研究</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/tools/tools.html"><strong aria-hidden="true">5.5.4.3.</strong> 其他工具</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/6_security/security.html"><strong aria-hidden="true">5.6.</strong> 安全参考</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/business.html"><strong aria-hidden="true">5.7.</strong> 商业观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/blockchain/blockchain.html"><strong aria-hidden="true">5.7.1.</strong> 区块链</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/practices/practices.html"><strong aria-hidden="true">5.7.2.</strong> 生产实践</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/products/products.html"><strong aria-hidden="true">5.7.3.</strong> 优秀产品</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/8_libs/libs.html"><strong aria-hidden="true">5.8.</strong> 基础库</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/9_frameworks/frameworks.html"><strong aria-hidden="true">5.9.</strong> 框架引擎</a></li></ol></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
        <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Programming Anatomy In Rust</h1>

            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/programming_anatomy_in_rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:05 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/virtual_memory.html#%E4%BB%8B%E7%BB%8D">介绍</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:04 UTC 2022 -->
<!--te-->
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>从计算机组成原理了解到操作系统，当一个程序开始运行的时候，不论是可执行程序还是命令行，都会从创建进程，申请进程资源开始，再到堆栈(stack/heap)
的使用，申请与释放资源。这一系列操作对于编程来说重要性不言而喻，只不过根据编程语言的高级程度不同，开发者需要掌握的知识也有不同。</p>
<p>而在rust语言编程中，内存的管理方式及其重要。所以这一层主要先介绍虚拟内存管理以及相关出现的内容安全问题，接着介绍rust是如何通过所有权、作用域和生命周期，引申出借用、移动语义、复制语义等一系列内容来解决内存安全问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存管理与内存安全"><a class="header" href="#内存管理与内存安全">内存管理与内存安全</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权作用域与生命周期"><a class="header" href="#所有权作用域与生命周期">所有权、作用域与生命周期</a></h1>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%B5%B7%E6%BA%90">类型系统起源</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9C%A8%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B">我们为什么需要在语言中使用类型?</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#1-%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%88%B0%E6%B1%87%E7%BC%96">1. 从二进制数据格式到汇编</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#2-%E4%BB%8E%E6%B1%87%E7%BC%96%E5%88%B0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%BA%94%E8%BF%90%E8%80%8C%E7%94%9F">2. 从汇编到编程语言，类型系统应运而生</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#3-%E5%86%8D%E6%9D%A5%E8%AE%A4%E7%9C%9F%E7%9C%8B%E7%9C%8B%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">3. 再来认真看看类型系统</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#4-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E7%BB%84%E8%A7%84%E5%88%99">4. 类型系统其实是一组规则</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#5-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%AF%B9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%89%E5%85%A8%E7%9A%84%E6%8A%BD%E8%B1%A1">5. 类型系统是对内存管理/安全的抽象</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:04 UTC 2022 -->
<!--te-->
<h1 id="类型系统起源"><a class="header" href="#类型系统起源">类型系统起源</a></h1>
<h2 id="我们为什么需要在语言中使用类型"><a class="header" href="#我们为什么需要在语言中使用类型">我们为什么需要在语言中使用类型?</a></h2>
<blockquote>
<p>这是一个很好的问题,可以作为理解编程语言类型系统的契机。</p>
</blockquote>
<h3 id="1-从二进制数据格式到汇编"><a class="header" href="#1-从二进制数据格式到汇编">1. 从二进制数据格式到汇编</a></h3>
<p>作为程序员,我们知道为计算机编写的程序在最底层是以 0 和 1 组成的二进制数据格式表示的。实际上,最早的计算机必须使用机器代码手动编程。最终,程序员意识到这样做非常容易出错,并且乏味、耗时。对大部分人来说,在二进制层面操作和推断这些实体是不切实际的。 到了 20 世纪 50 年代, 编程社区提出了机器代码助记符的概念, 这些助记符变成了今天我们熟知的汇编语言。</p>
<h3 id="2-从汇编到编程语言类型系统应运而生"><a class="header" href="#2-从汇编到编程语言类型系统应运而生">2. 从汇编到编程语言，类型系统应运而生</a></h3>
<p>然后,编程语言应运而生,它们被编译成汇编代码,并允许编程人员编写人类可理解的代码,以方便计算机将其编译成机器代码。然而,大家平时所说的语言表达某些语义比较模糊,因此需要制定一套规则和条件,来表述用类似人类语言编写的计算机程序中可能或不可能存在的内容,即程序语义。这使得我们提出了类型和类型系统的理念。 </p>
<h3 id="3-再来认真看看类型系统"><a class="header" href="#3-再来认真看看类型系统">3. 再来认真看看类型系统</a></h3>
<p>类型是一组具名的可能值。例如,u8 是一种可能包含 0~255 的正数值类型。类型提供了一种方法来弥合我们创建的这些实体的底层表示与心理模型之间的差距。除此之外, 类型还为我们提供了<strong>表示实体的意图、行为和约束的方法</strong>：</p>
<blockquote>
<p>它们定义了用户通过类型能够(不能够) 做什么。 例如, 它没有定义将字符串类型的值和数值类型的值相加的结果是什么。</p>
</blockquote>
<h3 id="4-类型系统其实是一组规则"><a class="header" href="#4-类型系统其实是一组规则">4. 类型系统其实是一组规则</a></h3>
<p>从类型来看,语言设计者构建了类型系统,这些系统是一组规则,用于管理不同类型在编程语言中的交互。它们可以用作推断程序的工具,并有助于确保程序能够正常运行并符合规范。类型系统根据其表达力进行限定,这仅表示你可以使用类型表达逻辑的程度,以及程序中的不变量。</p>
<blockquote>
<p>例如 Haskell 是一种高级语言,它具有非常丰富的表现力的类型系统,而C 语言是一种低级语言,它只为我们提供了很少的基于类型的抽象。Rust 试图在这两个极端之间找到一种平衡。</p>
</blockquote>
<h3 id="5-类型系统是对内存管理安全的抽象"><a class="header" href="#5-类型系统是对内存管理安全的抽象">5. 类型系统是对内存管理/安全的抽象</a></h3>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ol>
<li>&lt;精通Rust(第二版)&gt;-4.1 类型系统及其重要性</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础内置类型"><a class="header" href="#基础内置类型">基础内置类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合类型"><a class="header" href="#集合类型">集合类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义类型"><a class="header" href="#自定义类型">自定义类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型特征及特征对象"><a class="header" href="#泛型特征及特征对象">泛型、特征及特征对象</a></h1>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/rust-traits-deep-dive.png" alt="rust-traits-deep-dive" /></p>
<!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81%E5%8F%8A%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1">泛型、特征及特征对象</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B">泛型</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E5%87%BA%E5%8F%91">从代码复用出发</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E4%B8%8D%E8%B6%B3">函数作用不足</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E8%BF%98%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B%E6%9D%A5%E5%A4%8D%E7%94%A8%E4%BB%A3%E7%A0%81">静态类型语言还需要泛型来复用代码</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%B8%80%E7%A7%8D%E5%8D%95%E6%80%81%E5%8C%96">泛型本质上是一种单态化</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">泛型使用方式</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">泛型函数</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93">泛型结构体</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E6%9E%9A%E4%B8%BE%E4%BD%93">泛型枚举体</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81">泛型特征</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">泛型方法</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#impl-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%9D%97">impl: 泛型实现块</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0">泛型实现</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%B8%93%E9%97%A8%E5%8C%96%E6%B3%9B%E5%9E%8B">专门化泛型</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BE%8B%E5%8C%96">指定类型进行实例化</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%8E%A8%E6%96%AD">基于类型实例化推断</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%9F%90%E4%BA%9B%E6%96%B9%E6%B3%95">泛型函数调用某些方法</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#turbofish-">turbofish: ::&lt;&gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81">特征</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%BB%8E%E5%A4%9A%E6%80%81%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B-%E6%8E%A5%E5%8F%A3%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E7%89%B9%E5%BE%81">从多态和代码复用的角度来看: 接口、鸭子类型还是特征？</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81-1">特征</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88">特征到底是什么？</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F">特征的多种表现形式</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%A0%87%E8%AE%B0%E7%89%B9%E5%BE%81">标记(特征)</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%AE%80%E5%8D%95%E7%89%B9%E5%BE%81">简单(特征)</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81-1">泛型(特征)</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81">关联类型(特征)</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%BB%A7%E6%89%BF%E7%89%B9%E5%BE%81">继承(特征)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81">特征区间：泛型+特征</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:04 UTC 2022 -->
<!--te-->
<h2 id="泛型"><a class="header" href="#泛型">泛型</a></h2>
<h3 id="从代码复用出发"><a class="header" href="#从代码复用出发">从代码复用出发</a></h3>
<h4 id="函数作用不足"><a class="header" href="#函数作用不足">函数作用不足</a></h4>
<p>一直以来，函数的实现方式就是基于c语言的goto指令：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20220613150721312.png" alt="image-20220613150721312" /></p>
<p>通过进一步强化，就得到函数的实现方式：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20220613150804039.png" alt="image-20220613150804039" /></p>
<blockquote>
<p>但是也就这样了，函数只能实现流程上的复用，不能实现类型上的复用。这一点其实在python、js这些动态类型语言上面就不存在这个问题。对于Rust这种静态类型语言，对函数入参类型要求十分严格，于是泛型就应运而生。</p>
</blockquote>
<h4 id="静态类型语言还需要泛型来复用代码"><a class="header" href="#静态类型语言还需要泛型来复用代码">静态类型语言还需要泛型来复用代码</a></h4>
<blockquote>
<p>泛型编程是一种仅适用于静态类型编程语言的技术。它首次出现在 ML 语言中,是一种静态类型的函数式语言。</p>
</blockquote>
<p>像 Python 这样的动态语言采用的是简单类型 (duck typing) , 其中的 API 是根据它们可以做什么,而不是它们是什么来处理参数的,因此不依赖于泛型。</p>
<p>泛型是语言设计特性的一部分, 可以实现代码复用, 并遵循不重复自己的原则 (Don't Repeat Yourself,DRY) 。采用这种技术,你可以使用类型占位符来编写算法、函数、方法及类型, 并在这些类型上指定一个类型变量(
使用单个字母,通常是 T、K 或 V) ,告知编译器在任何代码中实例化它们时要填充的实际类型。这些类型被称为泛型或元素。单个字母(例如类型 T)被称为泛型参数。当你使用或实例化任何泛型元素时,它们会被替换成诸如 u32 这样的具体类型。</p>
<h3 id="泛型本质上是一种单态化"><a class="header" href="#泛型本质上是一种单态化">泛型本质上是一种单态化</a></h3>
<p>每次将泛型元素与具体类型一起使用时,都会在编译时用类型变量 T 生成该代码的特定副本,并将其替换为具体类型。<strong>这种在编译时生成包含具体类型的专用函数的过程被称为单态化,这是执行与多态函数相反的过程。</strong></p>
<h3 id="泛型使用方式"><a class="header" href="#泛型使用方式">泛型使用方式</a></h3>
<blockquote>
<p>在使用泛型时，应该多去考虑它与不同元素结合使用的场景背后的思维方式。泛型可以与结构体、枚举、函数、特征、方法及代码实现块。它们的一个共同特征是泛型的参数是由一对尖头括号分隔,并包含于其中。</p>
</blockquote>
<h4 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h4>
<p>为了创建泛型函数,我们需要将泛型参数放在函数名之后和圆括号之前,如下所示:</p>
<pre><pre class="playground"><code class="language-rust  editable">// generic_function.rs

fn give_me&lt;T&gt;(value: T) {
    let _ = value;
}

fn main() {
    let a = &quot;generics&quot;;
    let b = 1024;
    give_me(a);
    give_me(b);
}
</code></pre></pre>
<h4 id="泛型结构体"><a class="header" href="#泛型结构体">泛型结构体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// generic_struct.rs

struct Container&lt;T&gt; {
    item: T
}

impl&lt;T&gt; Container&lt;T&gt; {
    fn new(item: T) -&gt; Self {
        Container { item }
    }
}

impl Container&lt;u32&gt; {
    fn sum(item: u32) -&gt; Self {
        Container { item }
    }
}

fn main() {
    // todo
}
</code></pre></pre>
<h4 id="泛型枚举体"><a class="header" href="#泛型枚举体">泛型枚举体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// generic_enum.rs

enum Transmission&lt;T&gt; {
    Signal(T),
    NoSignal
}

fn main() {
    // stuff
}
</code></pre></pre>
<h4 id="泛型特征"><a class="header" href="#泛型特征">泛型特征</a></h4>
<h4 id="泛型方法"><a class="header" href="#泛型方法">泛型方法</a></h4>
<h3 id="impl-泛型实现块"><a class="header" href="#impl-泛型实现块">impl: 泛型实现块</a></h3>
<h4 id="泛型实现"><a class="header" href="#泛型实现">泛型实现</a></h4>
<blockquote>
<p>当为任何泛型编写 impl 代码块时,都需要在使用它之前声明泛型参数。T 就像一个变量—— 一个类型变量,我们需要先声明它 impl代码块实际上意味着我们正在为所有类型 T 实现这些方法,它们会出现在 Container<T>中。这个 impl 代码块是一个泛型实现。 因此,生成的每个具体 Container 都将有这些方法。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// generic_struct_impl.rs

struct Container&lt;T&gt; {
    item: T
}

impl&lt;T&gt; Container&lt;T&gt; {
    fn new(item: T) -&gt; Self {
        Container { item }
    }
}

fn main() {
    // stuff
}
</code></pre></pre>
<h4 id="专门化泛型"><a class="header" href="#专门化泛型">专门化泛型</a></h4>
<blockquote>
<p>在这里, 由于 u32 是作为具体类型存在的, 因此我们不需要 impl 之后的<T>, 这是 impl 代码块的另外一个特性,它允许你通过独立实现方法来专门化泛型。 现在,我们也可以通过将 T 替换为任何具体类型来为 Container<T>编写更具体的 impl 代码块。以下就是它的实例:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">impl Container&lt;u32&gt; { 
    fn sum(item: u32) -&gt; Self {
        Container { item }
    } 
}
</code></pre></pre>
<h3 id="指定类型进行实例化"><a class="header" href="#指定类型进行实例化">指定类型进行实例化</a></h3>
<blockquote>
<p>每当我们进行实例化时, 编译器需要在其类型签名中知道 T 的具体类型以便替换,这为其提供了将泛型代码单态化的类型信息。 而具体类型的确定主要有三种方式：</p>
</blockquote>
<ol>
<li>大多数情况下,具体类型是基于类型的实例化推断.</li>
<li>对泛型函数调用某些方法来接收具体类型。</li>
<li>在极个别情况下, 我们需要通过使用 <code>turbofish (::&lt;&gt;)</code>运算符输入具体类型来替代泛型以便辅助编译器识别。</li>
</ol>
<h4 id="基于类型实例化推断"><a class="header" href="#基于类型实例化推断">基于类型实例化推断</a></h4>
<p>这是最常见的方式，主要基于类型特征(trait)。</p>
<h4 id="泛型函数调用某些方法"><a class="header" href="#泛型函数调用某些方法">泛型函数调用某些方法</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// using_generic_func.rs

use std::str;

fn main() {
    let num_from_str = str::parse::&lt;u8&gt;(&quot;34&quot;).unwrap();
    println!(&quot;Parsed number {}&quot;, num_from_str);
}
</code></pre></pre>
<h4 id="turbofish-"><a class="header" href="#turbofish-">turbofish: ::&lt;&gt;</a></h4>
<ol>
<li>如果没有任何类型特征，代码将无法编译：👇</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let a = Vec::new();
}
</code></pre></pre>
<ol start="2">
<li>这时可以用下列三种方式指定</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">// using_generic_vec.rs

fn main() {
    // providing a type
    let v1: Vec&lt;u8&gt; = Vec::new();

    // or calling method
    let mut v2 = Vec::new();
    v2.push(2);    // v2 is now Vec&lt;i32&gt;

    // or using turbofish
    let v3 = Vec::&lt;u8&gt;::new();    // not so readable
}
</code></pre></pre>
<h2 id="特征"><a class="header" href="#特征">特征</a></h2>
<h3 id="从多态和代码复用的角度来看-接口鸭子类型还是特征"><a class="header" href="#从多态和代码复用的角度来看-接口鸭子类型还是特征">从多态和代码复用的角度来看: 接口、鸭子类型还是特征？</a></h3>
<p>从多态和代码复用的角度来看, 在代码中将类型的共享行为和公共属性与其自身隔离通常是一个好主意,并且能拥有专属于自己的方法。在这样做时,我们允许不同类型通过通用属性互相关联,使我们能够为 API 编程,使其参数更通用或更具包容性。</p>
<blockquote>
<p>这意味着我们可以接收具有这些通用属性的类型,而不仅限于某种特定类型。</p>
</blockquote>
<h4 id="接口"><a class="header" href="#接口">接口</a></h4>
<p>类似 Java 和 C#的面向对象编程语言中,接口表达了相同的理念,我们可以在其中定义多种类型能够实现的共享行为。例如,我们可以使用单个 sort 函数接收实现 Comparable 或者 Comparator
接口的元素列表,而不是使用多个 sort 函数接收整数值列表,以及用其他函数接收字符串值列表。这使得我们可以将任何可比较(Comparable)的内容传递给 sort 函数。</p>
<h4 id="鸭子类型"><a class="header" href="#鸭子类型">鸭子类型</a></h4>
<p>而Python同样有明确的特性，被称为&quot;鸭子类型&quot;.</p>
<blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>
</blockquote>
<p>在鸭子类型中，关注点在于对象的行为，能做什么；而不是关注对象所属的类型。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为“鸭子”的对象，并调用它的“走”和“叫”方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的“走”和“叫”方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的“走”和“叫”方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p>
<p>鸭子类型通常得益于“不”测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。</p>
<p>在常规类型中，我们能否在一个特定场景中使用某个对象取决于这个对象的类型，而在鸭子类型中，则取决于这个对象是否具有某种属性或者方法——即只要具备特定的属性或方法，能通过鸭子测试，就可以使用。</p>
<h4 id="特征-1"><a class="header" href="#特征-1">特征</a></h4>
<p>Rust也有一个类似且功能强大的结构,被称为特征。Rust中的特征以多种形式存在, 我们将介绍一些最常见的形式并了解一些与它们简单交互的方式。此外,当特征与泛型搭配使用时,可以限制传递到 API
的参数范围。我们将会对特征进行比较深入的了解。</p>
<h3 id="特征到底是什么"><a class="header" href="#特征到底是什么">特征到底是什么？</a></h3>
<h3 id="特征的多种表现形式"><a class="header" href="#特征的多种表现形式">特征的多种表现形式</a></h3>
<h4 id="标记特征"><a class="header" href="#标记特征">标记(特征)</a></h4>
<h4 id="简单特征"><a class="header" href="#简单特征">简单(特征)</a></h4>
<h4 id="泛型特征-1"><a class="header" href="#泛型特征-1">泛型(特征)</a></h4>
<h4 id="关联类型特征"><a class="header" href="#关联类型特征">关联类型(特征)</a></h4>
<h4 id="继承特征"><a class="header" href="#继承特征">继承(特征)</a></h4>
<h2 id="特征区间泛型特征"><a class="header" href="#特征区间泛型特征">特征区间：泛型+特征</a></h2>
<h2 id="参考资源"><a class="header" href="#参考资源">参考资源</a></h2>
<ol>
<li>&lt;精通rust(第二版)&gt;-第四章：类型、泛型和特征</li>
<li><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">Advanced Traits - The Rust Programming Language</a></li>
<li><a href="https://blog.logrocket.com/rust-traits-a-deep-dive/">Rust traits: A deep dive - LogRocket Blog</a></li>
<li>《代码之髓》- 第五章：函数</li>
<li><a href="https://zh.m.wikipedia.org/zh-hans/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型 - 维基百科，自由的百科全书</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/3_language_grammar/language_grammar.html#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0">编程语言语法概述</a>
<ul>
<li><a href="layer1_underlying_abstract/3_language_grammar/language_grammar.html#%E5%89%8D%E8%A8%80">前言</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:05 UTC 2022 -->
<!--te-->
<h1 id="编程语言语法概述"><a class="header" href="#编程语言语法概述">编程语言语法概述</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>其实编程语言的语法本质上就分成三部分：确定使用什么类型、类型可以用的操作、通用逻辑操作。不过语法又不是这么简单，它担负着两方面的作用：</p>
<ol>
<li>与编译器交互：因为这些语法在编译器内部都有对应的操作，涉及一系列繁杂的自动化操作。所以当编写语法可以通过编译，至少说明程序可以跑起来。这一点在rust中尤其明显，毕竟rust是出了名的“面向编译器”开发语言，编译器对语法的要求可以算作“苛刻”。但是这样也有好处，就是潜移默化之中，编程思维也被调整一番。</li>
<li>与编程人员交互：这里主要指编程需要可读且易读。这和代码质量息息相关，这里的编程人员不仅包括第一个写出这段代码的人，还包括后续开发以及协作的开发人员。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="词法关键字扫盲"><a class="header" href="#词法关键字扫盲">词法关键字扫盲</a></h1>
<h2 id="1-关键字"><a class="header" href="#1-关键字">1. 关键字</a></h2>
<h3 id="严格关键字"><a class="header" href="#严格关键字">严格关键字</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>as / break / const / continue / crate / if / else / struct / enum / true / false / fn / for / in / let / loop / impl / mod / match / move mut / pub / ref / return / self / Self / static / super /trait / type / unsafe /use / where / while / async /await/dyn/main
<span class="boring">}
</span></code></pre></pre>
<h3 id="弱关键字"><a class="header" href="#弱关键字">弱关键字</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>abstract / become / box / do / final / macro / override / priv / typeof / unsized / virtual / yield / try
<span class="boring">}
</span></code></pre></pre>
<h3 id="保留字"><a class="header" href="#保留字">保留字</a></h3>
<ul>
<li>2018 Edition:union,'static</li>
<li>2015 Edition:dyn</li>
</ul>
<blockquote>
<p>被保留的关键字不代表将来一定会使用</p>
</blockquote>
<h2 id="2-标识符"><a class="header" href="#2-标识符">2. 标识符</a></h2>
<h2 id="3-注释"><a class="header" href="#3-注释">3. 注释</a></h2>
<blockquote>
<p>//!, /<em>!, //!!, /</em>!!, /<strong>...<em>/, //, ////, /</em></strong>...*/</p>
</blockquote>
<h2 id="4-空白-nttab"><a class="header" href="#4-空白-nttab">4. 空白: \n、\t、tab</a></h2>
<blockquote>
<p>任何形式的空白字符在RuSt中只用于分隔标记，没有语义意义。</p>
</blockquote>
<h2 id="5-词条"><a class="header" href="#5-词条">5. 词条</a></h2>
<ol>
<li>语言项(item)</li>
<li>块(block)</li>
<li>语句（Stmt)</li>
<li>表达式（Expr)</li>
<li>模式（Pattern)</li>
<li>关键字（Keyword)</li>
<li>标识符（Ident)</li>
<li>字面量(Literal)</li>
<li>生命周期(Lifetime)</li>
<li>可见性(Vis)</li>
<li>标点符号（Punctuation)</li>
<li>分隔符（delimiter)</li>
<li>词条树(Token Tree)</li>
<li>属性（Attribute)</li>
</ol>
<h2 id="路径--"><a class="header" href="#路径--">路径: ::, ::&lt;&gt;</a></h2>
<h2 id="参考资源-1"><a class="header" href="#参考资源-1">参考资源</a></h2>
<ol>
<li><a href="https://time.geekbang.org/course/detail/100060601-286522">词法结构</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="绑定赋值与匹配"><a class="header" href="#绑定赋值与匹配">绑定、赋值与匹配</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="逻辑判断与循环"><a class="header" href="#逻辑判断与循环">逻辑判断与循环</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:06 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:05 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面向对象编程"><a class="header" href="#面向对象编程">面向对象编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型编程"><a class="header" href="#泛型编程">泛型编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:06 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:06 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="模块相关"><a class="header" href="#模块相关">模块相关</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo及类似包管理器介绍"><a class="header" href="#cargo及类似包管理器介绍">Cargo及类似包管理器介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:07 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:07 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="从io模型开始"><a class="header" href="#从io模型开始">从IO模型开始</a></h1>
<!--ts-->
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E4%BB%8Eio%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%A7%8B">从IO模型开始</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#1-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB">1. 同步/异步、阻塞/非阻塞概念区别</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%B0%83%E7%94%A8%E8%80%85%E8%A7%86%E8%A7%92">同步和异步，关注的是消息通信机制。（调用者视角）</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%E7%A8%8B%E5%BA%8F%E7%AD%89%E5%BE%85%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C%E7%9A%84%E7%8A%B6%E6%80%81%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E8%A7%86%E8%A7%92">阻塞和非阻塞，关注的是程序等待调用结果的状态。（被调用者视角）</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E9%98%BB%E5%A1%9E%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9C%89%E5%85%B3">阻塞，与系统调用有关。</a></li>
</ul>
</li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#2-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5io-%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB">2. 同步/异步IO 模型分类</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#3-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9Eio-blocking-io">3. 同步阻塞I/O (blocking I/O)</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#4-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io-multiplexing-">4. I/O 多路复用（I/O Multiplexing )</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#5-epoll-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B">5. epoll: 同步阻塞/非阻塞模型</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#epoll%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0">epoll三个函数</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#epoll-%E4%B8%A4%E7%A7%8D%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6">epoll 两种触发机制：</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E6%83%8A%E7%BE%A4%E9%97%AE%E9%A2%98">惊群问题：</a></li>
</ul>
</li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#6-%E5%BC%82%E6%AD%A5-io-%E6%A8%A1%E5%9E%8B-io_uring">6. 异步 I/O 模型: io_uring</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#1-reactor%E5%8F%8D%E5%BA%94%E5%99%A8-%E6%A8%A1%E5%BC%8F">1. Reactor（反应器） 模式</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#2-preactor%E4%B8%BB%E5%8A%A8%E5%99%A8-%E6%A8%A1%E5%BC%8F">2. Preactor（主动器） 模式</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#reactor-model">Reactor Model:</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">三种实现方式：</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B">读写操作流程：</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E5%8F%82%E4%B8%8E%E8%80%85">参与者：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:07 UTC 2022 -->
<!--te-->
<h2 id="1-同步异步阻塞非阻塞概念区别"><a class="header" href="#1-同步异步阻塞非阻塞概念区别">1. 同步/异步、阻塞/非阻塞概念区别</a></h2>
<h3 id="同步和异步关注的是消息通信机制调用者视角"><a class="header" href="#同步和异步关注的是消息通信机制调用者视角">同步和异步，关注的是消息通信机制。（调用者视角）</a></h3>
<ul>
<li>同步，发出一个调用，在没有得到结果之前不返回。</li>
<li>异步，发出一个调用，在没有得到结果之前返回。</li>
</ul>
<h3 id="阻塞和非阻塞关注的是程序等待调用结果的状态被调用者视角"><a class="header" href="#阻塞和非阻塞关注的是程序等待调用结果的状态被调用者视角">阻塞和非阻塞，关注的是程序等待调用结果的状态。（被调用者视角）</a></h3>
<ul>
<li>阻塞，在调用结果返回之前，线程被挂起。</li>
<li>非阻塞，在调用结果返回之前，线程不会被挂起。</li>
</ul>
<h3 id="阻塞与系统调用有关"><a class="header" href="#阻塞与系统调用有关">阻塞，与系统调用有关。</a></h3>
<h2 id="2-同步异步io-模型分类"><a class="header" href="#2-同步异步io-模型分类">2. 同步/异步IO 模型分类</a></h2>
<pre><code class="language-text">                                 +-+ 阻 塞 I/O (BIO)
                                 |
                                 +-+ 非 阻 塞 I/O (NIO)
                                 |
              +----+ 同 步 I/O +--+
              |                  |
              |                  +-+ I/O 多 路 复 用
              |                  |
              |                  +-+ 信 号 驱 动 I/O
I/O 模 型  +---+
              |
              |
              |                  +-+ Linux (AIO)
              |                  |         (io_uring)
              +----+ 异 步 I/O +--+
                                 |
                                 +-+ windows (IOCP)

</code></pre>
<h2 id="3-同步阻塞io-blocking-io"><a class="header" href="#3-同步阻塞io-blocking-io">3. 同步阻塞I/O (blocking I/O)</a></h2>
<pre><code class="language-text">Application               kernel
+---------+            +-----------+  +---+
|         |   syscall  | no        |      |
|   Read  | +--------&gt; | datagram  |      |
| recvfrom|            | ready     |      |
|         |            |    +      |      +-+ wait for
|         |            |    |      |      +-+ data
|         |            |    v      |      |
|         |            | datagram  |      |
|         |            | ready     |  +---+
|         |            |           |
|         |            | copy      |  +---+
|         |            | datagram  |      |
|process  |            |    +      |      +-+ copy data
|datagram |   return   |    |      |      +-+ from kernel to user
|         | &lt;--------+ |    v      |      |
|         |            |  copy     |  +---+
|         |            |  complete |
+---------+            +-----------+
</code></pre>
<blockquote>
<p>输入操作两个阶段：</p>
</blockquote>
<ol>
<li>进程等待内核把数据准备好；这个阶段可以阻塞也可非阻塞，设置socket属性。
<ul>
<li>阻塞： recvfrom 阻塞线程直到返回数据就绪的结果。</li>
<li>非阻塞：立即返回一个错误，轮询直到数据就绪。</li>
</ul>
</li>
<li>从内核缓冲区向进程缓冲区复制数据。（一直阻塞）</li>
</ol>
<p>异步I/O，recvfrom总是立即返回，两个阶段都由内核完成。</p>
<h2 id="4-io-多路复用io-multiplexing-"><a class="header" href="#4-io-多路复用io-multiplexing-">4. I/O 多路复用（I/O Multiplexing )</a></h2>
<p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄。</p>
<p>支持I/O多路复用的系统调用有 select/pselect/poll/epoll，本质都是同步I/O，因为数据拷贝都是阻塞的。
通过 select/epoll 来判断数据报是否准备好，即判断可读可写状态。</p>
<h2 id="5-epoll-同步阻塞非阻塞模型"><a class="header" href="#5-epoll-同步阻塞非阻塞模型">5. epoll: 同步阻塞/非阻塞模型</a></h2>
<pre><code class="language-text">                        +--------------------------------+     +-------------------------+
                        | epoll_ctl                      |     | epoll_wait              |
                        |                                |     |                         |
                        |                                |     |         +----+          |
                        |                 +---+          |     |         |    |          |
                        |                 |   |          |     |         |    |          |
                        |               +-+---+--+       |     |         +--+-+          |
                        |               |        |       |     |            |            |
                        |            +--++     +-++      |     |            |            |
epoll_create  +----&gt;    |            |   |     |  |      |     |         +--+-+          |
                        |            +-+-+     +--+      +----&gt;+         |    |          |
                        |              |                 |event|         |    |          |
                        |         +----+--+              |     |         +--+-+          |
                        |         |       |              |     |            |            |
                        |         ++      |              |     |            |            |
                        |        +--+   +-+-+            |     |         +--+-+          |
                        |        |  |   |   |            |     |         |    |          |
                        |        +--+   +---+            |     |         |    |          |
                        |                                |     |         +----+          |
                        |                    红 黑 树     |     |                 链 表    |
                        +--------------------------------+     +-------------------------+


</code></pre>
<h3 id="epoll三个函数"><a class="header" href="#epoll三个函数">epoll三个函数</a></h3>
<ul>
<li>epoll_create(int size) : 内核产生一个epoll实例数据结构，并返回一个epfd</li>
<li>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)：将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。</li>
<li>epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout): 阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入events数组中</li>
</ul>
<h3 id="epoll-两种触发机制"><a class="header" href="#epoll-两种触发机制">epoll 两种触发机制：</a></h3>
<ul>
<li>水平触发机制（LT)。缓冲区只要有数据就触发读写。epoll 默认工作方式。select/poll只支持该方式。</li>
<li>边缘触发机制（ET)。缓冲区空或满的状态才触发读写。nginx 使用该方式，避免频繁读写。</li>
</ul>
<h3 id="惊群问题"><a class="header" href="#惊群问题">惊群问题：</a></h3>
<p>当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。
Liux 4.5 通过引入 EPOLLEXCLUSIVE 标识来保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的惊群问题。</p>
<h2 id="6-异步-io-模型-io_uring"><a class="header" href="#6-异步-io-模型-io_uring">6. 异步 I/O 模型: io_uring</a></h2>
<p>Linux AIO 实现的并不理想，所以引入了新的异步I/O接口 io_uring。</p>
<pre><code class="language-text">+----+ Head  +---------+               +----------+ Head
|            |         |               |          |
|            |         |               |          |
|            +---------+               +----------+
|            |         |               |          |
|            |         |               |          |
|            +---------+               +----------+
|            |         |               |          |
|            |         |               |          |
|            +---------+               +----------+
|            |         |               |          |
|      Tail  +---------+               +----------+ Tail &lt;--+
|        +--------------------------------------------+     |
|        | Kernel                                     |     |
|        |                                            |     |
|        |        +-------+              +-------+    |     |
|        |        |       |              |       |    |     |
+---------------&gt; | SQ    |              |  CQ   | +--------+
         |        |       |              |       |    |
         |        +-------+              +-------+    |
         |                                            |
         +--------------------------------------------+

</code></pre>
<p>io_uring接口通过两个主要数据结构工作：</p>
<ul>
<li>提交队列条目（sqe）</li>
<li>完成队列条目（cqe）</li>
</ul>
<p>这些结构的实例位于内核和应用程序之间的<strong>共享内存</strong>单生产者单消费者环形缓冲区中。</p>
<p>参考：</p>
<p><a href="https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/">https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/</a></p>
<p><a href="https://cor3ntin.github.io/posts/iouring/#io_uring">https://cor3ntin.github.io/posts/iouring/#io_uring</a></p>
<blockquote>
<p>因为处理 I/O 复用的编程模型相当复杂，为了简化编程，引入了下面两种模型:</p>
</blockquote>
<h3 id="1-reactor反应器-模式"><a class="header" href="#1-reactor反应器-模式">1. Reactor（反应器） 模式</a></h3>
<p>对应同步I/O，被动的事件分离和分发模型。服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。</p>
<h3 id="2-preactor主动器-模式"><a class="header" href="#2-preactor主动器-模式">2. Preactor（主动器） 模式</a></h3>
<p>对应异步I/O，主动的事件分离和分发模型。这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）。</p>
<h3 id="reactor-model"><a class="header" href="#reactor-model">Reactor Model:</a></h3>
<pre><code class="language-text">                                                     +----------------+
req                                        Dispatch  |                |
+------+                                  +--------&gt; | req handler    |
|      |                                  |          +----------------+
|      | +----+                           |
+------+      | event    +------------+   |
              |          |            |   |
              +--------&gt; |  Service   |   |Dispatch  +----------------+
                         |  Handler   +------------&gt; |                |
req          +---------&gt; |            |   |          | req handler    |
+------+     |           +------------+   |          +----------------+
|      |     | event                      |
|      +----+                             |
+------+                                  | Dispatch +----------------+
                                          +---------&gt;+                |
                                                     | req handler    |
                                                     +----------------+

</code></pre>
<h4 id="三种实现方式"><a class="header" href="#三种实现方式">三种实现方式：</a></h4>
<ul>
<li>单线程模式。 accept()、read()、write()以及connect()操作 都在同一线程。</li>
<li>工作者线程池模式。非 I/O 操作交给线程池处理</li>
<li>多线程模式。主Reactor (master) ，负责网络监听 ， 子Reactor(worker) 读写网络数据。</li>
</ul>
<h4 id="读写操作流程"><a class="header" href="#读写操作流程">读写操作流程：</a></h4>
<ol>
<li>应用注册读写就绪事件和相关联的事件处理器</li>
<li>事件分离器等待事件发生</li>
<li>当发生读写就绪事件，事件分离器调用已注册的事件处理器</li>
<li>事件处理器执行读写操作</li>
</ol>
<h4 id="参与者"><a class="header" href="#参与者">参与者：</a></h4>
<ol>
<li>描述符（handle）：操作系统提供的资源，识别 socket等。</li>
<li>同步事件多路分离器。开启事件循环，等待事件的发生。封装了 多路复用函数 select/poll/epoll等。</li>
<li>事件处理器。提供回调函数，用于描述与应用程序相关的某个事件的操作。</li>
<li>具体的事件处理器。事件处理器接口的具体实现。使用描述符来识别事件和程序提供的服务。</li>
<li>Reactor 管理器。事件处理器的调度核心。分离每个事件，调度事件管理器，调用具体的函数处理某个事件。</li>
</ol>
<h2 id="参考资源-2"><a class="header" href="#参考资源-2">参考资源</a></h2>
<ul>
<li><a href="https://time.geekbang.org/course/detail/100060601-365835">88. IO模型</a></li>
<li><a href="https://time.geekbang.org/course/detail/100060601-365838">89. epoll和io_uring</a></li>
<li><a href="https://time.geekbang.org/course/detail/100060601-367808">90. 事件驱动编程模型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:07 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:07 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:07 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:07 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Added by: kuanhsiaokuo, at: Thu Jun  2 23:19:28 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="学习资源"><a class="header" href="#学习资源">学习资源</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/1_learning_resource/learning_resource.html#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">学习资源</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 10:22:08 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="官方动态"><a class="header" href="#官方动态">官方动态</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="社区特点"><a class="header" href="#社区特点">社区特点</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="学术动态"><a class="header" href="#学术动态">学术动态</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开源观察"><a class="header" href="#开源观察">开源观察</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据处理"><a class="header" href="#数据处理">数据处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入式"><a class="header" href="#嵌入式">嵌入式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能工具"><a class="header" href="#性能工具">性能工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="云原生"><a class="header" href="#云原生">云原生</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前端开发"><a class="header" href="#前端开发">前端开发</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络基建"><a class="header" href="#网络基建">网络基建</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络开发"><a class="header" href="#网络开发">网络开发</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="音视频处理"><a class="header" href="#音视频处理">音视频处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="游戏与图像处理"><a class="header" href="#游戏与图像处理">游戏与图像处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rust与其他编程语言"><a class="header" href="#rust与其他编程语言">Rust与其他编程语言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="科学艺术研究"><a class="header" href="#科学艺术研究">科学艺术研究</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他工具"><a class="header" href="#其他工具">其他工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全参考"><a class="header" href="#安全参考">安全参考</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="商业观察"><a class="header" href="#商业观察">商业观察</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链"><a class="header" href="#区块链">区块链</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生产实践"><a class="header" href="#生产实践">生产实践</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优秀产品"><a class="header" href="#优秀产品">优秀产品</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础库"><a class="header" href="#基础库">基础库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="框架引擎"><a class="header" href="#框架引擎">框架引擎</a></h1>

            </main>

            <script src="https://utteranc.es/client.js"
                    repo="RustMagazine/rust_magazine_2022"
                    issue-term="title"
                    theme="github-light"
                    crossorigin="anonymous"
                    async></script>

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
    </nav>

</div>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="mermaid.min.js"></script>
    <script type="text/javascript" src="mermaid-init.js"></script>
    <script type="text/javascript" src="smart-anchor.js"></script>
    <script type="text/javascript" src="sidebar.js"></script>
        <script type="text/javascript">
            window.addEventListener('load', function () {
                MathJax.Hub.Register.StartupHook('End', function () {
                    window.setTimeout(window.print, 100);
                });
            });
        </script>
</body>
</html>
