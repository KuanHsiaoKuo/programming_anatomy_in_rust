<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Programming Anatomy In Rust</title>
        <meta name="robots" content="noindex"/>
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust为例分享学习编程常考虑的方方面面">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="style.css">
        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/layer1_underlying_abstract.html"><strong aria-hidden="true">1.</strong> Layer1: 底层抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/1_virtual_memory/virtual_memory.html"><strong aria-hidden="true">1.1.</strong> 虚拟内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/1_virtual_memory/memory_manage_safety.html"><strong aria-hidden="true">1.1.1.</strong> 内存管理与内存安全</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/1_virtual_memory/ownership_scope_lifetime.html"><strong aria-hidden="true">1.1.2.</strong> 所有权、作用域与生命周期</a></li></ol></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/type_system.html"><strong aria-hidden="true">1.2.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/primitive_types.html"><strong aria-hidden="true">1.2.1.</strong> 基础内置类型</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/collections.html"><strong aria-hidden="true">1.2.2.</strong> 集合类型</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/user_defined_types.html"><strong aria-hidden="true">1.2.3.</strong> 自定义类型</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html"><strong aria-hidden="true">1.2.4.</strong> 泛型、特征及特征对象</a></li></ol></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/language_grammar.html"><strong aria-hidden="true">1.3.</strong> 语言语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/keywords_glossary.html"><strong aria-hidden="true">1.3.1.</strong> 词法结构扫盲</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/binding_match.html"><strong aria-hidden="true">1.3.2.</strong> 绑定、赋值与匹配</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/logical_decision_loops.html"><strong aria-hidden="true">1.3.3.</strong> 逻辑判断与循环♻️</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/statements_expressions.html"><strong aria-hidden="true">1.3.4.</strong> 语句与表达式</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer2_design_abstract/layer2_design_abstract.html"><strong aria-hidden="true">2.</strong> Layer2: 设计抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/4_programming_paradigm.html"><strong aria-hidden="true">2.1.</strong> 编程范式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/fp.html"><strong aria-hidden="true">2.1.1.</strong> 函数式编程</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/oop.html"><strong aria-hidden="true">2.1.2.</strong> 面向对象编程</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/gp.html"><strong aria-hidden="true">2.1.3.</strong> 泛型编程</a></li></ol></li><li class="chapter-item expanded "><a href="layer2_design_abstract/5_design_pattern/5_design_pattern.html"><strong aria-hidden="true">2.2.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/6_module_manage.html"><strong aria-hidden="true">2.3.</strong> 模块管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/module_relate.html"><strong aria-hidden="true">2.3.1.</strong> 模块使用</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/cargo_basic.html"><strong aria-hidden="true">2.3.2.</strong> Cargo基础</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/cargo_plugins.html"><strong aria-hidden="true">2.3.3.</strong> Cargo扩展</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer3_task_abstract/layer3_task_abstract.html"><strong aria-hidden="true">3.</strong> Layer3: 任务抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/7_concurrency.html"><strong aria-hidden="true">3.1.</strong> 并发编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/io_models.html"><strong aria-hidden="true">3.1.1.</strong> 系统IO模型</a></li><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/1_multi_models/multi_models.html"><strong aria-hidden="true">3.1.2.</strong> 多线程模型</a></li><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/2_async_models/async_models.html"><strong aria-hidden="true">3.1.3.</strong> 异步模型</a></li></ol></li><li class="chapter-item expanded "><a href="layer3_task_abstract/8_meta_programming/8_meta_programming.html"><strong aria-hidden="true">3.2.</strong> 元编程</a></li></ol></li><li class="chapter-item expanded "><a href="layer4_protocol_abstract/layer4_protocol_abstract.html"><strong aria-hidden="true">4.</strong> Layer4: 协议抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer4_protocol_abstract/9_multilingual_programming/9_multilingual_programming.html"><strong aria-hidden="true">4.1.</strong> 跨语言编程</a></li><li class="chapter-item expanded "><a href="layer4_protocol_abstract/10_computer_network/10_computer_network.html"><strong aria-hidden="true">4.2.</strong> 计算机网络</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/layer5_ecosystem.html"><strong aria-hidden="true">5.</strong> Layer5: 生态环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/learning_resource.html"><strong aria-hidden="true">5.1.</strong> 学习资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/1_books/books.html"><strong aria-hidden="true">5.1.1.</strong> 书籍整理</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/2_courses/courses.html"><strong aria-hidden="true">5.1.2.</strong> 线上课程</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/3_blogs/blogs.html"><strong aria-hidden="true">5.1.3.</strong> 博客文章</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/4_videos/videos.html"><strong aria-hidden="true">5.1.4.</strong> 在线视频</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/5_projects/projects.html"><strong aria-hidden="true">5.1.5.</strong> 开源项目</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/2_lang_update/lang_update.html"><strong aria-hidden="true">5.2.</strong> 官方动态</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/3_community/community.html"><strong aria-hidden="true">5.3.</strong> 社区热点</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/4_academic/academic.html"><strong aria-hidden="true">5.4.</strong> 学术讨论</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/open_source.html"><strong aria-hidden="true">5.5.</strong> 开源观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/underlying.html"><strong aria-hidden="true">5.5.1.</strong> 底层开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/command/command.html"><strong aria-hidden="true">5.5.1.1.</strong> 命令行工具</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/data/data.html"><strong aria-hidden="true">5.5.1.2.</strong> 数据处理</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/embedded/embedded.html"><strong aria-hidden="true">5.5.1.3.</strong> 嵌入式</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/os/os.html"><strong aria-hidden="true">5.5.1.4.</strong> 系统开发</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/performance/performance.html"><strong aria-hidden="true">5.5.1.5.</strong> 性能工具</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network.html"><strong aria-hidden="true">5.5.2.</strong> 网络相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/cloud/cloud.html"><strong aria-hidden="true">5.5.2.1.</strong> 云原生</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/frontend/frontend.html"><strong aria-hidden="true">5.5.2.2.</strong> 前端基建</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network/network.html"><strong aria-hidden="true">5.5.2.3.</strong> 网络基建</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/web/web.html"><strong aria-hidden="true">5.5.2.4.</strong> web开发</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/3_media/media.html"><strong aria-hidden="true">5.5.3.</strong> 多媒体</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/3_media/av/av.html"><strong aria-hidden="true">5.5.3.1.</strong> 音视频处理</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/3_media/game/game.html"><strong aria-hidden="true">5.5.3.2.</strong> 游戏开发</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/other.html"><strong aria-hidden="true">5.5.4.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/lang-with-rust/lang_with_rust.html"><strong aria-hidden="true">5.5.4.1.</strong> Rust与其他语言</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/scientific-research/scientific_research.html"><strong aria-hidden="true">5.5.4.2.</strong> 科学艺术研究</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/tools/tools.html"><strong aria-hidden="true">5.5.4.3.</strong> 其他工具</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/6_security/security.html"><strong aria-hidden="true">5.6.</strong> 安全参考</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/business.html"><strong aria-hidden="true">5.7.</strong> 商业观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/blockchain/blockchain.html"><strong aria-hidden="true">5.7.1.</strong> 区块链</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/practices/practices.html"><strong aria-hidden="true">5.7.2.</strong> 生产实践</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/products/products.html"><strong aria-hidden="true">5.7.3.</strong> 优秀产品</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/8_libs/libs.html"><strong aria-hidden="true">5.8.</strong> 基础库</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/9_frameworks/frameworks.html"><strong aria-hidden="true">5.9.</strong> 框架引擎</a></li></ol></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
        <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Programming Anatomy In Rust</h1>

            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/programming_anatomy_in_rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:02 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/virtual_memory.html#%E4%BB%8B%E7%BB%8D">介绍</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:00 UTC 2022 -->
<!--te-->
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>从计算机组成原理了解到操作系统，当一个程序开始运行的时候，不论是可执行程序还是命令行，都会从创建进程，申请进程资源开始，再到堆栈(stack/heap)
的使用，申请与释放资源。这一系列操作对于编程来说重要性不言而喻，只不过根据编程语言的高级程度不同，开发者需要掌握的知识也有不同。</p>
<p>而在rust语言编程中，内存的管理方式及其重要。所以这一层主要先介绍虚拟内存管理以及相关出现的内容安全问题，接着介绍rust是如何通过所有权、作用域和生命周期，引申出借用、移动语义、复制语义等一系列内容来解决内存安全问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存管理与内存安全"><a class="header" href="#内存管理与内存安全">内存管理与内存安全</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权作用域与生命周期"><a class="header" href="#所有权作用域与生命周期">所有权、作用域与生命周期</a></h1>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%B5%B7%E6%BA%90">类型系统起源</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9C%A8%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B">我们为什么需要在语言中使用类型?</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#1-%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%88%B0%E6%B1%87%E7%BC%96">1. 从二进制数据格式到汇编</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#2-%E4%BB%8E%E6%B1%87%E7%BC%96%E5%88%B0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%BA%94%E8%BF%90%E8%80%8C%E7%94%9F">2. 从汇编到编程语言，类型系统应运而生</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#3-%E5%86%8D%E6%9D%A5%E8%AE%A4%E7%9C%9F%E7%9C%8B%E7%9C%8B%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">3. 再来认真看看类型系统</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#4-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E7%BB%84%E8%A7%84%E5%88%99">4. 类型系统其实是一组规则</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#5-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%AF%B9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%89%E5%85%A8%E7%9A%84%E6%8A%BD%E8%B1%A1">5. 类型系统是对内存管理/安全的抽象</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:01 UTC 2022 -->
<!--te-->
<h1 id="类型系统起源"><a class="header" href="#类型系统起源">类型系统起源</a></h1>
<h2 id="我们为什么需要在语言中使用类型"><a class="header" href="#我们为什么需要在语言中使用类型">我们为什么需要在语言中使用类型?</a></h2>
<blockquote>
<p>这是一个很好的问题,可以作为理解编程语言类型系统的契机。</p>
</blockquote>
<h3 id="1-从二进制数据格式到汇编"><a class="header" href="#1-从二进制数据格式到汇编">1. 从二进制数据格式到汇编</a></h3>
<p>作为程序员,我们知道为计算机编写的程序在最底层是以 0 和 1 组成的二进制数据格式表示的。实际上,最早的计算机必须使用机器代码手动编程。最终,程序员意识到这样做非常容易出错,并且乏味、耗时。对大部分人来说,在二进制层面操作和推断这些实体是不切实际的。 到了 20 世纪 50 年代, 编程社区提出了机器代码助记符的概念, 这些助记符变成了今天我们熟知的汇编语言。</p>
<h3 id="2-从汇编到编程语言类型系统应运而生"><a class="header" href="#2-从汇编到编程语言类型系统应运而生">2. 从汇编到编程语言，类型系统应运而生</a></h3>
<p>然后,编程语言应运而生,它们被编译成汇编代码,并允许编程人员编写人类可理解的代码,以方便计算机将其编译成机器代码。然而,大家平时所说的语言表达某些语义比较模糊,因此需要制定一套规则和条件,来表述用类似人类语言编写的计算机程序中可能或不可能存在的内容,即程序语义。这使得我们提出了类型和类型系统的理念。 </p>
<h3 id="3-再来认真看看类型系统"><a class="header" href="#3-再来认真看看类型系统">3. 再来认真看看类型系统</a></h3>
<p>类型是一组具名的可能值。例如,u8 是一种可能包含 0~255 的正数值类型。类型提供了一种方法来弥合我们创建的这些实体的底层表示与心理模型之间的差距。除此之外, 类型还为我们提供了<strong>表示实体的意图、行为和约束的方法</strong>：</p>
<blockquote>
<p>它们定义了用户通过类型能够(不能够) 做什么。 例如, 它没有定义将字符串类型的值和数值类型的值相加的结果是什么。</p>
</blockquote>
<h3 id="4-类型系统其实是一组规则"><a class="header" href="#4-类型系统其实是一组规则">4. 类型系统其实是一组规则</a></h3>
<p>从类型来看,语言设计者构建了类型系统,这些系统是一组规则,用于管理不同类型在编程语言中的交互。它们可以用作推断程序的工具,并有助于确保程序能够正常运行并符合规范。类型系统根据其表达力进行限定,这仅表示你可以使用类型表达逻辑的程度,以及程序中的不变量。</p>
<blockquote>
<p>例如 Haskell 是一种高级语言,它具有非常丰富的表现力的类型系统,而C 语言是一种低级语言,它只为我们提供了很少的基于类型的抽象。Rust 试图在这两个极端之间找到一种平衡。</p>
</blockquote>
<h3 id="5-类型系统是对内存管理安全的抽象"><a class="header" href="#5-类型系统是对内存管理安全的抽象">5. 类型系统是对内存管理/安全的抽象</a></h3>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ol>
<li>&lt;精通Rust(第二版)&gt;-4.1 类型系统及其重要性</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础内置类型"><a class="header" href="#基础内置类型">基础内置类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合类型"><a class="header" href="#集合类型">集合类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义类型"><a class="header" href="#自定义类型">自定义类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/3_language_grammar/language_grammar.html#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0">编程语言语法概述</a>
<ul>
<li><a href="layer1_underlying_abstract/3_language_grammar/language_grammar.html#%E5%89%8D%E8%A8%80">前言</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:02 UTC 2022 -->
<!--te-->
<h1 id="编程语言语法概述"><a class="header" href="#编程语言语法概述">编程语言语法概述</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>其实编程语言的语法本质上就分成三部分：确定使用什么类型、类型可以用的操作、通用逻辑操作。不过语法又不是这么简单，它担负着两方面的作用：</p>
<ol>
<li>与编译器交互：因为这些语法在编译器内部都有对应的操作，涉及一系列繁杂的自动化操作。所以当编写语法可以通过编译，至少说明程序可以跑起来。这一点在rust中尤其明显，毕竟rust是出了名的“面向编译器”开发语言，编译器对语法的要求可以算作“苛刻”。但是这样也有好处，就是潜移默化之中，编程思维也被调整一番。</li>
<li>与编程人员交互：这里主要指编程需要可读且易读。这和代码质量息息相关，这里的编程人员不仅包括第一个写出这段代码的人，还包括后续开发以及协作的开发人员。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="词法关键字扫盲"><a class="header" href="#词法关键字扫盲">词法关键字扫盲</a></h1>
<h2 id="1-关键字"><a class="header" href="#1-关键字">1. 关键字</a></h2>
<h3 id="严格关键字"><a class="header" href="#严格关键字">严格关键字</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>as / break / const / continue / crate / if / else / struct / enum / true / false / fn / for / in / let / loop / impl / mod / match / move mut / pub / ref / return / self / Self / static / super /trait / type / unsafe /use / where / while / async /await/dyn/main
<span class="boring">}
</span></code></pre></pre>
<h3 id="弱关键字"><a class="header" href="#弱关键字">弱关键字</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>abstract / become / box / do / final / macro / override / priv / typeof / unsized / virtual / yield / try
<span class="boring">}
</span></code></pre></pre>
<h3 id="保留字"><a class="header" href="#保留字">保留字</a></h3>
<ul>
<li>2018 Edition:union,'static</li>
<li>2015 Edition:dyn</li>
</ul>
<blockquote>
<p>被保留的关键字不代表将来一定会使用</p>
</blockquote>
<h2 id="2-标识符"><a class="header" href="#2-标识符">2. 标识符</a></h2>
<h2 id="3-注释"><a class="header" href="#3-注释">3. 注释</a></h2>
<blockquote>
<p>//!, /<em>!, //!!, /</em>!!, /<strong>...<em>/, //, ////, /</em></strong>...*/</p>
</blockquote>
<h2 id="4-空白-nttab"><a class="header" href="#4-空白-nttab">4. 空白: \n、\t、tab</a></h2>
<blockquote>
<p>任何形式的空白字符在RuSt中只用于分隔标记，没有语义意义。</p>
</blockquote>
<h2 id="5-词条"><a class="header" href="#5-词条">5. 词条</a></h2>
<ol>
<li>语言项(item)</li>
<li>块(block)</li>
<li>语句（Stmt)</li>
<li>表达式（Expr)</li>
<li>模式（Pattern)</li>
<li>关键字（Keyword)</li>
<li>标识符（Ident)</li>
<li>字面量(Literal)</li>
<li>生命周期(Lifetime)</li>
<li>可见性(Vis)</li>
<li>标点符号（Punctuation)</li>
<li>分隔符（delimiter)</li>
<li>词条树(Token Tree)</li>
<li>属性（Attribute)</li>
</ol>
<h2 id="路径--"><a class="header" href="#路径--">路径: ::, ::&lt;&gt;</a></h2>
<h2 id="参考资源"><a class="header" href="#参考资源">参考资源</a></h2>
<ol>
<li><a href="https://time.geekbang.org/course/detail/100060601-286522">词法结构</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="绑定赋值与匹配"><a class="header" href="#绑定赋值与匹配">绑定、赋值与匹配</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="逻辑判断与循环"><a class="header" href="#逻辑判断与循环">逻辑判断与循环</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:04 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:02 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面向对象编程"><a class="header" href="#面向对象编程">面向对象编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型编程"><a class="header" href="#泛型编程">泛型编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:03 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:04 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="模块相关"><a class="header" href="#模块相关">模块相关</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo及类似包管理器介绍"><a class="header" href="#cargo及类似包管理器介绍">Cargo及类似包管理器介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:06 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:05 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="从io模型开始"><a class="header" href="#从io模型开始">从IO模型开始</a></h1>
<!--ts-->
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E4%BB%8Eio%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%A7%8B">从IO模型开始</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#1-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB">1. 同步/异步、阻塞/非阻塞概念区别</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%B0%83%E7%94%A8%E8%80%85%E8%A7%86%E8%A7%92">同步和异步，关注的是消息通信机制。（调用者视角）</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%E7%A8%8B%E5%BA%8F%E7%AD%89%E5%BE%85%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C%E7%9A%84%E7%8A%B6%E6%80%81%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E8%A7%86%E8%A7%92">阻塞和非阻塞，关注的是程序等待调用结果的状态。（被调用者视角）</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E9%98%BB%E5%A1%9E%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9C%89%E5%85%B3">阻塞，与系统调用有关。</a></li>
</ul>
</li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#2-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5io-%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB">2. 同步/异步IO 模型分类</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#3-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9Eio-blocking-io">3. 同步阻塞I/O (blocking I/O)</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#4-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io-multiplexing-">4. I/O 多路复用（I/O Multiplexing )</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#5-epoll-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B">5. epoll: 同步阻塞/非阻塞模型</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#epoll%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0">epoll三个函数</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#epoll-%E4%B8%A4%E7%A7%8D%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6">epoll 两种触发机制：</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E6%83%8A%E7%BE%A4%E9%97%AE%E9%A2%98">惊群问题：</a></li>
</ul>
</li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#6-%E5%BC%82%E6%AD%A5-io-%E6%A8%A1%E5%9E%8B-io_uring">6. 异步 I/O 模型: io_uring</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#1-reactor%E5%8F%8D%E5%BA%94%E5%99%A8-%E6%A8%A1%E5%BC%8F">1. Reactor（反应器） 模式</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#2-preactor%E4%B8%BB%E5%8A%A8%E5%99%A8-%E6%A8%A1%E5%BC%8F">2. Preactor（主动器） 模式</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#reactor-model">Reactor Model:</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">三种实现方式：</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B">读写操作流程：</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E5%8F%82%E4%B8%8E%E8%80%85">参与者：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:05 UTC 2022 -->
<!--te-->
<h2 id="1-同步异步阻塞非阻塞概念区别"><a class="header" href="#1-同步异步阻塞非阻塞概念区别">1. 同步/异步、阻塞/非阻塞概念区别</a></h2>
<h3 id="同步和异步关注的是消息通信机制调用者视角"><a class="header" href="#同步和异步关注的是消息通信机制调用者视角">同步和异步，关注的是消息通信机制。（调用者视角）</a></h3>
<ul>
<li>同步，发出一个调用，在没有得到结果之前不返回。</li>
<li>异步，发出一个调用，在没有得到结果之前返回。</li>
</ul>
<h3 id="阻塞和非阻塞关注的是程序等待调用结果的状态被调用者视角"><a class="header" href="#阻塞和非阻塞关注的是程序等待调用结果的状态被调用者视角">阻塞和非阻塞，关注的是程序等待调用结果的状态。（被调用者视角）</a></h3>
<ul>
<li>阻塞，在调用结果返回之前，线程被挂起。</li>
<li>非阻塞，在调用结果返回之前，线程不会被挂起。</li>
</ul>
<h3 id="阻塞与系统调用有关"><a class="header" href="#阻塞与系统调用有关">阻塞，与系统调用有关。</a></h3>
<h2 id="2-同步异步io-模型分类"><a class="header" href="#2-同步异步io-模型分类">2. 同步/异步IO 模型分类</a></h2>
<pre><code class="language-text">                                 +-+ 阻 塞 I/O (BIO)
                                 |
                                 +-+ 非 阻 塞 I/O (NIO)
                                 |
              +----+ 同 步 I/O +--+
              |                  |
              |                  +-+ I/O 多 路 复 用
              |                  |
              |                  +-+ 信 号 驱 动 I/O
I/O 模 型  +---+
              |
              |
              |                  +-+ Linux (AIO)
              |                  |         (io_uring)
              +----+ 异 步 I/O +--+
                                 |
                                 +-+ windows (IOCP)

</code></pre>
<h2 id="3-同步阻塞io-blocking-io"><a class="header" href="#3-同步阻塞io-blocking-io">3. 同步阻塞I/O (blocking I/O)</a></h2>
<pre><code class="language-text">Application               kernel
+---------+            +-----------+  +---+
|         |   syscall  | no        |      |
|   Read  | +--------&gt; | datagram  |      |
| recvfrom|            | ready     |      |
|         |            |    +      |      +-+ wait for
|         |            |    |      |      +-+ data
|         |            |    v      |      |
|         |            | datagram  |      |
|         |            | ready     |  +---+
|         |            |           |
|         |            | copy      |  +---+
|         |            | datagram  |      |
|process  |            |    +      |      +-+ copy data
|datagram |   return   |    |      |      +-+ from kernel to user
|         | &lt;--------+ |    v      |      |
|         |            |  copy     |  +---+
|         |            |  complete |
+---------+            +-----------+
</code></pre>
<blockquote>
<p>输入操作两个阶段：</p>
</blockquote>
<ol>
<li>进程等待内核把数据准备好；这个阶段可以阻塞也可非阻塞，设置socket属性。
<ul>
<li>阻塞： recvfrom 阻塞线程直到返回数据就绪的结果。</li>
<li>非阻塞：立即返回一个错误，轮询直到数据就绪。</li>
</ul>
</li>
<li>从内核缓冲区向进程缓冲区复制数据。（一直阻塞）</li>
</ol>
<p>异步I/O，recvfrom总是立即返回，两个阶段都由内核完成。</p>
<h2 id="4-io-多路复用io-multiplexing-"><a class="header" href="#4-io-多路复用io-multiplexing-">4. I/O 多路复用（I/O Multiplexing )</a></h2>
<p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄。</p>
<p>支持I/O多路复用的系统调用有 select/pselect/poll/epoll，本质都是同步I/O，因为数据拷贝都是阻塞的。
通过 select/epoll 来判断数据报是否准备好，即判断可读可写状态。</p>
<h2 id="5-epoll-同步阻塞非阻塞模型"><a class="header" href="#5-epoll-同步阻塞非阻塞模型">5. epoll: 同步阻塞/非阻塞模型</a></h2>
<pre><code class="language-text">                        +--------------------------------+     +-------------------------+
                        | epoll_ctl                      |     | epoll_wait              |
                        |                                |     |                         |
                        |                                |     |         +----+          |
                        |                 +---+          |     |         |    |          |
                        |                 |   |          |     |         |    |          |
                        |               +-+---+--+       |     |         +--+-+          |
                        |               |        |       |     |            |            |
                        |            +--++     +-++      |     |            |            |
epoll_create  +----&gt;    |            |   |     |  |      |     |         +--+-+          |
                        |            +-+-+     +--+      +----&gt;+         |    |          |
                        |              |                 |event|         |    |          |
                        |         +----+--+              |     |         +--+-+          |
                        |         |       |              |     |            |            |
                        |         ++      |              |     |            |            |
                        |        +--+   +-+-+            |     |         +--+-+          |
                        |        |  |   |   |            |     |         |    |          |
                        |        +--+   +---+            |     |         |    |          |
                        |                                |     |         +----+          |
                        |                    红 黑 树     |     |                 链 表    |
                        +--------------------------------+     +-------------------------+


</code></pre>
<h3 id="epoll三个函数"><a class="header" href="#epoll三个函数">epoll三个函数</a></h3>
<ul>
<li>epoll_create(int size) : 内核产生一个epoll实例数据结构，并返回一个epfd</li>
<li>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)：将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。</li>
<li>epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout): 阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入events数组中</li>
</ul>
<h3 id="epoll-两种触发机制"><a class="header" href="#epoll-两种触发机制">epoll 两种触发机制：</a></h3>
<ul>
<li>水平触发机制（LT)。缓冲区只要有数据就触发读写。epoll 默认工作方式。select/poll只支持该方式。</li>
<li>边缘触发机制（ET)。缓冲区空或满的状态才触发读写。nginx 使用该方式，避免频繁读写。</li>
</ul>
<h3 id="惊群问题"><a class="header" href="#惊群问题">惊群问题：</a></h3>
<p>当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。
Liux 4.5 通过引入 EPOLLEXCLUSIVE 标识来保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的惊群问题。</p>
<h2 id="6-异步-io-模型-io_uring"><a class="header" href="#6-异步-io-模型-io_uring">6. 异步 I/O 模型: io_uring</a></h2>
<p>Linux AIO 实现的并不理想，所以引入了新的异步I/O接口 io_uring。</p>
<pre><code class="language-text">+----+ Head  +---------+               +----------+ Head
|            |         |               |          |
|            |         |               |          |
|            +---------+               +----------+
|            |         |               |          |
|            |         |               |          |
|            +---------+               +----------+
|            |         |               |          |
|            |         |               |          |
|            +---------+               +----------+
|            |         |               |          |
|      Tail  +---------+               +----------+ Tail &lt;--+
|        +--------------------------------------------+     |
|        | Kernel                                     |     |
|        |                                            |     |
|        |        +-------+              +-------+    |     |
|        |        |       |              |       |    |     |
+---------------&gt; | SQ    |              |  CQ   | +--------+
         |        |       |              |       |    |
         |        +-------+              +-------+    |
         |                                            |
         +--------------------------------------------+

</code></pre>
<p>io_uring接口通过两个主要数据结构工作：</p>
<ul>
<li>提交队列条目（sqe）</li>
<li>完成队列条目（cqe）</li>
</ul>
<p>这些结构的实例位于内核和应用程序之间的<strong>共享内存</strong>单生产者单消费者环形缓冲区中。</p>
<p>参考：</p>
<p><a href="https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/">https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/</a></p>
<p><a href="https://cor3ntin.github.io/posts/iouring/#io_uring">https://cor3ntin.github.io/posts/iouring/#io_uring</a></p>
<blockquote>
<p>因为处理 I/O 复用的编程模型相当复杂，为了简化编程，引入了下面两种模型:</p>
</blockquote>
<h3 id="1-reactor反应器-模式"><a class="header" href="#1-reactor反应器-模式">1. Reactor（反应器） 模式</a></h3>
<p>对应同步I/O，被动的事件分离和分发模型。服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。</p>
<h3 id="2-preactor主动器-模式"><a class="header" href="#2-preactor主动器-模式">2. Preactor（主动器） 模式</a></h3>
<p>对应异步I/O，主动的事件分离和分发模型。这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）。</p>
<h3 id="reactor-model"><a class="header" href="#reactor-model">Reactor Model:</a></h3>
<pre><code class="language-text">                                                     +----------------+
req                                        Dispatch  |                |
+------+                                  +--------&gt; | req handler    |
|      |                                  |          +----------------+
|      | +----+                           |
+------+      | event    +------------+   |
              |          |            |   |
              +--------&gt; |  Service   |   |Dispatch  +----------------+
                         |  Handler   +------------&gt; |                |
req          +---------&gt; |            |   |          | req handler    |
+------+     |           +------------+   |          +----------------+
|      |     | event                      |
|      +----+                             |
+------+                                  | Dispatch +----------------+
                                          +---------&gt;+                |
                                                     | req handler    |
                                                     +----------------+

</code></pre>
<h4 id="三种实现方式"><a class="header" href="#三种实现方式">三种实现方式：</a></h4>
<ul>
<li>单线程模式。 accept()、read()、write()以及connect()操作 都在同一线程。</li>
<li>工作者线程池模式。非 I/O 操作交给线程池处理</li>
<li>多线程模式。主Reactor (master) ，负责网络监听 ， 子Reactor(worker) 读写网络数据。</li>
</ul>
<h4 id="读写操作流程"><a class="header" href="#读写操作流程">读写操作流程：</a></h4>
<ol>
<li>应用注册读写就绪事件和相关联的事件处理器</li>
<li>事件分离器等待事件发生</li>
<li>当发生读写就绪事件，事件分离器调用已注册的事件处理器</li>
<li>事件处理器执行读写操作</li>
</ol>
<h4 id="参与者"><a class="header" href="#参与者">参与者：</a></h4>
<ol>
<li>描述符（handle）：操作系统提供的资源，识别 socket等。</li>
<li>同步事件多路分离器。开启事件循环，等待事件的发生。封装了 多路复用函数 select/poll/epoll等。</li>
<li>事件处理器。提供回调函数，用于描述与应用程序相关的某个事件的操作。</li>
<li>具体的事件处理器。事件处理器接口的具体实现。使用描述符来识别事件和程序提供的服务。</li>
<li>Reactor 管理器。事件处理器的调度核心。分离每个事件，调度事件管理器，调用具体的函数处理某个事件。</li>
</ol>
<h2 id="参考资源-1"><a class="header" href="#参考资源-1">参考资源</a></h2>
<ul>
<li><a href="https://time.geekbang.org/course/detail/100060601-365835">88. IO模型</a></li>
<li><a href="https://time.geekbang.org/course/detail/100060601-365838">89. epoll和io_uring</a></li>
<li><a href="https://time.geekbang.org/course/detail/100060601-367808">90. 事件驱动编程模型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:06 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:07 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:06 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:06 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Added by: kuanhsiaokuo, at: Thu Jun  2 23:19:28 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="学习资源"><a class="header" href="#学习资源">学习资源</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/1_learning_resource/learning_resource.html#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">学习资源</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Mon Jun 13 06:52:08 UTC 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="官方动态"><a class="header" href="#官方动态">官方动态</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="社区特点"><a class="header" href="#社区特点">社区特点</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="学术动态"><a class="header" href="#学术动态">学术动态</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开源观察"><a class="header" href="#开源观察">开源观察</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据处理"><a class="header" href="#数据处理">数据处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入式"><a class="header" href="#嵌入式">嵌入式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能工具"><a class="header" href="#性能工具">性能工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="云原生"><a class="header" href="#云原生">云原生</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前端开发"><a class="header" href="#前端开发">前端开发</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络基建"><a class="header" href="#网络基建">网络基建</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络开发"><a class="header" href="#网络开发">网络开发</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="音视频处理"><a class="header" href="#音视频处理">音视频处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="游戏与图像处理"><a class="header" href="#游戏与图像处理">游戏与图像处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rust与其他编程语言"><a class="header" href="#rust与其他编程语言">Rust与其他编程语言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="科学艺术研究"><a class="header" href="#科学艺术研究">科学艺术研究</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他工具"><a class="header" href="#其他工具">其他工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全参考"><a class="header" href="#安全参考">安全参考</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="商业观察"><a class="header" href="#商业观察">商业观察</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链"><a class="header" href="#区块链">区块链</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生产实践"><a class="header" href="#生产实践">生产实践</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优秀产品"><a class="header" href="#优秀产品">优秀产品</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础库"><a class="header" href="#基础库">基础库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="框架引擎"><a class="header" href="#框架引擎">框架引擎</a></h1>

            </main>

            <script src="https://utteranc.es/client.js"
                    repo="RustMagazine/rust_magazine_2022"
                    issue-term="title"
                    theme="github-light"
                    crossorigin="anonymous"
                    async></script>

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
    </nav>

</div>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="mermaid.min.js"></script>
    <script type="text/javascript" src="mermaid-init.js"></script>
    <script type="text/javascript" src="smart-anchor.js"></script>
    <script type="text/javascript" src="sidebar.js"></script>
        <script type="text/javascript">
            window.addEventListener('load', function () {
                MathJax.Hub.Register.StartupHook('End', function () {
                    window.setTimeout(window.print, 100);
                });
            });
        </script>
</body>
</html>
