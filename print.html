<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Programming Anatomy In Rust</title>
        <meta name="robots" content="noindex"/>
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust为例分享学习编程常考虑的方方面面">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="style.css">
        <link rel="stylesheet" href="././assets/css/mdbook-admonish.css">
        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> 总览</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/layer1_underlying_abstract.html"><strong aria-hidden="true">2.</strong> Layer1: 底层抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/1_virtual_memory/virtual_memory.html"><strong aria-hidden="true">2.1.</strong> 虚拟内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/1_virtual_memory/memory_manage_safety.html"><strong aria-hidden="true">2.1.1.</strong> 内存管理与内存安全</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html"><strong aria-hidden="true">2.1.2.</strong> 所有权三件套</a></li></ol></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/type_system.html"><strong aria-hidden="true">2.2.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/built_in_types.html"><strong aria-hidden="true">2.2.1.</strong> 基础内置类型</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/collections.html"><strong aria-hidden="true">2.2.2.</strong> 集合类型</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/user_defined_types.html"><strong aria-hidden="true">2.2.3.</strong> 自定义类型</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html"><strong aria-hidden="true">2.2.4.</strong> 泛型、特征及特征对象</a></li></ol></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/language_grammar.html"><strong aria-hidden="true">2.3.</strong> 语言语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/keywords_glossary.html"><strong aria-hidden="true">2.3.1.</strong> 词法结构扫盲</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/binding_match.html"><strong aria-hidden="true">2.3.2.</strong> 绑定、赋值与匹配</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/logical_decision_loops.html"><strong aria-hidden="true">2.3.3.</strong> 逻辑判断与循环♻️</a></li><li class="chapter-item expanded "><a href="layer1_underlying_abstract/3_language_grammar/statements_expressions.html"><strong aria-hidden="true">2.3.4.</strong> 语句与表达式</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer2_design_abstract/layer2_design_abstract.html"><strong aria-hidden="true">3.</strong> Layer2: 设计抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/4_programming_paradigm.html"><strong aria-hidden="true">3.1.</strong> 编程范式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/fp.html"><strong aria-hidden="true">3.1.1.</strong> 函数式编程</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/oop.html"><strong aria-hidden="true">3.1.2.</strong> 面向对象编程</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/4_programming_paradigm/gp.html"><strong aria-hidden="true">3.1.3.</strong> 泛型编程</a></li></ol></li><li class="chapter-item expanded "><a href="layer2_design_abstract/5_design_pattern/5_design_pattern.html"><strong aria-hidden="true">3.2.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/6_module_manage.html"><strong aria-hidden="true">3.3.</strong> 模块管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/module_relate.html"><strong aria-hidden="true">3.3.1.</strong> 模块使用</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html"><strong aria-hidden="true">3.3.2.</strong> Cargo与项目生命周期</a></li><li class="chapter-item expanded "><a href="layer2_design_abstract/6_module_manage/rust_plugins.html"><strong aria-hidden="true">3.3.3.</strong> Rust扩展工具</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer3_task_abstract/layer3_task_abstract.html"><strong aria-hidden="true">4.</strong> Layer3: 任务抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/7_concurrency.html"><strong aria-hidden="true">4.1.</strong> 并发编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/io_models.html"><strong aria-hidden="true">4.1.1.</strong> 系统IO模型</a></li><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/1_multi_models/multi_models.html"><strong aria-hidden="true">4.1.2.</strong> 多线程模型</a></li><li class="chapter-item expanded "><a href="layer3_task_abstract/7_concurrency/2_async_models/async_models.html"><strong aria-hidden="true">4.1.3.</strong> 异步模型</a></li></ol></li><li class="chapter-item expanded "><a href="layer3_task_abstract/8_meta_programming/8_meta_programming.html"><strong aria-hidden="true">4.2.</strong> 元编程</a></li></ol></li><li class="chapter-item expanded "><a href="layer4_protocol_abstract/layer4_protocol_abstract.html"><strong aria-hidden="true">5.</strong> Layer4: 协议抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer4_protocol_abstract/9_multilingual_programming/9_multilingual_programming.html"><strong aria-hidden="true">5.1.</strong> 跨语言编程</a></li><li class="chapter-item expanded "><a href="layer4_protocol_abstract/10_computer_network/10_computer_network.html"><strong aria-hidden="true">5.2.</strong> 计算机网络</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/layer5_ecosystem.html"><strong aria-hidden="true">6.</strong> Layer5: 生态环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/learning_resource.html"><strong aria-hidden="true">6.1.</strong> 学习资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/1_books/books.html"><strong aria-hidden="true">6.1.1.</strong> 书籍整理</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/2_courses/courses.html"><strong aria-hidden="true">6.1.2.</strong> 线上课程</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/3_blogs/blogs.html"><strong aria-hidden="true">6.1.3.</strong> 博客文章</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/4_videos/videos.html"><strong aria-hidden="true">6.1.4.</strong> 在线视频</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/1_learning_resource/5_projects/projects.html"><strong aria-hidden="true">6.1.5.</strong> 开源项目</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/2_lang_update/lang_update.html"><strong aria-hidden="true">6.2.</strong> 官方动态</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/3_community/community.html"><strong aria-hidden="true">6.3.</strong> 社区热点</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/4_academic/academic.html"><strong aria-hidden="true">6.4.</strong> 学术讨论</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/open_source.html"><strong aria-hidden="true">6.5.</strong> 开源观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/underlying.html"><strong aria-hidden="true">6.5.1.</strong> 底层开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/command/command.html"><strong aria-hidden="true">6.5.1.1.</strong> 命令行工具</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/data/data.html"><strong aria-hidden="true">6.5.1.2.</strong> 数据处理</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/embedded/embedded.html"><strong aria-hidden="true">6.5.1.3.</strong> 嵌入式</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/os/os.html"><strong aria-hidden="true">6.5.1.4.</strong> 系统开发</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/1_underlying/performance/performance.html"><strong aria-hidden="true">6.5.1.5.</strong> 性能工具</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network.html"><strong aria-hidden="true">6.5.2.</strong> 网络相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/cloud/cloud.html"><strong aria-hidden="true">6.5.2.1.</strong> 云原生</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/frontend/frontend.html"><strong aria-hidden="true">6.5.2.2.</strong> 前端基建</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network/network.html"><strong aria-hidden="true">6.5.2.3.</strong> 网络基建</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html"><strong aria-hidden="true">6.5.2.3.1.</strong> IPFS: 星际文件系统(InterPlanetary File System)</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_website.html"><strong aria-hidden="true">6.5.2.3.2.</strong> 利用IPFS构建自己的去中心化分布式网站</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_pubsub.html"><strong aria-hidden="true">6.5.2.3.3.</strong> IPFS pubsub功能</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_companion.html"><strong aria-hidden="true">6.5.2.3.4.</strong> IPFS伴侣插件</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_ngrok.html"><strong aria-hidden="true">6.5.2.3.5.</strong> IPFS+ngrok</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/2_network/web/web.html"><strong aria-hidden="true">6.5.2.4.</strong> web开发</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/3_media/media.html"><strong aria-hidden="true">6.5.3.</strong> 多媒体</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/3_media/av/av.html"><strong aria-hidden="true">6.5.3.1.</strong> 音视频处理</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/3_media/game/game.html"><strong aria-hidden="true">6.5.3.2.</strong> 游戏开发</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/other.html"><strong aria-hidden="true">6.5.4.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/lang-with-rust/lang_with_rust.html"><strong aria-hidden="true">6.5.4.1.</strong> Rust与其他语言</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/scientific-research/scientific_research.html"><strong aria-hidden="true">6.5.4.2.</strong> 科学艺术研究</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/5_open_source/4_other/tools/tools.html"><strong aria-hidden="true">6.5.4.3.</strong> 其他工具</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/6_security/security.html"><strong aria-hidden="true">6.6.</strong> 安全参考</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/business.html"><strong aria-hidden="true">6.7.</strong> 商业观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/blockchain/blockchain.html"><strong aria-hidden="true">6.7.1.</strong> 区块链</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/blockchain/substrate_intro.html"><strong aria-hidden="true">6.7.1.1.</strong> Substrate介绍与解析</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/blockchain/nervos_ckb_anatomy.html"><strong aria-hidden="true">6.7.1.2.</strong> Nervos CKB介绍与解析</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/blockchain/solana.html"><strong aria-hidden="true">6.7.1.3.</strong> Solana</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/practices/practices.html"><strong aria-hidden="true">6.7.2.</strong> 生产实践</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/7_business/products/products.html"><strong aria-hidden="true">6.7.3.</strong> 优秀产品</a></li></ol></li><li class="chapter-item expanded "><a href="layer5_ecosystem/8_libs/libs.html"><strong aria-hidden="true">6.8.</strong> 基础库</a></li><li class="chapter-item expanded "><a href="layer5_ecosystem/9_frameworks/frameworks.html"><strong aria-hidden="true">6.9.</strong> 框架引擎</a></li></ol></li><li class="chapter-item expanded "><a href="checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
        <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Programming Anatomy In Rust</h1>
            <h4 class="menu-bar"> -- 练武不练功 到头一场空 -- 《赛博英雄传》 </h4>
            <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/programming_anatomy_in_rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="编程解剖-in-rust"><a class="header" href="#编程解剖-in-rust">编程解剖 in rust</a></h1>
<blockquote>
<p>以rust为例分享学习编程常考虑的方方面面</p>
</blockquote>
<!--ts-->
<ul>
<li><a href="overview.html#%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%89%96-in-rust">编程解剖 in rust</a>
<ul>
<li><a href="overview.html#%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C">本地运行</a></li>
<li><a href="overview.html#git-lfs%E9%85%8D%E7%BD%AE">git lfs配置</a></li>
<li><a href="overview.html#%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84">项目基础结构</a></li>
<li><a href="overview.html#%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7">用到的工具</a>
<ul>
<li><a href="overview.html#mdbook-checklist-%E6%95%B4%E7%90%86%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9">mdbook-checklist: 整理待办事项</a></li>
<li><a href="overview.html#mdbook-pagetoc-%E6%B7%BB%E5%8A%A0%E4%B8%9A%E5%86%85%E7%9B%AE%E5%BD%95">mdbook-pagetoc: 添加业内目录</a></li>
<li><a href="overview.html#mdbook-admonish-%E4%BD%BF%E7%94%A8%E6%96%B0%E7%9A%84css%E6%96%87%E4%BB%B6">mdbook-admonish: 使用新的css文件</a>
<ul>
<li><a href="overview.html#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90">相关资源</a></li>
<li><a href="overview.html#%E7%89%B9%E5%88%AB%E8%AF%AD%E6%B3%95">特别语法</a>
<ul>
<li><a href="overview.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%A2%98">自定义标题</a></li>
<li><a href="overview.html#%E5%86%85%E5%B5%8C%E4%BB%A3%E7%A0%81">内嵌代码</a></li>
<li><a href="overview.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F">自定义样式</a></li>
<li><a href="overview.html#%E5%8F%AF%E6%8A%98%E5%8F%A0">可折叠</a></li>
</ul>
</li>
<li><a href="overview.html#%E5%B8%B8%E7%94%A8%E6%A0%BC%E5%BC%8F">常用格式</a>
<ul>
<li><a href="overview.html#note">note</a></li>
<li><a href="overview.html#abstract-summary-tldr">abstract, summary, tldr</a></li>
<li><a href="overview.html#info-todo">info, todo</a></li>
<li><a href="overview.html#tip-hint-important">tip, hint, important</a></li>
<li><a href="overview.html#success-check-done">success, check, done</a></li>
<li><a href="overview.html#question-help-faq">question, help, faq</a></li>
<li><a href="overview.html#warning-caution-attention">warning, caution, attention</a></li>
<li><a href="overview.html#failure-fail-missing">failure, fail, missing</a></li>
<li><a href="overview.html#danger-error">danger, error</a></li>
<li><a href="overview.html#bug">bug</a></li>
<li><a href="overview.html#example">example</a></li>
<li><a href="overview.html#quote-cite">quote, cite</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="overview.html#github-action">github action</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Jun 15 09:14:14 UTC 2022 -->
<!--te-->
<h2 id="本地运行"><a class="header" href="#本地运行">本地运行</a></h2>
<pre><code class="language-shell">cargo install mdbook
mdbook serve
</code></pre>
<h2 id="git-lfs配置"><a class="header" href="#git-lfs配置">git lfs配置</a></h2>
<ul>
<li><a href="https://git-lfs.github.com/">Git Large File Storage | Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.</a></li>
</ul>
<pre><code>git lfs install 
git lfs track '*.img'
</code></pre>
<h2 id="项目基础结构"><a class="header" href="#项目基础结构">项目基础结构</a></h2>
<ol>
<li>每个文件夹下的同名md文件介绍当前文件夹的内容</li>
</ol>
<h2 id="用到的工具"><a class="header" href="#用到的工具">用到的工具</a></h2>
<blockquote>
<p>来自：<a href="https://kuanhsiaokuo.github.io/apple_power_user/app_deepin/mdbook_deepin.html">Mdbook - Apple Power User</a></p>
</blockquote>
<h3 id="mdbook-checklist-整理待办事项"><a class="header" href="#mdbook-checklist-整理待办事项">mdbook-checklist: 整理待办事项</a></h3>
<p><a href="https://github.com/ANSSI-FR/mdbook-checklist">ANSSI-FR/mdbook-checklist: mdbook preprocessor for generating checklists and indexes</a></p>
<pre><code class="language-shell">cargo install mdbook-checklist
</code></pre>
<p><a href="https://crates.io/crates/mdbook-checklist">mdbook-checklist - crates.io: Rust Package Registry</a></p>
<h3 id="mdbook-pagetoc-添加页旁目录"><a class="header" href="#mdbook-pagetoc-添加页旁目录">mdbook-pagetoc: 添加页旁目录</a></h3>
<p><a href="https://github.com/JorelAli/mdBook-pagetoc">JorelAli/mdBook-pagetoc: A page table of contents for mdBook</a></p>
<h3 id="mdbook-admonish-使用新的css文件"><a class="header" href="#mdbook-admonish-使用新的css文件">mdbook-admonish: 使用新的css文件</a></h3>
<h4 id="相关资源"><a class="header" href="#相关资源">相关资源</a></h4>
<ul>
<li><a href="https://github.com/tommilligan/mdbook-admonish">tommilligan/mdbook-admonish: A preprocessor for mdbook to add Material Design admonishments.</a></li>
<li><a href="https://crates.io/crates/mdbook-admonish">mdbook-admonish - crates.io: Rust Package Registry</a></li>
<li><a href="https://tommilligan.github.io/mdbook-admonish/">Overview - The mdbook-admonish book</a></li>
<li><a href="https://squidfunk.github.io/mkdocs-material/reference/admonitions/#usage">Admonitions - Material for MkDocs</a></li>
</ul>
<blockquote>
<p>All supported directives are listed below.</p>
</blockquote>
<h4 id="特别语法"><a class="header" href="#特别语法">特别语法</a></h4>
<h5 id="自定义标题"><a class="header" href="#自定义标题">自定义标题</a></h5>
<div id="admonition-数据损失" class="admonition warning">
<div class="admonition-title">
<p>数据损失</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-数据损失"></a></p>
</div>
<div>
<p>The following steps can lead to irrecoverable data corruption.</p>
</div>
</div>
<h5 id="内嵌代码"><a class="header" href="#内嵌代码">内嵌代码</a></h5>
<div id="admonition-内嵌代码" class="admonition bug">
<div class="admonition-title">
<p>内嵌代码</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-内嵌代码"></a></p>
</div>
<div>
<p>This syntax won't work in Python 3:</p>
<pre><code class="language-python">print &quot;Hello, world!&quot;
</code></pre>
</div>
</div>
<h5 id="自定义样式"><a class="header" href="#自定义样式">自定义样式</a></h5>
<div id="admonition-note" class="admonition note custom-0 custom-1">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-note"></a></p>
</div>
<div>
<p>Styled with my custom CSS class.</p>
</div>
</div>
<h5 id="可折叠"><a class="header" href="#可折叠">可折叠</a></h5>
<details id="admonition-note-1" class="admonition note">
<summary class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-note-1"></a></p>
</summary>
<div>
<p>Content will be hidden initially.</p>
</div>
</details>
<h4 id="常用格式"><a class="header" href="#常用格式">常用格式</a></h4>
<h5 id="note"><a class="header" href="#note">note</a></h5>
<div id="admonition-note-2" class="admonition note">
<div class="admonition-title">
<p>Note</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-note-2"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="abstract-summary-tldr"><a class="header" href="#abstract-summary-tldr"><code>abstract</code>, <code>summary</code>, <code>tldr</code></a></h5>
<div id="admonition-abstract" class="admonition abstract">
<div class="admonition-title">
<p>Abstract</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-abstract"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="info-todo"><a class="header" href="#info-todo"><code>info</code>, <code>todo</code></a></h5>
<div id="admonition-info" class="admonition info">
<div class="admonition-title">
<p>Info</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-info"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="tip-hint-important"><a class="header" href="#tip-hint-important"><code>tip</code>, <code>hint</code>, <code>important</code></a></h5>
<div id="admonition-tip" class="admonition tip">
<div class="admonition-title">
<p>Tip</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-tip"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="success-check-done"><a class="header" href="#success-check-done"><code>success</code>, <code>check</code>, <code>done</code></a></h5>
<div id="admonition-success" class="admonition success">
<div class="admonition-title">
<p>Success</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-success"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="question-help-faq"><a class="header" href="#question-help-faq"><code>question</code>, <code>help</code>, <code>faq</code></a></h5>
<div id="admonition-question" class="admonition question">
<div class="admonition-title">
<p>Question</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-question"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="warning-caution-attention"><a class="header" href="#warning-caution-attention"><code>warning</code>, <code>caution</code>, <code>attention</code></a></h5>
<div id="admonition-warning" class="admonition warning">
<div class="admonition-title">
<p>Warning</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-warning"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="failure-fail-missing"><a class="header" href="#failure-fail-missing"><code>failure</code>, <code>fail</code>, <code>missing</code></a></h5>
<div id="admonition-failure" class="admonition failure">
<div class="admonition-title">
<p>Failure</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-failure"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="danger-error"><a class="header" href="#danger-error"><code>danger</code>, <code>error</code></a></h5>
<div id="admonition-danger" class="admonition danger">
<div class="admonition-title">
<p>Danger</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-danger"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="bug"><a class="header" href="#bug"><code>bug</code></a></h5>
<div id="admonition-bug" class="admonition bug">
<div class="admonition-title">
<p>Bug</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-bug"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="example"><a class="header" href="#example"><code>example</code></a></h5>
<div id="admonition-example" class="admonition example">
<div class="admonition-title">
<p>Example</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-example"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h5 id="quote-cite"><a class="header" href="#quote-cite"><code>quote</code>, <code>cite</code></a></h5>
<div id="admonition-quote" class="admonition quote">
<div class="admonition-title">
<p>Quote</p>
<p><a class="admonition-anchor-link" href="overview.html#admonition-quote"></a></p>
</div>
<div>
<p>Rust is a multi-paradigm, general-purpose programming language designed for performance and safety, especially safe concurrency.</p>
</div>
</div>
<h2 id="github-action"><a class="header" href="#github-action">github action</a></h2>
<ul>
<li><a href="https://github.com/marketplace/actions/rust-cargo-install">rust-cargo-install · Actions · GitHub Marketplace</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:42 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/virtual_memory.html#%E4%BB%8B%E7%BB%8D">介绍</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:32 CST 2022 -->
<!--te-->
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>从计算机组成原理了解到操作系统，当一个程序开始运行的时候，不论是可执行程序还是命令行，都会从创建进程，申请进程资源开始，再到堆栈(stack/heap)
的使用，申请与释放资源。这一系列操作对于编程来说重要性不言而喻，只不过根据编程语言的高级程度不同，开发者需要掌握的知识也有不同。</p>
<p>而在rust语言编程中，内存的管理方式及其重要。所以这一层主要先介绍虚拟内存管理以及相关出现的内容安全问题，接着介绍rust是如何通过所有权、作用域和生命周期，引申出借用、移动语义、复制语义等一系列内容来解决内存安全问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存管理与内存安全"><a class="header" href="#内存管理与内存安全">内存管理与内存安全</a></h1>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000020338427">Go内存分配那些事，就这么简单！ - SegmentFault 思否</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/memory-model.html">Memory model - The Rust Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权三件套所有权借用与生命周期"><a class="header" href="#所有权三件套所有权借用与生命周期">所有权三件套：所有权、借用与生命周期</a></h1>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/Ownership.jpeg" alt="Ownership" /></p>
<!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%89%E4%BB%B6%E5%A5%97%E6%89%80%E6%9C%89%E6%9D%83%E5%80%9F%E7%94%A8%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">所有权三件套：所有权、借用与生命周期</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E7%BB%BC%E8%BF%B0">综述</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E6%89%80%E6%9C%89%E6%9D%83">所有权</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E8%B5%84%E6%BA%90%E6%89%80%E6%9C%89%E8%80%85">资源所有者</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E8%B5%84%E6%BA%90%E6%89%80%E6%9C%89%E8%80%85%E8%B4%9F%E8%B4%A3%E9%87%8A%E6%94%BE">资源所有者负责释放</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E9%9D%A0gc%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%84%E7%90%86">动态语言靠GC在运行期处理</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E8%A7%84%E5%AE%9A">静态语言在编译期规定</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99">Rust的所有权规则</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E6%8F%A3%E6%91%A9%E6%89%80%E6%9C%89%E6%9D%83%E5%90%AB%E4%B9%89">揣摩所有权含义</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%89%80%E6%9C%89%E6%9D%83%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0">作用域：所有权考虑因素</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%A4%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90">多作用域的情况分析</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E6%8E%A8%E6%96%AD%E6%89%80%E6%9C%89%E6%9D%83%E6%97%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7">作用域是推断所有权时的一个重要属性</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%BC%95%E5%85%A5%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89">引入移动和复制语义</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E8%AF%AD%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D">语义是什么意思</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%88%96%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E6%97%B6%E9%BB%98%E8%AE%A4">移动语义：变量访问或重新分配时默认</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89">复制语义</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%BD%BF%E7%94%A8copy%E7%89%B9%E5%BE%81%E6%9B%B4%E6%94%B9%E8%AF%AD%E4%B9%89">使用Copy特征更改语义</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#copy-%E7%89%B9%E5%BE%81%E4%BE%9D%E8%B5%96%E4%BA%8Eclone-%E7%89%B9%E5%BE%81">Copy 特征依赖于Clone 特征</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%8C%BA%E5%88%AB%E4%B8%80%E4%B8%8Bcopy%E4%B8%8Eclone-trait">区别一下Copy与Clone trait</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#copy">Copy</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#clone">Clone</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#copy%E4%B8%8Eclone%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">Copy与Clone的使用原则</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%BD%95%E6%97%B6%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0-copy">何时在类型上实现 Copy</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%BD%95%E6%97%B6%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0-clone">何时在类型上实现 Clone。</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E6%89%80%E6%9C%89%E6%9D%83%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">所有权使用场景</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#let%E7%BB%91%E5%AE%9A%E7%A4%BA%E4%BE%8B">let绑定示例</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E5%87%BD%E6%95%B0">将参数传递给函数</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#match%E8%A1%A8%E8%BE%BE%E5%BC%8F">match表达式</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#impl%E4%BB%A3%E7%A0%81%E5%9D%97">impl代码块</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E9%97%AD%E5%8C%85">闭包</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%80%9F%E7%94%A8-%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%A7%84%E9%81%BF%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99%E9%99%90%E5%88%B6">借用: 通过引用规避所有权规则限制</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%80%9F%E7%94%A8%E5%BC%95%E7%94%A8">为何需要借用/引用</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%80%9F%E7%94%A8-or-%E5%BC%95%E7%94%A8">借用 or 引用？</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%B8%A4%E7%A7%8D%E5%80%9F%E7%94%A8%E6%96%B9%E5%BC%8F">两种借用方式</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8">不可变借用：&amp;</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8mut">可变借用：&amp;mut</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99">借用规则</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%A6%82%E6%9E%9C%E8%BF%9D%E5%8F%8D%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99">如果违反借用规则</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%80%9F%E7%94%A8">函数中的借用</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%80%9F%E7%94%A8">匹配中的借用</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%BB%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8">从函数返回引用：</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%9F%BA%E4%BA%8E%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99%E7%9A%84%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B">基于借用规则的方法类型</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%88%E5%AF%B9%E5%BC%95%E7%94%A8%E9%99%84%E5%8A%A0%E7%9A%84%E4%BF%A1%E6%81%AF">生命周期：针对引用附加的信息</a>
<ul>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E4%BB%8E%E5%8F%98%E9%87%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BC%80%E5%A7%8B">从变量生命周期开始</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%99%90%E5%AE%9A">生命周期限定</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B3%A8%E8%A7%A3">生命周期注解</a></li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5">生命周期省略</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:30 CST 2022 -->
<!--te-->
<h2 id="综述"><a class="header" href="#综述">综述</a></h2>
<pre><code class="language-text">┌───────────────────────────────────┐
│                                   │
│                                   │
│         .───────.       ┌──────┐  │
│       ,'         `.     │Borrow│  │
│     ,'             `.   └──────┘  │
│    ;   ┌─────────┐   :            │
│    │   │OwnerShip│   │            │
│    │   └─────────┘   │            │
│    :     ┌─────┐     ; ┌────────┐ │
│     ╲    │Scope│    ╱  │Lifetime│ │
│      `.  └─────┘  ,'   └────────┘ │
│        `.       ,'                │
│          `─────'                  │
│                                   │
│                                   │
└───────────────────────────────────┘
</code></pre>
<p>所有权、作用域、借用与生命周期是 Rust 的内存安全及其零成本抽象原则的核心。 它们让 Rust 能够在编译期检测程序中内存安全违规,在离开作用域时自动释放相关资源等情况。
所有权有点类似核心原则,而借用和生命周期是对语言类型系统的扩展。在代码的不同上下文中加强或有时放松所有权原则,可确保编译期内存管理正常运作。</p>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<h3 id="资源所有者"><a class="header" href="#资源所有者">资源所有者</a></h3>
<p>程序中资源的真正所有者的概念因语言而异。这里的含义是通过资源, 主要包含下列内容：</p>
<ol>
<li>共同引用在堆或堆栈上保存值的任何变量</li>
<li>或者是包含打开文件描述符、数据库连接套接字、网络套接字及类似内容的变量。</li>
</ol>
<p>从它们存在到完成程序调用及其之后的时间,都会占用一些内存。</p>
<h3 id="资源所有者负责释放"><a class="header" href="#资源所有者负责释放">资源所有者负责释放</a></h3>
<blockquote>
<p>资源所有者的一个重要职责就是明智地释放它们使用的内存,因为如果无法在适当的位置和时间执行取消内存分配,就可能导致内存泄漏。</p>
</blockquote>
<h4 id="动态语言靠gc在运行期处理"><a class="header" href="#动态语言靠gc在运行期处理">动态语言靠GC在运行期处理</a></h4>
<p>在使用 Python 等动态语言编程时,可以将多个所有者或别名添加到 list 对象中,从而使用执行该对象的众多变量之一添加或删除 list 中的项目。变量不需要关心如何释放对象使用过的内存,因为 GC
会处理这些事情,并且一旦指向对象的所有引用都消失,GC 就会释放相关的内存。</p>
<h4 id="静态语言在编译期规定"><a class="header" href="#静态语言在编译期规定">静态语言在编译期规定</a></h4>
<p>对于 C/C++/Golang之类的编译语言,在智能指针出现之前,程序库对代码使用完毕的相关资源 API 的调用方或者被调用方是否负责释放内存有明确的规定。存在这些规则是因为编译器不会在这些语言中强制限定所有权。在
C++中不使用智能指针仍然有可能出现问题。在C++中,存在多个变量指向堆上的某个值是完全没问题的(尽管我们不建议这么做) ,这就是所谓的别名。由于具有指向资源的多个指针或别名的灵活性,程序员会遇到各种各样的问题,其中之一就是
C++中的迭代器失效问题。</p>
<blockquote>
<p>具体而言,当给定作用域中资源的其他不可变别名相对存在至少一个可变别名时,就会出现问题</p>
</blockquote>
<h3 id="rust的所有权规则"><a class="header" href="#rust的所有权规则">Rust的所有权规则</a></h3>
<p>Rust 试图为程序中值的所有权设定适当的语义。Rust 的所有权规则遵循以下原则。</p>
<ul>
<li>使用 let 语句创建值或资源,并将其分配给变量时,该变量将成为资源的所有者。</li>
<li>当值从一个变量重新分配给另一个变量时, 值的所有权将转移至另一个变量, 原来的变量将失效以便另作他用。</li>
<li>值和变量在其作用域的末尾会被清理、释放。</li>
</ul>
<h3 id="揣摩所有权含义"><a class="header" href="#揣摩所有权含义">揣摩所有权含义</a></h3>
<p>需要注意的是,Rust 中的值只有一个所有者,即创建它们的变量。其理念很简单,但是它的含义值得揣摩：</p>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_basics.rs

#[derive(Debug)]
struct Foo(u32);

fn main() {
    // 根据所有权规则, foo 是 Foo 实例的所有者
    let foo = Foo(2048);
    /*
        bar 成为Foo 实例的新所有者, 而旧的 foo 是一个废弃变量.
        经过此变动之后不能在其他任何地方使用
    */
    let bar = foo; // value moved here
    /*
        每当我们将变量分配给某个其他变量或从变量读取数据时,Rust 会默认移动变量指向的值。
        所有权规则可以防止你通过多个访问点来修改值,这可能导致访问已被释放的变量.
        即使在单线程上下文中,使用允许多个值的可变别名的语言也是如此
    */
    println!(&quot;Foo is {:?}&quot;, foo);  // value borrowed here after move
    println!(&quot;Bar is {:?}&quot;, bar);
}
</code></pre></pre>
<p>每当我们将变量分配给某个其他变量或从变量读取数据时,Rust 会默认移动变量指向的值。所有权规则可以防止你通过多个访问点来修改值,这可能导致访问已被释放的变量,即使在单线程上下文中,使用允许多个值的可变别名的语言也是如此</p>
<h3 id="作用域所有权考虑因素"><a class="header" href="#作用域所有权考虑因素">作用域：所有权考虑因素</a></h3>
<blockquote>
<p>为了分析某个值何时超出作用域,所有权规则还会考虑变量的作用域</p>
</blockquote>
<ol>
<li>在 Rust 的背景下, 所有权与作用域协同工作。</li>
<li>因此,作用域只不过是变量和值存在的环境。你声明的每个变量都与作用域有关。</li>
<li>代码中的作用域是由一对花括号表示的。无论何时使用块表达式都会创建一个作用域,即任何以花括号开头和结尾的表达式。</li>
<li>此外,作用域支持互相嵌套,并且可以在子作用域中访问父作用域的元素,但反过来不行</li>
</ol>
<h4 id="多作用域的情况分析"><a class="header" href="#多作用域的情况分析">多作用域的情况分析</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// scopes.rs

/*
由于函数可以创建新的作用域, 因此 main 函数引入了根级别作用域 0,
在代码中定义为 level_0_str
*/
fn main() {
    let level_0_str = String::from(&quot;foo&quot;);
    /*
        在 0 级作用域中, 创建了一个新的作用域,即作用域 1,
        并且带有一个花括号,其中包含变量level_1_number。
    */
    {
        let level_1_number = 9;
        /*
            在 1 级作用域中, 创建了一个块表达式, 它成为 2 级作用域。
            在其中, 声明了另一个变量 level_2_vector,
            以便可以将 level_1_number 添加到其中,
            而level_1_number 来自其父级作用域 1
        */
        {
            let mut level_2_vector = vec![1, 2, 3];
            level_2_vector.push(level_1_number);    // can access
        } // level_2_vector goes out of scope here 

        level_2_vector.push(4);    // no longer exists
    } // level_1_number goes out of scope here
} // level_0_str goes out of scope here
</code></pre></pre>
<h4 id="作用域是推断所有权时的一个重要属性"><a class="header" href="#作用域是推断所有权时的一个重要属性">作用域是推断所有权时的一个重要属性</a></h4>
<blockquote>
<p>作用域还会被用来推断后续介绍的借用和生命周期。</p>
</blockquote>
<ol>
<li>当作用域结束时,拥有值的任何变量都会运行相关代码以取消分配该值,并且其自身在作用域之外是无效的。</li>
<li>特别是对在堆上分配的值,drop 方法会被放在作用域结束标记}之前调用。</li>
<li>这类似于在 C 语言中调用 free 函数,但这里是隐式的, 并且可以避免程序员忘记释放值。</li>
<li>drop 方法来自 Drop 特征,它是为 Rust 中大部分堆分配类型实现的,可以轻松地自动释放资源。</li>
</ol>
<h3 id="引入移动和复制语义"><a class="header" href="#引入移动和复制语义">引入移动和复制语义</a></h3>
<blockquote>
<p>结合作用域判断一下下列代码是否正确</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_primitives.rs

fn main() {
    let foo = 4623;
    /*
        4623 的所有权不会从 foo 转移到 bar,但 bar 会获得4623 的单独副本。
        看起来基元类型在 Rust 中会被特殊对待,它们会被移动而不是复制。
        这意味着根据我们在 Rust 中使用的类型,存在不同的所有权语义,这将引入移动和复制语义的概念
    */
    let bar = foo;
    println!(&quot;{:?} {:?}&quot;, foo, bar); 
}
</code></pre></pre>
<h4 id="语义是什么意思"><a class="header" href="#语义是什么意思">语义是什么意思</a></h4>
<p>以移动语义为例，在 Rust
中,变量绑定默认具有移动语义。但这究竟意味着什么?要理解这一点,我们需要考虑如何在程序中使用变量。我们创建值或资源并将它们分配给变量,以便在程序中可以方便地引用它们。这些变量是指向值所在内存地址的名称。现在,诸如读取、赋值、添加及将它们传递给函数等对变量的操作,在访问变量指向值的方式上可能具有不同的语义或含义。在静态类型语言中,这些语义大致分为移动语义和复制语义。</p>
<h4 id="移动语义变量访问或重新分配时默认"><a class="header" href="#移动语义变量访问或重新分配时默认">移动语义：变量访问或重新分配时默认</a></h4>
<blockquote>
<p>通过变量访问或重新分配给变量时移动到接收项的值表示移动语义。</p>
</blockquote>
<p>由于Rust 的仿射类型系统,它默认会采用移动语义。仿射类型系统的一个突出特点是值或资源只能使用一次,而 Rust 通过所有权规则展示此属性。</p>
<h4 id="复制语义"><a class="header" href="#复制语义">复制语义</a></h4>
<p>默认情况下,通过变量分配或访问,以及从函数返回时复制的值(例如按位复制)具有复制语义。这意味着该值可以使用任意次数,每个值都是全新的。</p>
<h4 id="使用copy特征更改语义"><a class="header" href="#使用copy特征更改语义">使用Copy特征更改语义</a></h4>
<p>Rust 中的移动语义有时会受到限制。幸运的是,通过实现 Copy 特征可以更改类型的行为以遵循复制语义。基元和其他仅适用于堆栈的数据类型在默认情况下实现了上述特征,这也是前面的基元代码能够正常工作的原因</p>
<pre><pre class="playground"><code class="language-rust  editable">// making_copy_types.rs

#[derive(Copy, Debug)]  // the trait `Clone` is not implemented for `Dummy`
struct Dummy;

fn main() {
    let a = Dummy;
    let b = a;
    println!(&quot;{:?}&quot;, a);
    println!(&quot;{:?}&quot;, b);
}
</code></pre></pre>
<h4 id="copy-特征依赖于clone-特征"><a class="header" href="#copy-特征依赖于clone-特征">Copy 特征依赖于Clone 特征</a></h4>
<blockquote>
<p>Clone 是 Copy 的父级特征, 任何实现 Copy 特征的类型必须实现 Clone。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// making_copy_types.rs

// 可以在派生注释中的 Copy 旁边添加 Clone 特征来让该示例通过编译
#[derive(Copy, Clone, Debug)]
struct Dummy;

fn main() {
    let a = Dummy;
    let b = a;
    println!(&quot;{:?}&quot;, a);
    println!(&quot;{:?}&quot;, b);
}
</code></pre></pre>
<h3 id="区别一下copy与clone-trait"><a class="header" href="#区别一下copy与clone-trait">区别一下Copy与Clone trait</a></h3>
<blockquote>
<p>Copy 和 Clone 特征传达了在代码中使用类型时如何进行复制的原理。</p>
</blockquote>
<table><thead><tr><th align="center">特征</th><th align="center">复制方式</th><th align="center">复制内容</th><th align="center">使用场景</th></tr></thead><tbody>
<tr><td align="center">Copy</td><td align="center">隐式，自动化特征</td><td align="center">堆栈</td><td align="center">可以在堆栈上单独表示的小型值</td></tr>
<tr><td align="center">Clone</td><td align="center">显式调用clone</td><td align="center">堆+栈</td><td align="center">在堆上还包含一个值作为其表示的一部分</td></tr>
</tbody></table>
<h4 id="copy"><a class="header" href="#copy">Copy</a></h4>
<ol>
<li>Copy 特征通常用于可以在堆栈上完全表示的类型, 也就是说它们自身没有任何部分位于堆上。</li>
<li>如果出现了这种情况,那么 Copy 将是开销很大的操作,因为它必须从堆中复制值。这直接影响到赋值运算符的工作方式。</li>
<li>如果类型实现了 Copy,则从一个变量到另一个变量的赋值操作将隐式复制数据。</li>
</ol>
<h4 id="clone"><a class="header" href="#clone">Clone</a></h4>
<p>Clone 特征用于显式复制, 并附带 clone 方法, 类型可以实现该方法以获取自身的副本</p>
<p>Clone 有一个名为 clone 的方法,用于获取接收者的不可变引用,即&amp;self,并返回相同类型的新值。用户自定义类型或任何需要提供能够复制自身的包装器类型,应通过实现clone 方法来实现 Clone 特征</p>
<blockquote>
<p>一个通过 Clone 特征复制类型的示例</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// explicit_copy.rs

// 在 derive 属性中添加了一个 Clone 特征。
#[derive(Clone, Debug)]
struct Dummy {
    items: u32,
}

fn main() {
    let a = Dummy { items: 54 };
    // 有了Clone, 我们就可以在 a 上调用 clone 方法来获得它的新副本
    let b = a.clone();
    println!(&quot;a: {:?}, b: {:?}&quot;, a, b);
}
</code></pre></pre>
<h3 id="copy与clone的使用原则"><a class="header" href="#copy与clone的使用原则">Copy与Clone的使用原则</a></h3>
<h4 id="何时在类型上实现-copy"><a class="header" href="#何时在类型上实现-copy">何时在类型上实现 Copy</a></h4>
<blockquote>
<p>可以在堆栈上单独表示的小型值如下所示。</p>
</blockquote>
<ul>
<li>如果类型仅依赖于在其上实现了 Copy 特征的其他类型, 则 Copy 特征是为其隐式实现的。</li>
<li>Copy 特征隐式影响赋值运算符的工作方式。 使用 Copy 特征构建自定义外部可见类型需要考虑它是否会对赋值运算符产生影响。 如果在开发的早期阶段,
你的类型是Copy,后续将它移除之后则会影响使用该类型进行赋值的所有环节。你可以通过这种方式轻松地破坏 API。</li>
</ul>
<h4 id="何时在类型上实现-clone"><a class="header" href="#何时在类型上实现-clone">何时在类型上实现 Clone。</a></h4>
<ul>
<li>Clone 特征只是声明一个 clone 方法,需要被显式调用。</li>
<li>如果你的类型在堆上还包含一个值作为其表示的一部分, 那么可选择实现 Clone 特征,这也需要向复制堆数据的用户明确表示。</li>
<li>如果要实现智能指针类型(例如引用计数类型) ,那么应该在类型上实现 Clone 特征,以便仅复制堆栈上的指针。</li>
</ul>
<h3 id="所有权使用场景"><a class="header" href="#所有权使用场景">所有权使用场景</a></h3>
<blockquote>
<p>重要的是我们能够识别它和编译器给出的错误提示信息</p>
</blockquote>
<h4 id="let绑定示例"><a class="header" href="#let绑定示例">let绑定示例</a></h4>
<h4 id="将参数传递给函数"><a class="header" href="#将参数传递给函数">将参数传递给函数</a></h4>
<blockquote>
<p>如果将参数传递给函数,那么相同的所有权规则也同样有效</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_functions.rs

fn take_the_n(n: u8) {}

fn take_the_s(s: String) {}

fn main() {
    let n = 5;
    let s = String::from(&quot;string&quot;);
    // take_the_n 函数能够正常工作,是因为 u8(基元类型)实现了 Copy 特征
    take_the_n(n);
    /*
        String 并没有实现 Copy 特征,因此值的所有权在 take_the_s 函数中会发生移动。
        当函数返回时,相关值的作用域也随之结束,并且会在 s 上调用 drop 方法,
        这会释放 s 所使用的堆内存。
        因此,在函数调用结束后 s 将失效
        使用clone即可通过编译：take_the_s(s.clone())
    */
    take_the_s(s);

    println!(&quot;n is {}&quot;, n);
    println!(&quot;s is {}&quot;, s);
}
</code></pre></pre>
<blockquote>
<p>如果我们只需要变量 s 的读取访问权限,那么可以让该代码正常工作的另一种方法是将字符串 s 传递回 main 函数</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_functions_back.rs

fn take_the_n(n: u8) {}

// 添加了一个返回类型
fn take_the_s(s: String) -&gt; String {
    println!(&quot;inside function: {}&quot;, s);
    // 并将传递的字符串返回给调用者
    s
}

fn main() {
    let n = 5;
    let s = String::from(&quot;string&quot;);

    take_the_n(n);
    let s = take_the_s(s);

    println!(&quot;n is {}&quot;, n);
    println!(&quot;s is {}&quot;, s);
}
</code></pre></pre>
<h4 id="match表达式"><a class="header" href="#match表达式">match表达式</a></h4>
<blockquote>
<p>在 match 表达式中,移动类型默认也会被移动</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_match.rs

#[derive(Debug)]
enum Food {
    Cake,
    Pizza,
    Salad,
}

#[derive(Debug)]
struct Bag {
    food: Food,
}

fn main() {
    let bag = Bag { food: Food::Cake };
    match bag.food {
        Food::Cake =&gt; println!(&quot;I got cake&quot;),
        a =&gt; println!(&quot;I got {:?}&quot;, a) // value partially moved here
    }

    println!(&quot;{:?}&quot;, bag); // value borrowed here after partial move
}
</code></pre></pre>
<h4 id="impl代码块"><a class="header" href="#impl代码块">impl代码块</a></h4>
<blockquote>
<p>impl 代码块中,任何以 self 作为第一个参数的方法都将获取调用该方法的值的所有权。这意味着对值调用方法后,你无法再次使用该值</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_methods.rs

struct Item(u32);

impl Item {
    fn new() -&gt; Self {
        Item(1024)
    }
    /*
        以 self 作为第 1 个参数的实例方法。
        在调用之后, 它将在方法内移动, 并在函数作用域结束时被释放。
        后续我们将不能再使用它
    */
    fn take_item(self) {
        // does nothing
    }
}

fn main() {
    let it = Item::new(); // move occurs because `it` has type `Item`, which does not implement the `Copy` trait
    it.take_item(); // `it` moved due to this method call
    println!(&quot;{}&quot;, it.0); // value borrowed here after move
}
</code></pre></pre>
<h4 id="闭包"><a class="header" href="#闭包">闭包</a></h4>
<blockquote>
<p>闭包接收不同的值取决于在其内部使用变量的方式</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_closures.rs

#[derive(Debug)]
struct Foo;

fn main() {
    let a = Foo;

    /*
        Foo 的所有权在闭包中已经默认移动到了 b,
        用户将无法再次访问 a。
    */
    // let closure = move || {
    let closure = || {
        let b = a;
    };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<h2 id="借用-通过引用规避所有权规则限制"><a class="header" href="#借用-通过引用规避所有权规则限制">借用: 通过引用规避所有权规则限制</a></h2>
<h3 id="为何需要借用引用"><a class="header" href="#为何需要借用引用">为何需要借用/引用</a></h3>
<p>Rust的所有权规则非常严格, 因为它只允许我们使用类型一次。 如果函数只需要对值的读取访问权限,那么我们需要再次从函数返回值,或者在它传递给函数之前复制它。如果类型没有实现 Clone 特征,那么后者可能无法实现其目的。
复制类型看起来似乎很容易绕过所有权规则,但是由于 Clone 总是复制类型,可能会调用内存分配器 API,这是一种涉及系统调用,并且开销高昂的操作,因此它无法满足零成本抽象承诺的所有要点。 随着移动语义和所有权规则的实施,在 Rust
中编写程序很快就会变得困难重重。幸运的是,我们引入了借用和引用类型的概念,它们放宽了规则所施加的限制,但仍然能够在编译期确保兼容所有权规则。</p>
<p>借用的概念是规避所有权规则的限制。进行借用时,你不会获取值的所有权,而是根据需要提供数据。这是通过借用值,即获取值的引用来实现的。为了借用值,我们需要将运算符&amp;放在变量之前,&amp;表示指向变量的地址。</p>
<h3 id="借用-or-引用"><a class="header" href="#借用-or-引用">借用 or 引用？</a></h3>
<h3 id="两种借用方式"><a class="header" href="#两种借用方式">两种借用方式</a></h3>
<h4 id="不可变借用"><a class="header" href="#不可变借用">不可变借用：&amp;</a></h4>
<blockquote>
<p>当我们在类型之前使用运算符&amp;时,就会创建一个不可变借用。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_basics.rs

#[derive(Debug)]
struct Foo;

fn main() {
    let foo = Foo;
    /*
        注意变量 foo 之前的&amp;。我们借用 foo 并将借用结果分配给 bar。
        bar 的类型为&amp;Foo, 这是一种引用类型。
        作为一个不可变借用,我们不能通过 bar 改变 Foo 中的值
     */
    let bar = &amp;foo;
    println!(&quot;Foo is {:?}&quot;, foo);
    println!(&quot;Bar is {:?}&quot;, bar);
}
</code></pre></pre>
<h4 id="可变借用mut"><a class="header" href="#可变借用mut">可变借用：&amp;mut</a></h4>
<blockquote>
<p>可以使用&amp;mut 运算符对某个值进行可变借用。 通过可变借用, 你可以改变该值。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// mutable_borrow.rs

fn main() {
    // 可变借用需要可变变量，所以这里会报错，可以加上mut
    let a = String::from(&quot;Owned string&quot;);
    /*
        用&amp;mut a 创建了一个该值的可变借用。
        这并没有将 a 移动到 b
        只是可变地对它借用。
    */
    let a_ref = &amp;mut a;
    a_ref.push('!');
}
</code></pre></pre>
<blockquote>
<p>可变借用可以改变值,但是不能销毁该值,因为它不是所有者。
如果a 在借用它的代码行之前被销毁,则借用失效</p>
</blockquote>
<p>{{#check 检查是否更新 | 借用失效情况并不存在}}</p>
<pre><pre class="playground"><code class="language-rust  editable">// exclusive_borrow.rs

fn main() {
    let mut a = String::from(&quot;Owned string&quot;);
    let a_ref = &amp;mut a;
    a_ref.push('!');
    println!(&quot;{}&quot;, a);
}
</code></pre></pre>
<div id="admonition-bug" class="admonition bug">
<div class="admonition-title">
<p>Bug</p>
<p><a class="admonition-anchor-link" href="layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html#admonition-bug"></a></p>
</div>
<div>
<p>(存疑🤨，待修正🤔️)</p>
</div>
</div>
<h3 id="借用规则"><a class="header" href="#借用规则">借用规则</a></h3>
<blockquote>
<p>通过引用来维护单一的所有权语义。这些规则如下所示</p>
</blockquote>
<ol>
<li>一个引用的生命周期可能不会超过其被引用的时间。 这是显而易见的, 因为如果它的生命周期超过其被借用的时间,那么它将指向一个垃圾值(被销毁的值) 。</li>
<li>如果存在一个值的可变借用,那么不允许其他引用(可变借用或不可变借用)在该作用域下指向相同的值。可变借用是一种独占性借用。</li>
<li>如果不存在指向某些东西的可变借用, 那么在该作用域下允许出现对同一值的任意数量的不可变借用</li>
</ol>
<h3 id="如果违反借用规则"><a class="header" href="#如果违反借用规则">如果违反借用规则</a></h3>
<h4 id="函数中的借用"><a class="header" href="#函数中的借用">函数中的借用</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// borrowing_functions.rs

// 接收可变借用作为参数
fn take_the_n(n: &amp;mut u8) {
    *n += 2;
}

fn take_the_s(s: &amp;mut String) {
    s.push_str(&quot;ing&quot;);
}

fn main() {
    // 变量绑定必须是可变
    let mut n = 5;
    let mut s = String::from(&quot;Borrow&quot;);
    // 因为函数内做了修改，所以调用时也需要使用可变借用
    take_the_n(&amp;mut n);
    take_the_s(&amp;mut s);

    println!(&quot;n changed to {}&quot;, n);
    println!(&quot;s changed to {}&quot;, s);
}
</code></pre></pre>
<h4 id="匹配中的借用"><a class="header" href="#匹配中的借用">匹配中的借用</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_match.rs

#[derive(Debug)]
enum Food {
    Cake,
    Pizza,
    Salad
}

#[derive(Debug)]
struct Bag {
    food: Food
}

fn main() {
    let bag = Bag { food: Food::Cake };
    match bag.food {
        Food::Cake =&gt; println!(&quot;I got cake&quot;),
        // 以 ref 作为前缀。
        // 关键字 ref 可以通过引用来匹配元素,而不是根据值来捕获它们。
        ref a =&gt; println!(&quot;I got {:?}&quot;, a)
    }
    
    println!(&quot;{:?}&quot;, bag);
}
</code></pre></pre>
<h4 id="从函数返回引用"><a class="header" href="#从函数返回引用">从函数返回引用：</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// return_func_ref.rs

fn get_a_borrowed_value() -&gt; &amp;u8 { // expected named lifetime parameter
    let x = 1;
    &amp;x
}

fn main() {
    let value = get_a_borrowed_value();
}
</code></pre></pre>
<h3 id="基于借用规则的方法类型"><a class="header" href="#基于借用规则的方法类型">基于借用规则的方法类型</a></h3>
<blockquote>
<p>借用规则还规定了如何定义类型的固有方法和特征的实例方法。以下是它们接收实例的方式,并且是根据限制由少到多排列的。</p>
</blockquote>
<ul>
<li>&amp;self 方法:这些方法只对其成员具有不可变的访问权限。</li>
<li>&amp;mut self 方法:这些方法能够可变地借用 self 实例。</li>
<li>self 方法:这些方法拥有调用它的实例的所有权,并且类型在后续调用时将失效。</li>
</ul>
<p>对于自定义类型,相同的借用规则也适用于其作用域成员。</p>
<h2 id="生命周期针对引用附加的信息"><a class="header" href="#生命周期针对引用附加的信息">生命周期：针对引用附加的信息</a></h2>
<h3 id="从变量生命周期开始"><a class="header" href="#从变量生命周期开始">从变量生命周期开始</a></h3>
<h3 id="生命周期限定"><a class="header" href="#生命周期限定">生命周期限定</a></h3>
<h3 id="生命周期注解"><a class="header" href="#生命周期注解">生命周期注解</a></h3>
<h3 id="生命周期省略"><a class="header" href="#生命周期省略">生命周期省略</a></h3>
<h2 id="参考资源"><a class="header" href="#参考资源">参考资源</a></h2>
<ul>
<li><a href="https://www.ditsing.com/object-lifetime-and-ownership/">Object lifetime and ownership</a></li>
<li><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">What is Ownership? - The Rust Programming Language</a></li>
<li>&lt;精通rust(第二版)&gt;-5.7 内存安全三原则</li>
<li><a href="https://www.zhihu.com/question/58863427">go没有虚拟机怎么运行gc的？ - 知乎</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/lifetime-elision.html#lifetime-elision-in-functions">生命周期省略规则(Lifetime elision) - The Rust Reference</a></li>
<li><a href="https://hashrust.com/blog/lifetimes-in-rust/">Lifetimes in Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%B5%B7%E6%BA%90">类型系统起源</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9C%A8%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B">我们为什么需要在语言中使用类型?</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#1-%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%88%B0%E6%B1%87%E7%BC%96">1. 从二进制数据格式到汇编</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#2-%E4%BB%8E%E6%B1%87%E7%BC%96%E5%88%B0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%BA%94%E8%BF%90%E8%80%8C%E7%94%9F">2. 从汇编到编程语言，类型系统应运而生</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#3-%E5%86%8D%E6%9D%A5%E8%AE%A4%E7%9C%9F%E7%9C%8B%E7%9C%8B%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">3. 再来认真看看类型系统</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#4-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%80%E7%BB%84%E8%A7%84%E5%88%99">4. 类型系统其实是一组规则</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#5-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%AF%B9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AE%89%E5%85%A8%E7%9A%84%E6%8A%BD%E8%B1%A1">5. 类型系统是对内存管理/安全的抽象</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/type_system.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:36 CST 2022 -->
<!--te-->
<h1 id="类型系统起源"><a class="header" href="#类型系统起源">类型系统起源</a></h1>
<h2 id="我们为什么需要在语言中使用类型"><a class="header" href="#我们为什么需要在语言中使用类型">我们为什么需要在语言中使用类型?</a></h2>
<blockquote>
<p>这是一个很好的问题,可以作为理解编程语言类型系统的契机。</p>
</blockquote>
<h3 id="1-从二进制数据格式到汇编"><a class="header" href="#1-从二进制数据格式到汇编">1. 从二进制数据格式到汇编</a></h3>
<p>作为程序员,我们知道为计算机编写的程序在最底层是以 0 和 1
组成的二进制数据格式表示的。实际上,最早的计算机必须使用机器代码手动编程。最终,程序员意识到这样做非常容易出错,并且乏味、耗时。对大部分人来说,在二进制层面操作和推断这些实体是不切实际的。 到了 20 世纪 50 年代,
编程社区提出了机器代码助记符的概念, 这些助记符变成了今天我们熟知的汇编语言。</p>
<h3 id="2-从汇编到编程语言类型系统应运而生"><a class="header" href="#2-从汇编到编程语言类型系统应运而生">2. 从汇编到编程语言，类型系统应运而生</a></h3>
<p>然后,编程语言应运而生,它们被编译成汇编代码,并允许编程人员编写人类可理解的代码,以方便计算机将其编译成机器代码。然而,大家平时所说的语言表达某些语义比较模糊,因此需要制定一套规则和条件,来表述用类似人类语言编写的计算机程序中可能或不可能存在的内容,即程序语义。这使得我们提出了类型和类型系统的理念。</p>
<h3 id="3-再来认真看看类型系统"><a class="header" href="#3-再来认真看看类型系统">3. 再来认真看看类型系统</a></h3>
<p>类型是一组具名的可能值。例如,u8 是一种可能包含 0~255 的正数值类型。类型提供了一种方法来弥合我们创建的这些实体的底层表示与心理模型之间的差距。除此之外, 类型还为我们提供了<strong>表示实体的意图、行为和约束的方法</strong>：</p>
<blockquote>
<p>它们定义了用户通过类型能够(不能够) 做什么。 例如, 它没有定义将字符串类型的值和数值类型的值相加的结果是什么。</p>
</blockquote>
<h3 id="4-类型系统其实是一组规则"><a class="header" href="#4-类型系统其实是一组规则">4. 类型系统其实是一组规则</a></h3>
<p>从类型来看,语言设计者构建了类型系统,这些系统是一组规则,用于管理不同类型在编程语言中的交互。它们可以用作推断程序的工具,并有助于确保程序能够正常运行并符合规范。类型系统根据其表达力进行限定,这仅表示你可以使用类型表达逻辑的程度,以及程序中的不变量。</p>
<blockquote>
<p>例如 Haskell 是一种高级语言,它具有非常丰富的表现力的类型系统,而C 语言是一种低级语言,它只为我们提供了很少的基于类型的抽象。Rust 试图在这两个极端之间找到一种平衡。</p>
</blockquote>
<h3 id="5-类型系统是对内存管理安全的抽象"><a class="header" href="#5-类型系统是对内存管理安全的抽象">5. 类型系统是对内存管理/安全的抽象</a></h3>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ol>
<li>&lt;精通Rust(第二版)&gt;-4.1 类型系统及其重要性</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础内置类型"><a class="header" href="#基础内置类型">基础内置类型</a></h1>
<!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/built_in_types.html#%E5%9F%BA%E7%A1%80%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">基础内置类型</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/built_in_types.html#%E5%9F%BA%E5%85%83%E7%B1%BB%E5%9E%8B">基元类型</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/built_in_types.html#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B">序列类型</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/built_in_types.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B">自定义类型</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/built_in_types.html#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B">函数类型</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/built_in_types.html#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B">指针类型</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/built_in_types.html#%E7%89%B9%E5%BE%81%E7%B1%BB%E5%9E%8B">特征类型</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/built_in_types.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:33 CST 2022 -->
<!--te-->
<h2 id="基元类型"><a class="header" href="#基元类型">基元类型</a></h2>
<h2 id="序列类型"><a class="header" href="#序列类型">序列类型</a></h2>
<h2 id="自定义类型"><a class="header" href="#自定义类型">自定义类型</a></h2>
<h2 id="函数类型"><a class="header" href="#函数类型">函数类型</a></h2>
<h2 id="指针类型"><a class="header" href="#指针类型">指针类型</a></h2>
<h2 id="特征类型"><a class="header" href="#特征类型">特征类型</a></h2>
<h2 id="参考资源-1"><a class="header" href="#参考资源-1">参考资源</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/reference/types.html">Types - The Rust Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合类型"><a class="header" href="#集合类型">集合类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义类型-1"><a class="header" href="#自定义类型-1">自定义类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型特征及特征对象"><a class="header" href="#泛型特征及特征对象">泛型、特征及特征对象</a></h1>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/rust-traits-deep-dive.png" alt="rust-traits-deep-dive" /></p>
<!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81%E5%8F%8A%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1">泛型、特征及特征对象</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B">泛型</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E5%87%BA%E5%8F%91">从代码复用出发</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E4%B8%8D%E8%B6%B3">函数作用不足</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E8%BF%98%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B%E6%9D%A5%E5%A4%8D%E7%94%A8%E4%BB%A3%E7%A0%81">静态类型语言还需要泛型来复用代码</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%B8%80%E7%A7%8D%E5%8D%95%E6%80%81%E5%8C%96">泛型本质上是一种单态化</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">泛型使用方式</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">泛型函数</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93">泛型结构体</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E6%9E%9A%E4%B8%BE%E4%BD%93">泛型枚举体</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81">泛型特征</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">泛型方法</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#impl-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%9D%97">impl: 泛型实现块</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0">泛型实现</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%B8%93%E9%97%A8%E5%8C%96%E6%B3%9B%E5%9E%8B">专门化泛型</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BE%8B%E5%8C%96">指定类型进行实例化</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%8E%A8%E6%96%AD">基于类型实例化推断</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%9F%90%E4%BA%9B%E6%96%B9%E6%B3%95">泛型函数调用某些方法</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#turbofish-">turbofish: ::&lt;&gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81">特征</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%BB%8E%E5%A4%9A%E6%80%81%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B-%E6%8E%A5%E5%8F%A3%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E7%89%B9%E5%BE%81">从多态和代码复用的角度来看: 接口、鸭子类型还是特征？</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81-1">特征</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88">特征到底是什么？</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F">特征的多种表现形式</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%A0%87%E8%AE%B0%E7%89%B9%E5%BE%81">标记(特征)</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%AE%80%E5%8D%95%E7%89%B9%E5%BE%81">简单(特征)</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81-1">泛型(特征)</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81">关联类型(特征)</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%BB%A7%E6%89%BF%E7%89%B9%E5%BE%81">继承(特征)</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%89%B9%E5%BE%81">一些常用内置特征</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#debug">Debug</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#partialeq-%E5%92%8C-eq">PartialEq 和 Eq</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#copy%E5%92%8Cclone">Copy和Clone</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#display">Display</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#add">Add</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#into-%E5%92%8C-from">Into 和 From</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90">一个完整例子</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81">特征区间：泛型+特征</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%BC%95%E5%87%BA%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4">引出特征区间</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%BB%A3%E7%A0%81%E5%8D%95%E4%BD%93%E5%8C%96">代码单体化</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%8C%87%E5%AE%9A%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%96%B9%E6%B3%95">指定特征区间的四个方法</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%8C%BA%E9%97%B4%E5%86%85%E6%B3%9B%E5%9E%8B-fn-fn_namet-target_traitval-t">区间内泛型: fn fn_name&lt;T: target_trait&gt;(val: T)</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#where%E8%AF%AD%E5%8F%A5-%E5%BD%93%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E8%BF%87%E9%95%BF%E6%97%B6%E4%BD%BF%E7%94%A8">where语句: 当第一种方法签名过长时使用</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E7%89%B9%E5%BE%81">使用&quot;+&quot;组合多个特征</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%BD%BF%E7%94%A8impl%E7%89%B9%E5%BE%81%E8%AF%AD%E6%B3%95-%E9%97%AD%E5%8C%85%E5%B8%B8%E7%94%A8">使用impl特征语法: 闭包常用</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">特征区间的使用场景</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BB%BA%E8%AE%AE">在类型上使用：不建议</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0impl%E4%BB%A3%E7%A0%81%E5%9D%97">泛型函数+impl代码块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81%E7%89%B9%E5%BE%81%E7%B1%BB%E5%9E%8B">特征对象: 多态特征类型</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%88%86%E5%8F%91dispatch">分发(dispatch)</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%88%86%E5%8F%91%E6%96%B9%E5%BC%8F%E9%9D%99%E6%80%81-or-%E5%8A%A8%E6%80%81">分发方式：静态 or 动态</a></li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%8C%BA%E5%88%AB%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E4%B8%8E%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1">区别特征区间与特征对象</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E5%85%B7%E4%BD%93%E8%AF%B4%E8%AF%B4">特征对象具体说说</a>
<ul>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%8C%87%E5%AE%9A%E4%B8%BA%E5%AE%9E%E7%8E%B0%E6%9F%90%E4%B8%AA%E7%89%B9%E5%BE%81">指定为实现某个特征</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E7%94%A8%E8%83%96%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0">用胖指针实现</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%98%AFrust%E6%89%A7%E8%A1%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91%E7%9A%84%E6%96%B9%E5%BC%8F">是Rust执行动态分发的方式</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8B%E5%8F%AA%E8%83%BD%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E5%88%9B%E5%BB%BA">不定长类型只能作为引用创建</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E6%80%BB%E7%BB%93%E7%89%B9%E5%BE%81%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E5%92%8C%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1">总结特征、特征区间和特征对象</a></li>
<li><a href="layer1_underlying_abstract/2_type_system/generics_traits_objects.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:35 CST 2022 -->
<!--te-->
<h2 id="泛型"><a class="header" href="#泛型">泛型</a></h2>
<h3 id="从代码复用出发"><a class="header" href="#从代码复用出发">从代码复用出发</a></h3>
<h4 id="函数作用不足"><a class="header" href="#函数作用不足">函数作用不足</a></h4>
<p>一直以来，函数的实现方式就是基于c语言的goto指令：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20220613150721312.png" alt="image-20220613150721312" /></p>
<p>通过进一步强化，就得到函数的实现方式：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20220613150804039.png" alt="image-20220613150804039" /></p>
<blockquote>
<p>但是也就这样了，函数只能实现流程上的复用，不能实现类型上的复用。这一点其实在python、js这些动态类型语言上面就不存在这个问题。对于Rust这种静态类型语言，对函数入参类型要求十分严格，于是泛型就应运而生。</p>
</blockquote>
<h4 id="静态类型语言还需要泛型来复用代码"><a class="header" href="#静态类型语言还需要泛型来复用代码">静态类型语言还需要泛型来复用代码</a></h4>
<blockquote>
<p>泛型编程是一种仅适用于静态类型编程语言的技术。它首次出现在 ML 语言中,是一种静态类型的函数式语言。</p>
</blockquote>
<p>像 Python 这样的动态语言采用的是简单类型 (duck typing) , 其中的 API 是根据它们可以做什么,而不是它们是什么来处理参数的,因此不依赖于泛型。</p>
<p>泛型是语言设计特性的一部分, 可以实现代码复用, 并遵循不重复自己的原则 (Don't Repeat Yourself,DRY) 。采用这种技术,你可以使用类型占位符来编写算法、函数、方法及类型, 并在这些类型上指定一个类型变量(
使用单个字母,通常是 T、K 或 V) ,告知编译器在任何代码中实例化它们时要填充的实际类型。这些类型被称为泛型或元素。单个字母(例如类型 T)被称为泛型参数。当你使用或实例化任何泛型元素时,它们会被替换成诸如 u32 这样的具体类型。</p>
<h3 id="泛型本质上是一种单态化"><a class="header" href="#泛型本质上是一种单态化">泛型本质上是一种单态化</a></h3>
<p>每次将泛型元素与具体类型一起使用时,都会在编译时用类型变量 T 生成该代码的特定副本,并将其替换为具体类型。<strong>这种在编译时生成包含具体类型的专用函数的过程被称为单态化,这是执行与多态函数相反的过程。</strong></p>
<h3 id="泛型使用方式"><a class="header" href="#泛型使用方式">泛型使用方式</a></h3>
<blockquote>
<p>在使用泛型时，应该多去考虑它与不同元素结合使用的场景背后的思维方式。泛型可以与结构体、枚举、函数、特征、方法及代码实现块。它们的一个共同特征是泛型的参数是由一对尖头括号分隔,并包含于其中。</p>
</blockquote>
<h4 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h4>
<p>为了创建泛型函数,我们需要将泛型参数放在函数名之后和圆括号之前,如下所示:</p>
<pre><pre class="playground"><code class="language-rust  editable">// generic_function.rs

fn give_me&lt;T&gt;(value: T) {
    let _ = value;
}

fn main() {
    let a = &quot;generics&quot;;
    let b = 1024;
    give_me(a);
    give_me(b);
}
</code></pre></pre>
<h4 id="泛型结构体"><a class="header" href="#泛型结构体">泛型结构体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// generic_struct.rs

struct Container&lt;T&gt; {
    item: T,
}

impl&lt;T&gt; Container&lt;T&gt; {
    fn new(item: T) -&gt; Self {
        Container { item }
    }
}

impl Container&lt;u32&gt; {
    fn sum(item: u32) -&gt; Self {
        Container { item }
    }
}

fn main() {
    // todo
}
</code></pre></pre>
<h4 id="泛型枚举体"><a class="header" href="#泛型枚举体">泛型枚举体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// generic_enum.rs

enum Transmission&lt;T&gt; {
    Signal(T),
    NoSignal,
}

fn main() {
    // stuff
}
</code></pre></pre>
<h4 id="泛型特征"><a class="header" href="#泛型特征">泛型特征</a></h4>
<h4 id="泛型方法"><a class="header" href="#泛型方法">泛型方法</a></h4>
<h3 id="impl-泛型实现块"><a class="header" href="#impl-泛型实现块">impl: 泛型实现块</a></h3>
<h4 id="泛型实现"><a class="header" href="#泛型实现">泛型实现</a></h4>
<blockquote>
<p>当为任何泛型编写 impl 代码块时,都需要在使用它之前声明泛型参数。T 就像一个变量—— 一个类型变量,我们需要先声明它 impl代码块实际上意味着我们正在为所有类型 T 实现这些方法,它们会出现在 Container<T>中。这个 impl 代码块是一个泛型实现。 因此,生成的每个具体 Container 都将有这些方法。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// generic_struct_impl.rs

struct Container&lt;T&gt; {
    item: T,
}

impl&lt;T&gt; Container&lt;T&gt; {
    fn new(item: T) -&gt; Self {
        Container { item }
    }
}

fn main() {
    // stuff
}
</code></pre></pre>
<h4 id="专门化泛型"><a class="header" href="#专门化泛型">专门化泛型</a></h4>
<blockquote>
<p>在这里, 由于 u32 是作为具体类型存在的, 因此我们不需要 impl 之后的<T>, 这是 impl 代码块的另外一个特性,它允许你通过独立实现方法来专门化泛型。 现在,我们也可以通过将 T 替换为任何具体类型来为 Container<T>编写更具体的 impl 代码块。以下就是它的实例:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">impl Container&lt;u32&gt; { 
    fn sum(item: u32) -&gt; Self {
        Container { item }
    } 
}
</code></pre></pre>
<h3 id="指定类型进行实例化"><a class="header" href="#指定类型进行实例化">指定类型进行实例化</a></h3>
<blockquote>
<p>每当我们进行实例化时, 编译器需要在其类型签名中知道 T 的具体类型以便替换,这为其提供了将泛型代码单态化的类型信息。 而具体类型的确定主要有三种方式：</p>
</blockquote>
<ol>
<li>大多数情况下,具体类型是基于类型的实例化推断.</li>
<li>对泛型函数调用某些方法来接收具体类型。</li>
<li>在极个别情况下, 我们需要通过使用 <code>turbofish (::&lt;&gt;)</code>运算符输入具体类型来替代泛型以便辅助编译器识别。</li>
</ol>
<h4 id="基于类型实例化推断"><a class="header" href="#基于类型实例化推断">基于类型实例化推断</a></h4>
<p>这是最常见的方式，主要基于类型特征(trait)。</p>
<h4 id="泛型函数调用某些方法"><a class="header" href="#泛型函数调用某些方法">泛型函数调用某些方法</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// using_generic_func.rs

use std::str;

fn main() {
    let num_from_str = str::parse::&lt;u8&gt;(&quot;34&quot;).unwrap();
    println!(&quot;Parsed number {}&quot;, num_from_str);
}
</code></pre></pre>
<h4 id="turbofish-"><a class="header" href="#turbofish-">turbofish: ::&lt;&gt;</a></h4>
<ol>
<li>如果没有任何类型特征，代码将无法编译：👇</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let a = Vec::new();
}
</code></pre></pre>
<ol start="2">
<li>这时可以用下列三种方式指定</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">// using_generic_vec.rs

fn main() {
    // providing a type
    let v1: Vec&lt;u8&gt; = Vec::new();

    // or calling method
    let mut v2 = Vec::new();
    v2.push(2); // v2 is now Vec&lt;i32&gt;

    // or using turbofish
    let v3 = Vec::&lt;u8&gt;::new(); // not so readable
}
</code></pre></pre>
<h2 id="特征"><a class="header" href="#特征">特征</a></h2>
<h3 id="从多态和代码复用的角度来看-接口鸭子类型还是特征"><a class="header" href="#从多态和代码复用的角度来看-接口鸭子类型还是特征">从多态和代码复用的角度来看: 接口、鸭子类型还是特征？</a></h3>
<p>从多态和代码复用的角度来看, 在代码中将类型的共享行为和公共属性与其自身隔离通常是一个好主意,并且能拥有专属于自己的方法。在这样做时,我们允许不同类型通过通用属性互相关联,使我们能够为 API 编程,使其参数更通用或更具包容性。</p>
<blockquote>
<p>这意味着我们可以接收具有这些通用属性的类型,而不仅限于某种特定类型。</p>
</blockquote>
<h4 id="接口"><a class="header" href="#接口">接口</a></h4>
<p>类似 Java 和 C#的面向对象编程语言中,接口表达了相同的理念,我们可以在其中定义多种类型能够实现的共享行为。例如,我们可以使用单个 sort 函数接收实现 Comparable 或者 Comparator
接口的元素列表,而不是使用多个 sort 函数接收整数值列表,以及用其他函数接收字符串值列表。这使得我们可以将任何可比较(Comparable)的内容传递给 sort 函数。</p>
<h4 id="鸭子类型"><a class="header" href="#鸭子类型">鸭子类型</a></h4>
<p>而Python同样有明确的特性，被称为&quot;鸭子类型&quot;.</p>
<blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>
</blockquote>
<p>在鸭子类型中，关注点在于对象的行为，能做什么；而不是关注对象所属的类型。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为“鸭子”的对象，并调用它的“走”和“叫”方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的“走”和“叫”方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的“走”和“叫”方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p>
<p>鸭子类型通常得益于“不”测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。</p>
<p>在常规类型中，我们能否在一个特定场景中使用某个对象取决于这个对象的类型，而在鸭子类型中，则取决于这个对象是否具有某种属性或者方法——即只要具备特定的属性或方法，能通过鸭子测试，就可以使用。</p>
<h4 id="特征-1"><a class="header" href="#特征-1">特征</a></h4>
<p>Rust也有一个类似且功能强大的结构,被称为特征。Rust中的特征以多种形式存在, 我们将介绍一些最常见的形式并了解一些与它们简单交互的方式。此外,当特征与泛型搭配使用时,可以限制传递到 API
的参数范围。我们将会对特征进行比较深入的了解。</p>
<h3 id="特征到底是什么"><a class="header" href="#特征到底是什么">特征到底是什么？</a></h3>
<h3 id="特征的多种表现形式"><a class="header" href="#特征的多种表现形式">特征的多种表现形式</a></h3>
<h4 id="标记特征"><a class="header" href="#标记特征">标记(特征)</a></h4>
<h4 id="简单特征"><a class="header" href="#简单特征">简单(特征)</a></h4>
<h4 id="泛型特征-1"><a class="header" href="#泛型特征-1">泛型(特征)</a></h4>
<h4 id="关联类型特征"><a class="header" href="#关联类型特征">关联类型(特征)</a></h4>
<h4 id="继承特征"><a class="header" href="#继承特征">继承(特征)</a></h4>
<h3 id="一些常用内置特征"><a class="header" href="#一些常用内置特征">一些常用内置特征</a></h3>
<h4 id="debug"><a class="header" href="#debug">Debug</a></h4>
<p>这个特征有助于在控制台上输出类型以便进行调试。在组合类型的情况下,类型将以类似 JSON 的格式输出,其中带有花括号和其他括号,如果类型是字符串,将会用引号标识。这适用于 Rust 中的大多数内置类型。</p>
<h4 id="partialeq-和-eq"><a class="header" href="#partialeq-和-eq">PartialEq 和 Eq</a></h4>
<p>这些特征允许两个元素相互比较以验证是否相等</p>
<h4 id="copy和clone"><a class="header" href="#copy和clone">Copy和Clone</a></h4>
<p>这些特征定义了类型的复制方式。 简而言之,当在任何自定义类型上自动派生时,这些特征允许用户从实例创建新的副本:</p>
<ol>
<li>可以在实现 Copy 时隐式创建</li>
<li>也可以在实现 Clone 时通过调用 clone() 显式创建。</li>
</ol>
<blockquote>
<p>请注意,Copy 依赖于在类型上实现的 Clone 特征</p>
</blockquote>
<h4 id="display"><a class="header" href="#display">Display</a></h4>
<h4 id="add"><a class="header" href="#add">Add</a></h4>
<h4 id="into-和-from"><a class="header" href="#into-和-from">Into 和 From</a></h4>
<h3 id="一个完整例子"><a class="header" href="#一个完整例子">一个完整例子</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// complex/src/lib.rs

use std::ops::Add;

/*
将#[derive(Default)] 属性实现为一个过程宏,可以自动实现它修饰的类型的特征。
此自动派生要求任何自定义类型的字段(例如结构体或枚举)本身必须实现 Default 特征。
使用它们继承特征仅适用于结构体、枚举及联合。
*/
#[derive(Default, Debug, PartialEq, Copy, Clone)]
struct Complex&lt;T&gt; {
    // Real part
    re: T,
    // Complex part
    im: T,
}

impl&lt;T&gt; Complex&lt;T&gt; {
    // new 函数实际上并不是一个特殊的构造函数(如果你只了解带有构造函数的语言),
    // 而是社区采用的一个常用名称(作为创建新类型实例的方法名) 。
    fn new(re: T, im: T) -&gt; Self {
        Complex { re, im }
    }
}

// 来自 std::ops 模块的 Add 特征允许我们使用“+”运算符将两个复数相加
/*
1. impl&lt;T: Add&lt;T, Output=T&gt;表示我们正在为泛型 T 实现 Add,其中 T 实现 Add&lt;T, Output=T&gt;。
2. &lt;T, Output=T&gt;部分表示 Add 特征的实现必须具有相同的输入和输出类型
3. Add for Complex&lt;T&gt;部分表示为 Complex&lt;T&gt;类型实现 Add 特征
4. T:Add 表示必须实现 Add 特征。如果没有实现,那么我们不能使用“+”运算符
*/
impl&lt;T: Add&lt;T, Output=T&gt;&gt; Add for Complex&lt;T&gt; {
    type Output = Complex&lt;T&gt;;
    // Add 特征提供的核心功能,是我们在两种实现类型之间使用“+”运算符时调用的方法。
    // 它是一个实例方法,通过值获取 self 并接收 rhs 作为参数,即特征定义中的 RHS。
    fn add(self, rhs: Complex&lt;T&gt;) -&gt; Self::Output {
        Complex { re: self.re + rhs.re, im: self.im + rhs.im }
    }
}

// 来自 std::convert 模块的 Into 和 From 特征使用户能够根据其他类型创建复数类型
/*
1. 如果我们可以从内置基元类型 (例如双元素元组) 构造 Complex 类型
   其中第 1 个元素是实部,第 2 个元素是虚部,将会很方便。
   我们可以通过实现 From 特征来达到此目的。
2. 此特征定义了一个 from 方法, 为我们提供了在类型之间进行转换的一般方法
3. 第一个&lt;T&gt;是泛型 T 的声明, 第二个和第三个&lt;T&gt;是泛型类型 T 的用途。 我们会根据(T,T) 类型创建它
*/
impl&lt;T&gt; From&lt;(T, T)&gt; for Complex&lt;T&gt; {
    /*
        当我们实现它时, 只需要用我们希望实现它的类型替换 T 并实现 from 方法,
        然后我们就可以在相关类型上调用该方法。
        这是一个将 Complex 值转换为双元素元组类型的实现, Rust本身就能识别它
    */
    fn from(value: (T, T)) -&gt; Complex&lt;T&gt; {
        Complex { re: value.0, im: value.1 }
    }
}

use std::fmt::{Formatter, Display, Result};

// Display 特征能够输出人类可读版本的复数类型
impl&lt;T: Display&gt; Display for Complex&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result {
        // 为了让用户能够以数学符号的形式查看复数类型
        write!(f, &quot;{} + {}i&quot;, self.re, self.im)
    }
}

// 一个简单的初始化测试用例。
#[cfg(test)]
mod tests {
    use crate::Complex;

    #[test]
    fn complex_basics() {
        let first = Complex::new(3, 5);
        let second: Complex&lt;i32&gt; = Complex::default();
        assert_eq!(first.re, 3);
        assert_eq!(first.im, 5);
        assert!(second.re == second.im);
    }

    #[test]
    fn complex_addition() {
        let a = Complex::new(1, -2);
        let b = Complex::default();
        let res = a + b;
        assert_eq!(res, a);
    }

    #[test]
    fn complex_from() {
        let a = (2345, 456);
        let complex = Complex::from(a);
        assert_eq!(complex.re, 2345);
        assert_eq!(complex.im, 456);
    }

    #[test]
    fn complex_display() {
        let my_imaginary = Complex::new(2345, 456);
        println!(&quot;{}&quot;, my_imaginary);
    }
}
// 最后使用cargo test -- --nocapture执行
</code></pre></pre>
<h2 id="特征区间泛型特征"><a class="header" href="#特征区间泛型特征">特征区间：泛型+特征</a></h2>
<h3 id="引出特征区间"><a class="header" href="#引出特征区间">引出特征区间</a></h3>
<p>首先看一下如下代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_intro.rs

struct Game;

struct Enemy;

struct Hero;
/*
在 Game 类型上我们有一个泛型函数 load,它可以接收任何游戏实体,
并通过任意 T 调用 init()将其加载到我们的游戏世界中。
但是,这个示例无法通过编译
*/
impl Game {
    fn load&lt;T&gt;(&amp;self, entity: T) {
        entity.init(); // method not found in `T`
    }
}

fn main() {
    let game = Game;
    game.load(Enemy);
    game.load(Hero);
}
</code></pre></pre>
<ol>
<li>因此, 任何类型为 T 的泛型函数都不能知道或默认假定 init()方法存在于 T 之上。</li>
<li>如果确实如此,那么它根本不是泛型,并且它们只能接收具有 init()方法的类型。</li>
<li><strong>因此,有一种方法可以让编译器知道这一点,并约束 load 通过特征能够接收的类型集,这就需要用到特征区间</strong>。</li>
</ol>
<blockquote>
<p>我们可以定义一个名为 Loadable 的特征,并在我们的 Enemy 和 Hero 类型上实现它。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_intro.rs

struct Game;

struct Enemy;

struct Hero;

trait Loadable {
    fn init(&amp;self);
}
/*
我们分别为 Enemy 和 Hero 实现了 Loadable,还修改了 load 方法
*/
impl Loadable for Enemy {
    fn init(&amp;self) {
        println!(&quot;Enemy loaded&quot;);
    }
}

impl Loadable for Hero {
    fn init(&amp;self) {
        println!(&quot;Hero loaded&quot;);
    }
}

impl Game {
    /*
        我们必须在泛型声明旁边放置几个符号来指定特征,我们称之为特征区间
    */
    fn load&lt;T: Loadable&gt;(&amp;self, entity: T) {
        entity.init();
    }
}

fn main() {
    let game = Game;
    game.load(Enemy);
    game.load(Hero);
}
</code></pre></pre>
<ol>
<li>注意, “:Loadable”部分表明了我们指定特征范围的方式。特征区间允许我们限制泛型 API 可以接收的参数范围。</li>
</ol>
<h3 id="代码单体化"><a class="header" href="#代码单体化">代码单体化</a></h3>
<ol>
<li>指定泛型元素上的绑定的特征类似于我们为变量指定类型的方式</li>
<li>但是此处的变量是泛型 T,类型是某些特征。例如 <strong>T:SomeTrait</strong>。</li>
<li>定义泛型函数时几乎总是会用到特征区间。</li>
<li>如果定义的泛型函数中的 T 不包含任何特征区间,我们就不能通过任何方法调用,因 Rust 不知道给定方法实现的方式。</li>
<li>它需要知道 T 是否具有某个 foo 方法,以便<strong>将代码单体化</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_basics.rs

// 我们有一个方法 add_thing,它可以添加任何类型 T。
fn add_thing&lt;T&gt;(fst: T, snd: T) {
    // 编译器向用户建议在 T 上添加特征区间 Add
    // help: consider restricting type parameter `T`
    let _ = fst + snd;
}

fn main() {
    add_thing(2, 2);
}
</code></pre></pre>
<blockquote>
<p>修正后</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bound_basics_fixed.rs

use std::ops::Add;

// 代码修改之后,我们将“:Add”添加到了 T 的后面,之后代码通过了编译
fn add_thing&lt;T: Add&gt;(fst: T, snd: T) {
    let _ = fst + snd;
}

fn main() {
    add_thing(2, 2);
}
</code></pre></pre>
<h3 id="指定特征区间的四个方法"><a class="header" href="#指定特征区间的四个方法">指定特征区间的四个方法</a></h3>
<h4 id="区间内泛型-fn-fn_namet-target_traitval-t"><a class="header" href="#区间内泛型-fn-fn_namet-target_traitval-t">区间内泛型: fn fn_name&lt;T: target_trait&gt;(val: T)</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 指定特征区间的一种方法, 它会接收任何实现了 Display 特征的类型
fn show_me&lt;T: Display&gt;(val: T) {
    //可以使用{}格式化字符串，因为有Display特征区间
    printin!(&quot;{}&quot;, val);
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>这是在泛型函数的类型签名的长度较短时声明特征区间的常见语法。</li>
<li>在指定类型的特征区间时,此语法也有效</li>
</ol>
<h4 id="where语句-当第一种方法签名过长时使用"><a class="header" href="#where语句-当第一种方法签名过长时使用">where语句: 当第一种方法签名过长时使用</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;
    where F: FromStr { ... }
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>注意“where F: FromStr”部分告诉我们 F 类型必须实现 FromStr 特征。where 语句将特征区间和函数签名解耦,并使其可读</p>
</blockquote>
<h4 id="使用组合多个特征"><a class="header" href="#使用组合多个特征">使用&quot;+&quot;组合多个特征</a></h4>
<ul>
<li>先看一下标准库中 HashMap 类型的 impl 代码块:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// HashMap 键类型的 K 必须实现 Hash 特征和 Eq 特征
impl&lt;K: Hash + Eq, V&gt; HashMap&lt;K, V, RandomState&gt;
{}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>一个更加具体的例子</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">// traits_composition.rs

trait Eat {
    fn eat(&amp;self) {
        println!(&quot;eat&quot;);
    }
}

trait Code {
    fn code(&amp;self) {
        println!(&quot;code&quot;);
    }
}

trait Sleep {
    fn sleep(&amp;self) {
        println!(&quot;sleep&quot;);
    }
}

// 创建了一个新的特征 Programmer,它由 3 个特征组合而成:Eat、Code、 Sleep。
// 通过这种方式, 我们对类型设置了约束:
// 因此如果类型 T 实现了 Programmer, 那么它必须实现上述所有特征
trait Programmer: Eat + Code + Sleep {
    fn animate(&amp;self) {
        self.eat();
        self.code();
        self.sleep();
        println!(&quot;repeat!&quot;);
    }
}

struct Bob;

impl Programmer for Bob {}

impl Eat for Bob {}

impl Code for Bob {}

impl Sleep for Bob {}

fn main() {
    Bob.animate();
}
</code></pre></pre>
<h4 id="使用impl特征语法-闭包常用"><a class="header" href="#使用impl特征语法-闭包常用">使用impl特征语法: 闭包常用</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// impl_trait_syntax.rs

use std::fmt::Display;

/*
直接使用了 impl Display,而不是指定 T:Display。这是 impl 特征语法。
这为我们返回复杂或不方便表示的类型(例如函数的闭包)提供了便利
*/
fn show_me(val: impl Display) {
    println!(&quot;{}&quot;, val);
}

fn main() {
    show_me(&quot;Trait bounds are awesome&quot;);
}
</code></pre></pre>
<blockquote>
<p>如果没有这种语法,则必须使用 Box 智能指针类型将其放在指针后面返回,这涉及堆分配。
闭包的底层结构由实现了一系列特征的结构体组成。<strong>Fn(T) -&gt; U</strong> 特征就是其中之一</p>
</blockquote>
<p>闭包使用示例：</p>
<pre><pre class="playground"><code class="language-rust  editable">// impl_trait_closure.rs
// 它接收两个数字,并返回将这两个数字相加的闭包
fn lazy_adder(a: u32, b: u32) -&gt; impl Fn() -&gt; u32 {
    move || a + b
}

fn main() {
    // 调用 lazy_adder,传入两个数字。
    // 这会在 lazy_adder 中创建一个闭包,但不会对其进行求值
    let add_later = lazy_adder(1024, 2048);
    println!(&quot;{:?}&quot;, add_later());
}
</code></pre></pre>
<p>还可以在入参和返回使用：</p>
<pre><pre class="playground"><code class="language-rust  editable">// impl_trait_both.rs

use std::fmt::Display;

/*
1. 会接收任何 Display 特征的参数
2. 返回的类型是 impl Display
*/
fn surround_with_braces(val: impl Display) -&gt; impl Display {
    format!(&quot;{{{}}}&quot;, val)
}

fn main() {
    println!(&quot;{}&quot;, surround_with_braces(&quot;Hello&quot;));
}
</code></pre></pre>
<ol>
<li>通常建议将特征区间的 impl 特征语法用做函数的返回类型。</li>
<li>在参数位置使用它意味着我们不能使用 turbofish 运算符。</li>
<li>如果某些相关代码使用 turbofish 运算符来调用软件包中的某个方法,那么可能导致 API 不兼容。</li>
<li>只有当我们没有可用的具体类型时才应该使用它, 就像闭包那样。</li>
</ol>
<h3 id="特征区间的使用场景"><a class="header" href="#特征区间的使用场景">特征区间的使用场景</a></h3>
<h4 id="在类型上使用不建议"><a class="header" href="#在类型上使用不建议">在类型上使用：不建议</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_types.rs

use std::fmt::Display;

// 写法一：区间内泛型
struct Foo&lt;T: Display&gt; {
    bar: T,
}

// 写法二：where语句解耦
struct Bar&lt;F&gt;
    where
        F: Display,
{
    inner: F,
}

fn main() {}
</code></pre></pre>
<blockquote>
<p>不过,我们并不鼓励在类型上使用特征区间,因为它对类型自身施加了限制。
通常, 我们希望类型尽可能是泛型,从而允许我们使用任何类型创建实例,并使用函数或方法中的特征区间对其行为进行限制。</p>
</blockquote>
<h4 id="泛型函数impl代码块"><a class="header" href="#泛型函数impl代码块">泛型函数+impl代码块</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_functions.rs

use std::fmt::Debug;

trait Eatable {
    fn eat(&amp;self);
}

// 指定类型必须是 Debug,以便其可以在方法内部输出到控制台
#[derive(Debug)]
struct Food&lt;T&gt;(T);

#[derive(Debug)]
struct Apple;

// 为了让 apple 是“可食用”的,我们实现了 Food 的 Eatable 特征
impl&lt;T&gt; Eatable for Food&lt;T&gt;
    where
        T: Debug,
{
    fn eat(&amp;self) {
        println!(&quot;Eating {:?}&quot;, self);
    }
}

// 注意 eat 的特点,类型 T 必须实现 Eatable 特征。
fn eat&lt;T&gt;(val: T)
    where
        T: Eatable,
{
    val.eat();
}

fn main() {
    let apple = Food(Apple);
    eat(apple);
}
</code></pre></pre>
<h2 id="特征对象-多态特征类型"><a class="header" href="#特征对象-多态特征类型">特征对象: 多态特征类型</a></h2>
<h3 id="分发dispatch"><a class="header" href="#分发dispatch">分发(dispatch)</a></h3>
<blockquote>
<p>分发是一个从面向对象编程范式中借鉴的概念,主要用于描述被称为多态的上下文中的一种特性。 在面向对象程序设计(Object-Oriented Programming,OOP)中,当 API 是泛型或者接收实现为接口的参数时,必须弄清楚参数在传递给 API 的类型实例上调用什么方法实现。多态的上下文中的方法解析过程被称为分发,调用该方法被称为分发化(dispatching) 。</p>
</blockquote>
<h4 id="分发方式静态-or-动态"><a class="header" href="#分发方式静态-or-动态">分发方式：静态 or 动态</a></h4>
<blockquote>
<p>在支持多态的主流语言中,分发可以通过以下任意一种方式进行。</p>
</blockquote>
<ol>
<li>静态分发：编译期决定</li>
</ol>
<p>当在编译期决定要调用的方法时,它被称为静态分发或早期绑定。方法的签名用于决定调用的方法,所有这些都在编译期决定。在 Rust 中,泛型展示了这种形式的分发, 因为即使泛型函数可以接收许多参数, 也会在编译期使用具体类型生成函数的专用副本。</p>
<p>2.动态分发: 运行期决定，资源开销更大</p>
<p>在面向对象的语言中,有时直到运行时才能确定调用的方法。这是因为具体类型被隐藏,并且只有接口方法可用于调用该类型。 在 Java 中,当函数只有参数时就是这种情况,即接口。 这种情况只能通过动态分发来处理。在动态分发过程中,可通过对
vtable 接口的实现列表进行查找,并调用该方法来动态确定相关方法。vtable 是一个函数指针列表,指向每个类型的实现方法。由于方法调用过程中存在额外的间接指针引用,所以这需要更多的资源开销</p>
<h3 id="区别特征区间与特征对象"><a class="header" href="#区别特征区间与特征对象">区别特征区间与特征对象</a></h3>
<table><thead><tr><th align="center">特征使用方式</th><th align="center">分发方式</th><th align="center">实现方式</th><th align="center">绑定时期</th><th></th></tr></thead><tbody>
<tr><td align="center">特征区间</td><td align="center">静态分发</td><td align="center">限定泛型</td><td align="center">编译期(早期绑定)</td><td></td></tr>
<tr><td align="center">特征对象</td><td align="center">动态分发</td><td align="center">胖指针</td><td align="center">运行期多态(后期绑定)</td><td></td></tr>
</tbody></table>
<h3 id="特征对象具体说说"><a class="header" href="#特征对象具体说说">特征对象具体说说</a></h3>
<h4 id="指定为实现某个特征"><a class="header" href="#指定为实现某个特征">指定为实现某个特征</a></h4>
<p>特征对象是一种创建多态 API 的方法,可以将参数指定为实现某个特征的东西,而不是泛型或具体类型。这种方法被声明为实现某个特征 API,即特征对象。</p>
<h4 id="用胖指针实现"><a class="header" href="#用胖指针实现">用胖指针实现</a></h4>
<p>特征对象类似 C++中的虚方法。特征对象实现为胖指针,并且是不定长类型,这意味着它们只能在引用符号(&amp;)后面使用。特征对象胖指针具有指向与对象关联的实际数据的第一指针,而第二指针指向虚拟表(vtable)
,它是在固定偏移处为每个对象的方法保留一个函数指针的结构体。</p>
<h4 id="是rust执行动态分发的方式"><a class="header" href="#是rust执行动态分发的方式">是Rust执行动态分发的方式</a></h4>
<p>特征对象是 Rust 执行动态分发的方式,我们没有实际的具体类型信息。通过跳转到vtable 并调用适当的方法完成方法解析。</p>
<p>特征对象的另一个用例是,它们允许用户对可以具有多种类型的集合进行操作,但是在运行时需要额外的间接指针引用开销</p>
<pre><pre class="playground"><code class="language-rust  editable">// trait_objects.rs

use std::fmt::Debug;

#[derive(Debug)]
struct Square(f32);

#[derive(Debug)]
struct Rectangle(f32, f32);

trait Area: Debug {
    fn get_area(&amp;self) -&gt; f32;
}

impl Area for Square {
    fn get_area(&amp;self) -&gt; f32 {
        self.0 * self.0
    }
}

impl Area for Rectangle {
    fn get_area(&amp;self) -&gt; f32 {
        self.0 * self.1
    }
}

fn main() {
    /*
        shapes 的元素类型是&amp;dyn Area,这是一种表示为特征的类型。
        特征对象是由 dyn Area 表示的, 意味着它是指向 Area 特征某些实现的指针。
        特征对象形式的类型允许用户在集合类型(例如 Vec)中存储不同类型

        Square 和 Rectangle 会隐式转换成特征对象,因为我们给它们推送了一个引用。
        我们还可以通过手动转换某个特征对象来构造一个类型,但这是一种比较少见的情况.
        只有在编译器自身无法将类型作为特征对象转换时使用。
    */
    let shapes: Vec&lt;&amp;dyn Area&gt; = vec![&amp;Square(3f32), &amp;Rectangle(4f32, 2f32)];
    for s in shapes {
        println!(&quot;{:?}&quot;, s);
    }
}
</code></pre></pre>
<h4 id="不定长类型只能作为引用创建"><a class="header" href="#不定长类型只能作为引用创建">不定长类型只能作为引用创建</a></h4>
<blockquote>
<p>请注意,我们只能创建在编译时知道类型尺寸的特征对象。</p>
</blockquote>
<p>dyn Trait 是一个不定长类型,只能作为引用创建。我们还可以通过将特征对象置于其他指针类型之后来创建特征对象,例如 Box、Rc、Arc 等</p>
<pre><pre class="playground"><code class="language-rust  editable">// dyn_trait.rs

use std::fmt::Display;

fn show_me(item: &amp;dyn Display) {
    println!(&quot;{}&quot;, item);
}

fn main() {
    show_me(&amp;&quot;Hello trait object&quot;);
}
</code></pre></pre>
<h2 id="总结特征特征区间和特征对象"><a class="header" href="#总结特征特征区间和特征对象">总结特征、特征区间和特征对象</a></h2>
<p>特征和泛型通过单态化(早期绑定)或运行时多态(后期绑定)提供了两种代码复用的方式。 何时使用它们取决于具体情况和相关应用程序的需求：</p>
<ol>
<li>通常,错误类型会被分配到动态分发的序列,因为它们应该是很少被执行的代码路径。</li>
<li>单态化对小型的应用场景来说非常方便,但是缺点是导致了代码的膨胀和重复,这会影响缓存效率,并增加二进制文件的大小。</li>
</ol>
<blockquote>
<p>但是,在这两个选项中,静态分发应该是首选,除非系统对二进制文件大小存在严格的限制。</p>
</blockquote>
<h2 id="参考资源-2"><a class="header" href="#参考资源-2">参考资源</a></h2>
<ul>
<li>&lt;精通rust(第二版)&gt;-第四章：类型、泛型和特征</li>
<li><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">Advanced Traits - The Rust Programming Language</a></li>
<li><a href="https://blog.logrocket.com/rust-traits-a-deep-dive/">Rust traits: A deep dive - LogRocket Blog</a></li>
<li>《代码之髓》- 第五章：函数</li>
<li><a href="https://zh.m.wikipedia.org/zh-hans/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型 - 维基百科，自由的百科全书</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/trait-bounds.html">Trait and lifetime bounds - The Rust Reference</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/special-types-and-traits.html">Special types and traits - The Rust Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/3_language_grammar/language_grammar.html#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E6%A6%82%E8%BF%B0">编程语言语法概述</a>
<ul>
<li><a href="layer1_underlying_abstract/3_language_grammar/language_grammar.html#%E5%89%8D%E8%A8%80">前言</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:40 CST 2022 -->
<!--te-->
<h1 id="编程语言语法概述"><a class="header" href="#编程语言语法概述">编程语言语法概述</a></h1>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>其实编程语言的语法本质上就分成三部分：确定使用什么类型、类型可以用的操作、通用逻辑操作。不过语法又不是这么简单，它担负着两方面的作用：</p>
<ol>
<li></li>
</ol>
<p>与编译器交互：因为这些语法在编译器内部都有对应的操作，涉及一系列繁杂的自动化操作。所以当编写语法可以通过编译，至少说明程序可以跑起来。这一点在rust中尤其明显，毕竟rust是出了名的“面向编译器”开发语言，编译器对语法的要求可以算作“苛刻”。但是这样也有好处，就是潜移默化之中，编程思维也被调整一番。</p>
<ol start="2">
<li>与编程人员交互：这里主要指编程需要可读且易读。这和代码质量息息相关，这里的编程人员不仅包括第一个写出这段代码的人，还包括后续开发以及协作的开发人员。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="词法关键字扫盲"><a class="header" href="#词法关键字扫盲">词法关键字扫盲</a></h1>
<h2 id="1-关键字"><a class="header" href="#1-关键字">1. 关键字</a></h2>
<h3 id="严格关键字"><a class="header" href="#严格关键字">严格关键字</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>as / break / const / continue / crate / if / else / struct / enum / true / false / fn / for / in / let / loop / impl / mod / match / move mut / pub / ref / return / self / Self / static / super /trait / type / unsafe /use / where / while / async /await/dyn/main
<span class="boring">}
</span></code></pre></pre>
<h3 id="弱关键字"><a class="header" href="#弱关键字">弱关键字</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>abstract / become / box / do / final / macro / override / priv / typeof / unsized / virtual / yield / try
<span class="boring">}
</span></code></pre></pre>
<h3 id="保留字"><a class="header" href="#保留字">保留字</a></h3>
<ul>
<li>2018 Edition:union,'static</li>
<li>2015 Edition:dyn</li>
</ul>
<blockquote>
<p>被保留的关键字不代表将来一定会使用</p>
</blockquote>
<h2 id="2-标识符"><a class="header" href="#2-标识符">2. 标识符</a></h2>
<h2 id="3-注释"><a class="header" href="#3-注释">3. 注释</a></h2>
<blockquote>
<p>//!, /<em>!, //!!, /</em>!!, /<strong>...<em>/, //, ////, /</em></strong>...*/</p>
</blockquote>
<h2 id="4-空白-nttab"><a class="header" href="#4-空白-nttab">4. 空白: \n、\t、tab</a></h2>
<blockquote>
<p>任何形式的空白字符在RuSt中只用于分隔标记，没有语义意义。</p>
</blockquote>
<h2 id="5-词条"><a class="header" href="#5-词条">5. 词条</a></h2>
<ol>
<li>语言项(item)</li>
<li>块(block)</li>
<li>语句（Stmt)</li>
<li>表达式（Expr)</li>
<li>模式（Pattern)</li>
<li>关键字（Keyword)</li>
<li>标识符（Ident)</li>
<li>字面量(Literal)</li>
<li>生命周期(Lifetime)</li>
<li>可见性(Vis)</li>
<li>标点符号（Punctuation)</li>
<li>分隔符（delimiter)</li>
<li>词条树(Token Tree)</li>
<li>属性（Attribute)</li>
</ol>
<h2 id="路径--"><a class="header" href="#路径--">路径: ::, ::&lt;&gt;</a></h2>
<h2 id="参考资源-3"><a class="header" href="#参考资源-3">参考资源</a></h2>
<ul>
<li><a href="https://time.geekbang.org/course/detail/100060601-286522">词法结构</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/lexical-structure.html">Lexical structure - The Rust Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="绑定赋值与匹配"><a class="header" href="#绑定赋值与匹配">绑定、赋值与匹配</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="逻辑判断与循环"><a class="header" href="#逻辑判断与循环">逻辑判断与循环</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语句与表达式"><a class="header" href="#语句与表达式">语句与表达式</a></h1>
<!--ts-->
<ul>
<li><a href="layer1_underlying_abstract/3_language_grammar/statements_expressions.html#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F">语句与表达式</a>
<ul>
<li><a href="layer1_underlying_abstract/3_language_grammar/statements_expressions.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:42 CST 2022 -->
<!--te-->
<h2 id="参考资源-4"><a class="header" href="#参考资源-4">参考资源</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/reference/lexical-structure.html">Lexical structure - The Rust Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:01 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:43 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="面向对象编程"><a class="header" href="#面向对象编程">面向对象编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型编程"><a class="header" href="#泛型编程">泛型编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:50 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="项目模块管理及扩展"><a class="header" href="#项目模块管理及扩展">项目模块管理及扩展</a></h1>
<!--ts-->
<ul>
<li><a href="layer2_design_abstract/6_module_manage/6_module_manage.html#%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E5%8F%8A%E6%89%A9%E5%B1%95">项目模块管理及扩展</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:51 CST 2022 -->
<!--te-->
<p>对于一门编程语言，是否能够成为工程化开发工具的主要标准在于两点：</p>
<ol>
<li>包管理、模块管理</li>
<li>扩展工具是否方便加入</li>
</ol>
<p>这里面包含一些通用的设计抽象，因此专门作为单独的一层。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块相关"><a class="header" href="#模块相关">模块相关</a></h1>
<!--ts-->
<ul>
<li><a href="layer2_design_abstract/6_module_manage/module_relate.html#%E6%A8%A1%E5%9D%97%E7%9B%B8%E5%85%B3">模块相关</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/module_relate.html#%E6%A8%A1%E5%9D%97%E6%96%B9%E5%BC%8F">模块方式</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/module_relate.html#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%9D%97">嵌套模块</a></li>
<li><a href="layer2_design_abstract/6_module_manage/module_relate.html#%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97">文件模块</a></li>
<li><a href="layer2_design_abstract/6_module_manage/module_relate.html#%E7%9B%AE%E5%BD%95%E6%A8%A1%E5%9D%97">目录模块</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/module_relate.html#%E5%B5%8C%E5%A5%97%E5%AF%BC%E5%85%A5">嵌套导入</a></li>
<li><a href="layer2_design_abstract/6_module_manage/module_relate.html#%E5%86%8D%E6%AC%A1%E5%AF%BC%E5%87%BA">再次导出</a></li>
<li><a href="layer2_design_abstract/6_module_manage/module_relate.html#%E9%9A%90%E7%A7%81%E7%AE%A1%E7%90%86">隐私管理</a></li>
<li><a href="layer2_design_abstract/6_module_manage/module_relate.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:53 CST 2022 -->
<!--te-->
<h2 id="模块方式"><a class="header" href="#模块方式">模块方式</a></h2>
<h3 id="嵌套模块"><a class="header" href="#嵌套模块">嵌套模块</a></h3>
<h3 id="文件模块"><a class="header" href="#文件模块">文件模块</a></h3>
<h3 id="目录模块"><a class="header" href="#目录模块">目录模块</a></h3>
<h2 id="嵌套导入"><a class="header" href="#嵌套导入">嵌套导入</a></h2>
<h2 id="再次导出"><a class="header" href="#再次导出">再次导出</a></h2>
<h2 id="隐私管理"><a class="header" href="#隐私管理">隐私管理</a></h2>
<div id="admonition-pubcrate-fn-fn_name-" class="admonition info">
<div class="admonition-title">
<p>pub(crate) fn fn_name() {}</p>
<p><a class="admonition-anchor-link" href="layer2_design_abstract/6_module_manage/module_relate.html#admonition-pubcrate-fn-fn_name-"></a></p>
</div>
<div>
<p>Rust 中元素的隐私性是从模块层面开始的。作为程序库的作者,要从模块向用户公开一些内容可以使用关键字 pub。但是对于有一些元素,我们只想暴露给软件包中的其他模块,而不是用户。在这种情况下,我们可以对元素使用 pub(crate)修饰符,这允许元素仅在软件包内部暴露</p>
</div>
</div>
<h2 id="参考资源-5"><a class="header" href="#参考资源-5">参考资源</a></h2>
<ul>
<li>&lt;精通Rust(第二版)&gt;-2.2模块</li>
<li>&lt;精通Rust(第二版)&gt;-7.9 模块、路径和导入</li>
<li><a href="https://doc.rust-lang.org/stable/reference/visibility-and-privacy.html">Visibility and privacy - The Rust Reference</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/visibility-and-privacy.html#pubin-path-pubcrate-pubsuper-and-pubself">pub(in path), pub(crate), pub(super), and pub(self) - The Rust Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo与crate生命周期"><a class="header" href="#cargo与crate生命周期">Cargo与crate生命周期</a></h1>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/cargo_ship.jpeg" alt="cargo_ship" /></p>
<!--ts-->
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo%E4%B8%8Ecrate%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Cargo与crate生命周期</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo--%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%90%86%E8%A7%A3cargo%E6%8C%87%E4%BB%A4%E7%B3%BB%E5%88%97">cargo : 用生命周期理解Cargo指令系列</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E6%96%B0%E5%BB%BA">新建</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-new">cargo new</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-init">cargo init</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E5%BC%80%E5%8F%91">开发</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-clean">cargo clean</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-doc">cargo doc</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">依赖管理</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-check">cargo check</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-fix">cargo fix</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-fetch">cargo fetch</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-searchinstalluninstall">cargo search/install/uninstall</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-report">cargo report</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-generate-lockfile">cargo generate-lockfile</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-locate-project">cargo locate-project</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-metadata">cargo metadata</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-pkgid">cargo pkgid</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-tree">cargo tree</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-update">cargo update</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-vendor">cargo vendor</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-verify-project">cargo verify-project</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E6%B5%8B%E8%AF%95">测试</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-test">cargo test</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-bench">cargo bench</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E8%BF%90%E8%A1%8C">运行</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-run">cargo run</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E6%9E%84%E5%BB%BA">构建</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-rustc">cargo rustc</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-build">cargo build</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-rustdoc">cargo rustdoc</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E5%8F%91%E5%B8%83">发布</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-login">cargo login</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-owner">cargo owner</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-package">cargo package</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-publish">cargo publish</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-yank">cargo yank</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargo-owner-1">cargo owner</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E7%BB%B4%E6%8A%A4">维护</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E5%88%86%E5%8C%BA">分区</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#cargotoml%E7%BB%86%E8%AF%B4">Cargo.toml细说</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#rust%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93">Rust程序运行方式总结</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E8%84%9A%E6%9C%AC">脚本</a></li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E9%A1%B9%E7%9B%AE">项目</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/cargo_crate_lifetime.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:52 CST 2022 -->
<!--te-->
<h2 id="cargo--用生命周期理解cargo指令系列"><a class="header" href="#cargo--用生命周期理解cargo指令系列">cargo <cmd>: 用生命周期理解Cargo指令系列</a></h2>
<h3 id="新建"><a class="header" href="#新建">新建</a></h3>
<h4 id="cargo-new"><a class="header" href="#cargo-new">cargo new</a></h4>
<h4 id="cargo-init"><a class="header" href="#cargo-init">cargo init</a></h4>
<h3 id="开发"><a class="header" href="#开发">开发</a></h3>
<h4 id="cargo-clean"><a class="header" href="#cargo-clean">cargo clean</a></h4>
<h4 id="cargo-doc"><a class="header" href="#cargo-doc">cargo doc</a></h4>
<h3 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h3>
<h4 id="cargo-check"><a class="header" href="#cargo-check">cargo check</a></h4>
<h4 id="cargo-fix"><a class="header" href="#cargo-fix">cargo fix</a></h4>
<h4 id="cargo-fetch"><a class="header" href="#cargo-fetch">cargo fetch</a></h4>
<h4 id="cargo-searchinstalluninstall"><a class="header" href="#cargo-searchinstalluninstall">cargo search/install/uninstall</a></h4>
<h4 id="cargo-report"><a class="header" href="#cargo-report">cargo report</a></h4>
<h4 id="cargo-generate-lockfile"><a class="header" href="#cargo-generate-lockfile">cargo generate-lockfile</a></h4>
<h4 id="cargo-locate-project"><a class="header" href="#cargo-locate-project">cargo locate-project</a></h4>
<h4 id="cargo-metadata"><a class="header" href="#cargo-metadata">cargo metadata</a></h4>
<h4 id="cargo-pkgid"><a class="header" href="#cargo-pkgid">cargo pkgid</a></h4>
<h4 id="cargo-tree"><a class="header" href="#cargo-tree">cargo tree</a></h4>
<h4 id="cargo-update"><a class="header" href="#cargo-update">cargo update</a></h4>
<h4 id="cargo-vendor"><a class="header" href="#cargo-vendor">cargo vendor</a></h4>
<h4 id="cargo-verify-project"><a class="header" href="#cargo-verify-project">cargo verify-project</a></h4>
<h3 id="测试"><a class="header" href="#测试">测试</a></h3>
<h4 id="cargo-test"><a class="header" href="#cargo-test">cargo test</a></h4>
<h4 id="cargo-bench"><a class="header" href="#cargo-bench">cargo bench</a></h4>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<h4 id="cargo-run"><a class="header" href="#cargo-run">cargo run</a></h4>
<h3 id="构建"><a class="header" href="#构建">构建</a></h3>
<h4 id="cargo-rustc"><a class="header" href="#cargo-rustc">cargo rustc</a></h4>
<h4 id="cargo-build"><a class="header" href="#cargo-build">cargo build</a></h4>
<h4 id="cargo-rustdoc"><a class="header" href="#cargo-rustdoc">cargo rustdoc</a></h4>
<h3 id="发布"><a class="header" href="#发布">发布</a></h3>
<h4 id="cargo-login"><a class="header" href="#cargo-login">cargo login</a></h4>
<h4 id="cargo-owner"><a class="header" href="#cargo-owner">cargo owner</a></h4>
<h4 id="cargo-package"><a class="header" href="#cargo-package">cargo package</a></h4>
<h4 id="cargo-publish"><a class="header" href="#cargo-publish">cargo publish</a></h4>
<h4 id="cargo-yank"><a class="header" href="#cargo-yank">cargo yank</a></h4>
<h4 id="cargo-owner-1"><a class="header" href="#cargo-owner-1">cargo owner</a></h4>
<h3 id="维护"><a class="header" href="#维护">维护</a></h3>
<h3 id="分区"><a class="header" href="#分区">分区</a></h3>
<h2 id="cargotoml细说"><a class="header" href="#cargotoml细说">Cargo.toml细说</a></h2>
<h2 id="rust程序运行方式总结"><a class="header" href="#rust程序运行方式总结">Rust程序运行方式总结</a></h2>
<h3 id="脚本"><a class="header" href="#脚本">脚本</a></h3>
<h3 id="项目"><a class="header" href="#项目">项目</a></h3>
<h2 id="参考资源-6"><a class="header" href="#参考资源-6">参考资源</a></h2>
<ul>
<li>&lt;精通Rust(第二版)&gt;-2.3 Cargo和程序库</li>
<li><a href="https://doc.rust-lang.org/cargo/commands/index.html">Cargo Commands - The Cargo Book</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust扩展工具介绍"><a class="header" href="#rust扩展工具介绍">Rust扩展工具介绍</a></h1>
<!--ts-->
<ul>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#rust%E6%89%A9%E5%B1%95%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D">Rust扩展工具介绍</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#cargo%E5%AD%90%E5%91%BD%E4%BB%A4%E7%B3%BB%E5%88%97-cargo-install-">Cargo子命令系列: cargo install </a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#cargo-watch">cargo-watch</a></li>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#cargo-edit">cargo-edit</a></li>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#cargo-deb">cargo-deb</a></li>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#cargo-outdated">cargo-outdated</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#rustup%E7%B3%BB%E5%88%97-rust-component-add-tool_name">rustup系列: rust component add &lt;tool_name&gt;</a>
<ul>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#clippy">clippy</a></li>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#rustc">rustc</a></li>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#rustfmt">rustfmt</a></li>
</ul>
</li>
<li><a href="layer2_design_abstract/6_module_manage/rust_plugins.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:20:53 CST 2022 -->
<!--te-->
<h2 id="cargo子命令系列-cargo-install"><a class="header" href="#cargo子命令系列-cargo-install">Cargo子命令系列: cargo install <binary crate name></a></h2>
<h3 id="cargo-watch"><a class="header" href="#cargo-watch">cargo-watch</a></h3>
<h3 id="cargo-edit"><a class="header" href="#cargo-edit">cargo-edit</a></h3>
<h3 id="cargo-deb"><a class="header" href="#cargo-deb">cargo-deb</a></h3>
<h3 id="cargo-outdated"><a class="header" href="#cargo-outdated">cargo-outdated</a></h3>
<h2 id="rustup系列-rust-component-add-tool_name"><a class="header" href="#rustup系列-rust-component-add-tool_name">rustup系列: rust component add &lt;tool_name&gt;</a></h2>
<h3 id="clippy"><a class="header" href="#clippy">clippy</a></h3>
<h3 id="rustc"><a class="header" href="#rustc">rustc</a></h3>
<h3 id="rustfmt"><a class="header" href="#rustfmt">rustfmt</a></h3>
<h2 id="参考资源-7"><a class="header" href="#参考资源-7">参考资源</a></h2>
<ul>
<li>&lt;精通Rust(第二版)&gt;-2.4 Cargo工具扩展</li>
<li><a href="https://rust-lang.github.io/rustup/concepts/components.html">Components - The rustup book</a></li>
<li><a href="https://rust-lang.github.io/rustup-components-history/">Rustup packages availability on x86_64-unknown-linux-gnu</a></li>
<li><a href="https://rust-lang.github.io/rustup/concepts/channels.html#nightly-availability">Channels - The rustup book</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:07 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:04 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="从io模型开始"><a class="header" href="#从io模型开始">从IO模型开始</a></h1>
<!--ts-->
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E4%BB%8Eio%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%A7%8B">从IO模型开始</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#1-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%AB">1. 同步/异步、阻塞/非阻塞概念区别</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E8%B0%83%E7%94%A8%E8%80%85%E8%A7%86%E8%A7%92">同步和异步，关注的是消息通信机制。（调用者视角）</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%85%B3%E6%B3%A8%E7%9A%84%E6%98%AF%E7%A8%8B%E5%BA%8F%E7%AD%89%E5%BE%85%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%9C%E7%9A%84%E7%8A%B6%E6%80%81%E8%A2%AB%E8%B0%83%E7%94%A8%E8%80%85%E8%A7%86%E8%A7%92">阻塞和非阻塞，关注的是程序等待调用结果的状态。（被调用者视角）</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E9%98%BB%E5%A1%9E%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9C%89%E5%85%B3">阻塞，与系统调用有关。</a></li>
</ul>
</li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#2-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5io-%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB">2. 同步/异步IO 模型分类</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#3-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9Eio-blocking-io">3. 同步阻塞I/O (blocking I/O)</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#4-io-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8io-multiplexing-">4. I/O 多路复用（I/O Multiplexing )</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#5-epoll-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B">5. epoll: 同步阻塞/非阻塞模型</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#epoll%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0">epoll三个函数</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#epoll-%E4%B8%A4%E7%A7%8D%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6">epoll 两种触发机制：</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E6%83%8A%E7%BE%A4%E9%97%AE%E9%A2%98">惊群问题：</a></li>
</ul>
</li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#6-%E5%BC%82%E6%AD%A5-io-%E6%A8%A1%E5%9E%8B-io_uring">6. 异步 I/O 模型: io_uring</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#1-reactor%E5%8F%8D%E5%BA%94%E5%99%A8-%E6%A8%A1%E5%BC%8F">1. Reactor（反应器） 模式</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#2-preactor%E4%B8%BB%E5%8A%A8%E5%99%A8-%E6%A8%A1%E5%BC%8F">2. Preactor（主动器） 模式</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#reactor-model">Reactor Model:</a>
<ul>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">三种实现方式：</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B">读写操作流程：</a></li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E5%8F%82%E4%B8%8E%E8%80%85">参与者：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer3_task_abstract/7_concurrency/io_models.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:05 CST 2022 -->
<!--te-->
<h2 id="1-同步异步阻塞非阻塞概念区别"><a class="header" href="#1-同步异步阻塞非阻塞概念区别">1. 同步/异步、阻塞/非阻塞概念区别</a></h2>
<h3 id="同步和异步关注的是消息通信机制调用者视角"><a class="header" href="#同步和异步关注的是消息通信机制调用者视角">同步和异步，关注的是消息通信机制。（调用者视角）</a></h3>
<ul>
<li>同步，发出一个调用，在没有得到结果之前不返回。</li>
<li>异步，发出一个调用，在没有得到结果之前返回。</li>
</ul>
<h3 id="阻塞和非阻塞关注的是程序等待调用结果的状态被调用者视角"><a class="header" href="#阻塞和非阻塞关注的是程序等待调用结果的状态被调用者视角">阻塞和非阻塞，关注的是程序等待调用结果的状态。（被调用者视角）</a></h3>
<ul>
<li>阻塞，在调用结果返回之前，线程被挂起。</li>
<li>非阻塞，在调用结果返回之前，线程不会被挂起。</li>
</ul>
<h3 id="阻塞与系统调用有关"><a class="header" href="#阻塞与系统调用有关">阻塞，与系统调用有关。</a></h3>
<h2 id="2-同步异步io-模型分类"><a class="header" href="#2-同步异步io-模型分类">2. 同步/异步IO 模型分类</a></h2>
<pre><code class="language-text">                                 +-+ 阻 塞 I/O (BIO)
                                 |
                                 +-+ 非 阻 塞 I/O (NIO)
                                 |
              +----+ 同 步 I/O +--+
              |                  |
              |                  +-+ I/O 多 路 复 用
              |                  |
              |                  +-+ 信 号 驱 动 I/O
I/O 模 型  +---+
              |
              |
              |                  +-+ Linux (AIO)
              |                  |         (io_uring)
              +----+ 异 步 I/O +--+
                                 |
                                 +-+ windows (IOCP)

</code></pre>
<h2 id="3-同步阻塞io-blocking-io"><a class="header" href="#3-同步阻塞io-blocking-io">3. 同步阻塞I/O (blocking I/O)</a></h2>
<pre><code class="language-text">Application               kernel
+---------+            +-----------+  +---+
|         |   syscall  | no        |      |
|   Read  | +--------&gt; | datagram  |      |
| recvfrom|            | ready     |      |
|         |            |    +      |      +-+ wait for
|         |            |    |      |      +-+ data
|         |            |    v      |      |
|         |            | datagram  |      |
|         |            | ready     |  +---+
|         |            |           |
|         |            | copy      |  +---+
|         |            | datagram  |      |
|process  |            |    +      |      +-+ copy data
|datagram |   return   |    |      |      +-+ from kernel to user
|         | &lt;--------+ |    v      |      |
|         |            |  copy     |  +---+
|         |            |  complete |
+---------+            +-----------+
</code></pre>
<blockquote>
<p>输入操作两个阶段：</p>
</blockquote>
<ol>
<li>进程等待内核把数据准备好；这个阶段可以阻塞也可非阻塞，设置socket属性。
<ul>
<li>阻塞： recvfrom 阻塞线程直到返回数据就绪的结果。</li>
<li>非阻塞：立即返回一个错误，轮询直到数据就绪。</li>
</ul>
</li>
<li>从内核缓冲区向进程缓冲区复制数据。（一直阻塞）</li>
</ol>
<p>异步I/O，recvfrom总是立即返回，两个阶段都由内核完成。</p>
<h2 id="4-io-多路复用io-multiplexing-"><a class="header" href="#4-io-多路复用io-multiplexing-">4. I/O 多路复用（I/O Multiplexing )</a></h2>
<p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄。</p>
<p>支持I/O多路复用的系统调用有 select/pselect/poll/epoll，本质都是同步I/O，因为数据拷贝都是阻塞的。
通过 select/epoll 来判断数据报是否准备好，即判断可读可写状态。</p>
<h2 id="5-epoll-同步阻塞非阻塞模型"><a class="header" href="#5-epoll-同步阻塞非阻塞模型">5. epoll: 同步阻塞/非阻塞模型</a></h2>
<pre><code class="language-text">                        +--------------------------------+     +-------------------------+
                        | epoll_ctl                      |     | epoll_wait              |
                        |                                |     |                         |
                        |                                |     |         +----+          |
                        |                 +---+          |     |         |    |          |
                        |                 |   |          |     |         |    |          |
                        |               +-+---+--+       |     |         +--+-+          |
                        |               |        |       |     |            |            |
                        |            +--++     +-++      |     |            |            |
epoll_create  +----&gt;    |            |   |     |  |      |     |         +--+-+          |
                        |            +-+-+     +--+      +----&gt;+         |    |          |
                        |              |                 |event|         |    |          |
                        |         +----+--+              |     |         +--+-+          |
                        |         |       |              |     |            |            |
                        |         ++      |              |     |            |            |
                        |        +--+   +-+-+            |     |         +--+-+          |
                        |        |  |   |   |            |     |         |    |          |
                        |        +--+   +---+            |     |         |    |          |
                        |                                |     |         +----+          |
                        |                    红 黑 树     |     |                 链 表    |
                        +--------------------------------+     +-------------------------+


</code></pre>
<h3 id="epoll三个函数"><a class="header" href="#epoll三个函数">epoll三个函数</a></h3>
<ul>
<li>epoll_create(int size) : 内核产生一个epoll实例数据结构，并返回一个epfd</li>
<li>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)：将被监听的描述符添加到红黑树或从红黑树中删除或者对监听事件进行修改。</li>
<li>epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout): 阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入events数组中</li>
</ul>
<h3 id="epoll-两种触发机制"><a class="header" href="#epoll-两种触发机制">epoll 两种触发机制：</a></h3>
<ul>
<li>水平触发机制（LT)。缓冲区只要有数据就触发读写。epoll 默认工作方式。select/poll只支持该方式。</li>
<li>边缘触发机制（ET)。缓冲区空或满的状态才触发读写。nginx 使用该方式，避免频繁读写。</li>
</ul>
<h3 id="惊群问题"><a class="header" href="#惊群问题">惊群问题：</a></h3>
<p>当多个进程/线程调用epoll_wait时会阻塞等待，当内核触发可读写事件，所有进程/线程都会进行响应，但是实际上只有一个进程/线程真实处理这些事件。
Liux 4.5 通过引入 EPOLLEXCLUSIVE 标识来保证一个事件发生时候只有一个线程会被唤醒，以避免多侦听下的惊群问题。</p>
<h2 id="6-异步-io-模型-io_uring"><a class="header" href="#6-异步-io-模型-io_uring">6. 异步 I/O 模型: io_uring</a></h2>
<p>Linux AIO 实现的并不理想，所以引入了新的异步I/O接口 io_uring。</p>
<pre><code class="language-text">+----+ Head  +---------+               +----------+ Head
|            |         |               |          |
|            |         |               |          |
|            +---------+               +----------+
|            |         |               |          |
|            |         |               |          |
|            +---------+               +----------+
|            |         |               |          |
|            |         |               |          |
|            +---------+               +----------+
|            |         |               |          |
|      Tail  +---------+               +----------+ Tail &lt;--+
|        +--------------------------------------------+     |
|        | Kernel                                     |     |
|        |                                            |     |
|        |        +-------+              +-------+    |     |
|        |        |       |              |       |    |     |
+---------------&gt; | SQ    |              |  CQ   | +--------+
         |        |       |              |       |    |
         |        +-------+              +-------+    |
         |                                            |
         +--------------------------------------------+

</code></pre>
<p>io_uring接口通过两个主要数据结构工作：</p>
<ul>
<li>提交队列条目（sqe）</li>
<li>完成队列条目（cqe）</li>
</ul>
<p>这些结构的实例位于内核和应用程序之间的<strong>共享内存</strong>单生产者单消费者环形缓冲区中。</p>
<p>参考：</p>
<p><a href="https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/">https://thenewstack.io/how-io_uring-and-ebpf-will-revolutionize-programming-in-linux/</a></p>
<p><a href="https://cor3ntin.github.io/posts/iouring/#io_uring">https://cor3ntin.github.io/posts/iouring/#io_uring</a></p>
<blockquote>
<p>因为处理 I/O 复用的编程模型相当复杂，为了简化编程，引入了下面两种模型:</p>
</blockquote>
<h3 id="1-reactor反应器-模式"><a class="header" href="#1-reactor反应器-模式">1. Reactor（反应器） 模式</a></h3>
<p>对应同步I/O，被动的事件分离和分发模型。服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。</p>
<h3 id="2-preactor主动器-模式"><a class="header" href="#2-preactor主动器-模式">2. Preactor（主动器） 模式</a></h3>
<p>对应异步I/O，主动的事件分离和分发模型。这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）。</p>
<h3 id="reactor-model"><a class="header" href="#reactor-model">Reactor Model:</a></h3>
<pre><code class="language-text">                                                     +----------------+
req                                        Dispatch  |                |
+------+                                  +--------&gt; | req handler    |
|      |                                  |          +----------------+
|      | +----+                           |
+------+      | event    +------------+   |
              |          |            |   |
              +--------&gt; |  Service   |   |Dispatch  +----------------+
                         |  Handler   +------------&gt; |                |
req          +---------&gt; |            |   |          | req handler    |
+------+     |           +------------+   |          +----------------+
|      |     | event                      |
|      +----+                             |
+------+                                  | Dispatch +----------------+
                                          +---------&gt;+                |
                                                     | req handler    |
                                                     +----------------+

</code></pre>
<h4 id="三种实现方式"><a class="header" href="#三种实现方式">三种实现方式：</a></h4>
<ul>
<li>单线程模式。 accept()、read()、write()以及connect()操作 都在同一线程。</li>
<li>工作者线程池模式。非 I/O 操作交给线程池处理</li>
<li>多线程模式。主Reactor (master) ，负责网络监听 ， 子Reactor(worker) 读写网络数据。</li>
</ul>
<h4 id="读写操作流程"><a class="header" href="#读写操作流程">读写操作流程：</a></h4>
<ol>
<li>应用注册读写就绪事件和相关联的事件处理器</li>
<li>事件分离器等待事件发生</li>
<li>当发生读写就绪事件，事件分离器调用已注册的事件处理器</li>
<li>事件处理器执行读写操作</li>
</ol>
<h4 id="参与者"><a class="header" href="#参与者">参与者：</a></h4>
<ol>
<li>描述符（handle）：操作系统提供的资源，识别 socket等。</li>
<li>同步事件多路分离器。开启事件循环，等待事件的发生。封装了 多路复用函数 select/poll/epoll等。</li>
<li>事件处理器。提供回调函数，用于描述与应用程序相关的某个事件的操作。</li>
<li>具体的事件处理器。事件处理器接口的具体实现。使用描述符来识别事件和程序提供的服务。</li>
<li>Reactor 管理器。事件处理器的调度核心。分离每个事件，调度事件管理器，调用具体的函数处理某个事件。</li>
</ol>
<h2 id="参考资源-8"><a class="header" href="#参考资源-8">参考资源</a></h2>
<ul>
<li><a href="https://time.geekbang.org/course/detail/100060601-365835">88. IO模型</a></li>
<li><a href="https://time.geekbang.org/course/detail/100060601-365838">89. epoll和io_uring</a></li>
<li><a href="https://time.geekbang.org/course/detail/100060601-367808">90. 事件驱动编程模型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:06 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:11 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:09 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:09 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:26:21 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><h1 id="学习资源"><a class="header" href="#学习资源">学习资源</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/1_learning_resource/learning_resource.html#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90">学习资源</a></li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:16 CST 2022 -->
<!--te--><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="官方动态"><a class="header" href="#官方动态">官方动态</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="社区特点"><a class="header" href="#社区特点">社区特点</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="学术动态"><a class="header" href="#学术动态">学术动态</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开源观察"><a class="header" href="#开源观察">开源观察</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="命令行工具"><a class="header" href="#命令行工具">命令行工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据处理"><a class="header" href="#数据处理">数据处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="嵌入式"><a class="header" href="#嵌入式">嵌入式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="操作系统"><a class="header" href="#操作系统">操作系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能工具"><a class="header" href="#性能工具">性能工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="云原生"><a class="header" href="#云原生">云原生</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前端开发"><a class="header" href="#前端开发">前端开发</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络基建"><a class="header" href="#网络基建">网络基建</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ipfs-星际文件系统interplanetary-file-system"><a class="header" href="#ipfs-星际文件系统interplanetary-file-system">IPFS: 星际文件系统(InterPlanetary File System)</a></h1>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/ipfs.jpeg" alt="ipfs" /></p>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs-%E6%98%9F%E9%99%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Finterplanetary-file-system">IPFS: 星际文件系统(InterPlanetary File System)</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E4%BB%8B%E7%BB%8D">IPFS介绍</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#1-%E4%BB%80%E4%B9%88%E6%98%AFipfs">1 什么是IPFS</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89ipfs">2 为什么有IPFS</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#http%E7%9A%84%E4%B8%AD%E5%BF%83%E5%8C%96%E6%98%AF%E4%BD%8E%E6%95%88%E7%9A%84-%E5%B9%B6%E4%B8%94%E6%88%90%E6%9C%AC%E5%BE%88%E9%AB%98">HTTP的中心化是低效的, 并且成本很高</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#web%E6%96%87%E4%BB%B6%E7%BB%8F%E5%B8%B8%E8%A2%AB%E5%88%A0%E9%99%A4">Web文件经常被删除</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#%E4%B8%AD%E5%BF%83%E5%8C%96%E9%99%90%E5%88%B6%E4%BA%86web%E7%9A%84%E6%88%90%E9%95%BF">中心化限制了web的成长</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E9%AB%98%E5%BA%A6%E4%BE%9D%E8%B5%96%E4%B8%BB%E5%B9%B2%E7%BD%91">互联网应用高度依赖主干网</a></li>
</ul>
</li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#3-ipfs%E7%9A%84%E7%9B%AE%E6%A0%87">3 IPFS的目标</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#4-ipfs%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9">4 IPFS包含哪些内容</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8D%8F%E8%AE%AE%E7%B1%BB%E4%BC%BChttp%E5%8D%8F%E8%AE%AE">IPFS是一个协议，类似http协议</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E6%98%AF%E4%B8%80%E4%B8%AAweb%E5%8D%8F%E8%AE%AE">IPFS是一个web协议</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8D%8F%E8%AE%AE">IPFS是模块化的协议</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E6%98%AF%E4%B8%80%E4%B8%AAp2p%E7%B3%BB%E7%BB%9F">IPFS是一个p2p系统</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E5%A4%A9%E7%94%9F%E6%98%AF%E4%B8%80%E4%B8%AAcdn">IPFS天生是一个CDN</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E6%8B%A5%E6%9C%89%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1">IPFS拥有命名服务</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C">IPFS如何工作</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%AD%E5%BF%83%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%BA%E7%82%B9">IPFS如何解决中心化服务器缺点</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#1-%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%BF%AB-%E4%B8%8D%E5%86%8D%E4%BE%9D%E8%B5%96%E4%B8%BB%E5%B9%B2%E7%BD%91-%E4%B8%AD%E5%BF%83%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8">1 下载速度快, 不再依赖主干网, 中心化服务器</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#2-%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%8F%98%E5%BE%97%E9%9D%9E%E5%B8%B8%E4%BE%BF%E5%AE%9C">2 存储空间变得非常便宜</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#3-%E5%AE%89%E5%85%A8">3 安全</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#4-%E5%BC%80%E6%94%BE">4 开放</a></li>
</ul>
</li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E7%9A%84%E7%94%A8%E9%80%94">IPFS的用途</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E7%9A%84pow%E6%9C%BA%E5%88%B6">IPFS的POW机制</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E5%AE%B6%E6%97%8F">IPFS家族</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#main-projects">Main Projects</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#contributions">Contributions</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#movements">Movements</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs-%E4%B8%8E-filecoin">IPFS 与 Filecoin</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E7%B1%BB%E4%BC%BChttp%E5%8D%8F%E8%AE%AE">IPFS：数据的分发和定位（数据传输协议，类似HTTP协议）</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#filecoin-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%B1%BB%E4%BC%BC%E4%B8%80%E4%B8%AA%E4%BA%91%E5%AD%98%E5%82%A8">Filecoin: 数据存储（类似一个云存储）</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E5%92%8Cfilecoin%E5%85%B1%E5%90%8C%E4%BE%9D%E8%B5%96libp2p%E9%A1%B9%E7%9B%AE">IPFS和Filecoin共同依赖libp2p项目。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#%E4%BD%BF%E7%94%A8ipfs%E7%9A%84%E5%BA%94%E7%94%A8">使用IPFS的应用</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E7%BD%91%E7%BB%9C%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C">IPFS网络如何运行</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs-nat-traversal">IPFS: NAT traversal</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#bitswap">BitSwap</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#ipfs%E9%9D%9Erust%E5%AE%9E%E7%8E%B0%E7%89%88%E6%9C%AC">IPFS非rust实现版本</a></li>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:21:26 CST 2022 -->
<!--te-->
<h2 id="ipfs介绍"><a class="header" href="#ipfs介绍">IPFS介绍</a></h2>
<h3 id="1-什么是ipfs"><a class="header" href="#1-什么是ipfs">1 什么是IPFS</a></h3>
<p>星际文件系统(InterPlanetary File System). IPFS 是一个分布式的web, 点到点超媒体协议. 可以让我们的互联网速度更快, 更加安全, 并且更加开放. IPFS协议的目标是取代传统的互联网协议HTTP。</p>
<h3 id="2-为什么有ipfs"><a class="header" href="#2-为什么有ipfs">2 为什么有IPFS</a></h3>
<p>众所周知, 互联网是建立在HTTP协议上的. HTTP协议是个伟大的发明, 让我们的互联网得以快速发展.但是互联网发展到了今天HTTP逐渐出来了不足.</p>
<h4 id="http的中心化是低效的-并且成本很高"><a class="header" href="#http的中心化是低效的-并且成本很高">HTTP的中心化是低效的, 并且成本很高</a></h4>
<p>使用HTTP协议每次需要从中心化的服务器下载完整的文件(网页, 视频, 图片等), 速度慢, 效率低. 如果改用P2P的方式下载, 可以节省近60%的带宽. P2P将文件分割为小的块, 从多个服务器同时下载, 速度非常快.</p>
<h4 id="web文件经常被删除"><a class="header" href="#web文件经常被删除">Web文件经常被删除</a></h4>
<p>回想一下是不是经常你收藏的某个页面, 在使用的时候浏览器返回404(无法找到页面), http的页面平均生存周期大约只有100天. Web文件经常被删除(由于存储成本太高), 无法永久保存. IPFS提供了文件的历史版本回溯功能(
就像git版本控制工具一样), 可以很容易的查看文件的历史版本, 数据可以得到永久保存</p>
<h4 id="中心化限制了web的成长"><a class="header" href="#中心化限制了web的成长">中心化限制了web的成长</a></h4>
<p>我们的现有互联网是一个高度中心化的网络. 互联网是人类的伟大发明, 也是科技创新的加速器. 各种管制将对这互联网的功能造成威胁, 例如: 互联网封锁, 管制, 监控等等.
这些都源于互联网的中心化.而分布式的IPFS可以克服这些web的缺点.</p>
<h4 id="互联网应用高度依赖主干网"><a class="header" href="#互联网应用高度依赖主干网">互联网应用高度依赖主干网</a></h4>
<p>主干网受制于诸多因素的影响, 战争, 自然灾害, 互联网管制, 中心化服务器宕机等等, 都可能是我们的互联网应用中断服务. IPFS可以是互联网应用极大的降低互联网应用对主干网的依赖.</p>
<h3 id="3-ipfs的目标"><a class="header" href="#3-ipfs的目标">3 IPFS的目标</a></h3>
<p>IPFS不仅仅是为了加速web. 而是为了最终取代HTTP协议, 使互联网更加美好</p>
<h3 id="4-ipfs包含哪些内容"><a class="header" href="#4-ipfs包含哪些内容">4 IPFS包含哪些内容</a></h3>
<h4 id="ipfs是一个协议类似http协议"><a class="header" href="#ipfs是一个协议类似http协议">IPFS是一个协议，类似http协议</a></h4>
<ul>
<li>定义了基于内容的寻址文件系统</li>
<li>内容分发</li>
<li>使用的技术分布式哈希、p2p传输、版本管理系统</li>
<li>IPFS是一个文件系统</li>
</ul>
<p>有文件夹和文件 可挂载文件系统</p>
<h4 id="ipfs是一个web协议"><a class="header" href="#ipfs是一个web协议">IPFS是一个web协议</a></h4>
<ul>
<li>可以像http那样查看互联网页面</li>
<li>未来浏览器可以直接支持 ipfs:/ 或者 fs:/ 协议</li>
</ul>
<h4 id="ipfs是模块化的协议"><a class="header" href="#ipfs是模块化的协议">IPFS是模块化的协议</a></h4>
<ul>
<li>连接层：通过其他任何网络协议连接</li>
<li>路由层：寻找定位文件所在位置</li>
<li>数据块交换：采用BitTorrent技术</li>
</ul>
<h4 id="ipfs是一个p2p系统"><a class="header" href="#ipfs是一个p2p系统">IPFS是一个p2p系统</a></h4>
<ul>
<li>世界范围内的p2p文件传输网络</li>
<li>分布式网络结构</li>
<li>没有单点失效问题</li>
</ul>
<h4 id="ipfs天生是一个cdn"><a class="header" href="#ipfs天生是一个cdn">IPFS天生是一个CDN</a></h4>
<ul>
<li>文件添加到IPFS网络，将会在全世界进行CDN加速</li>
<li>bittorrent的带宽管理</li>
</ul>
<h4 id="ipfs拥有命名服务"><a class="header" href="#ipfs拥有命名服务">IPFS拥有命名服务</a></h4>
<ul>
<li>IPNS：基于SFS（自认证系统）命名体系</li>
<li>可以和现有域名系统绑定</li>
</ul>
<h2 id="ipfs如何工作"><a class="header" href="#ipfs如何工作">IPFS如何工作</a></h2>
<ol>
<li>IPFS为每一个文件分配一个独一无二的哈希值(文件指纹: 根据文件的内容进行创建), 即使是两个文件内容只有1个比特的不相同, 其哈希值也是不相同的.所以IPFS是基于文件内容进行寻址, 而不像传统的HTTP协议一样基于域名寻址.</li>
<li>IPFS在整个网络范围内去掉重复的文件, 并且为文件建立版本管理, 也就是说每一个文件的变更历史都将被记录(这一点类似版本控制工具git, svn等), 可以很容易个回到文件的历史版本查看数据.</li>
<li>当查询文件的时候, IPFS网络根据文件的哈希值(全网唯一)进行查找. 由于每个文件的哈希值全网唯一, 查询将很容易进行.</li>
<li>如果仅仅使用哈希值来区分文件的话, 会给传播造成困难, 因为哈希值不容易记忆, 就像ip地址一样不容易记忆, 于是人类发明的域名. IPFS利用IPNS将哈希值映射为容易记的名字</li>
<li>每个节点除了存储自己需要的数据, 还存储了一张哈希表, 用来记录文件存储所在的位置. 用来进行文件的查询下载.</li>
</ol>
<h2 id="ipfs如何解决中心化服务器缺点"><a class="header" href="#ipfs如何解决中心化服务器缺点">IPFS如何解决中心化服务器缺点</a></h2>
<h3 id="1-下载速度快-不再依赖主干网-中心化服务器"><a class="header" href="#1-下载速度快-不再依赖主干网-中心化服务器">1 下载速度快, 不再依赖主干网, 中心化服务器</a></h3>
<p>整个IPFS系统是一个分布式的文件存储系统, 那么在下载相关数据的时候, 将从多个节点同时下载, 相比于HTTP从中心服务器的下载速度要快很多, 大家都用过P2P下载(比如: 迅雷, BitTorrent), IPFS下载过程跟这个类似.</p>
<h3 id="2-存储空间变得非常便宜"><a class="header" href="#2-存储空间变得非常便宜">2 存储空间变得非常便宜</a></h3>
<p>由于IPFS使用的是区块链技术, 利用 Filecoin(为了的文章中会将如何获取filecoin, 也就是挖矿)来激励矿工分享自己的硬盘, 并且IFPS从全网去掉了冗余存储(从整个网络空间考虑, 这将大大节省网络存储空间),
将来的IPFS存储将会变得非常便宜(与我们现在的云盘, 各种中心化的CND相比较).</p>
<h3 id="3-安全"><a class="header" href="#3-安全">3 安全</a></h3>
<p>中心化服务器目前很难抵挡DDoS攻击, 当大量的访问请求从四面八方涌来, 中心化的服务器几乎会在一瞬间瘫痪, 做过运维的同学应该深有感触, 比如每年双11, 不能睡觉的除了阿里, 腾讯的技术同学, 还有整个银行业的小朋友.
巨大的访问量随时可能造成服务器宕机. IPFS天生就拥有抵挡这种攻击的能力. 因为所有的访问将会被分散到不同的节点. 甚至攻击者自己也是节点之一. 某种程度上讲, IPFS甚至能抵挡量子计算的攻击.</p>
<h3 id="4-开放"><a class="header" href="#4-开放">4 开放</a></h3>
<p>众所周知, 比特币是一种去中心化, 匿名的数据货币, 这些特性使得比特币无法被管制, 交易无法篡改. IPFS同样, 由于是建立在去中心化的分布式网络上的, 所以IFPS很难被中心化管理, 限制. 互联网将更加开放.</p>
<h2 id="ipfs的用途"><a class="header" href="#ipfs的用途">IPFS的用途</a></h2>
<blockquote>
<p>IPFS主要解决现有中心化服务器中的数据存储问题。它能够极大的降低数据存储的成本,提升数据下载速度。</p>
</blockquote>
<blockquote>
<p>那么凡是需要优化数据存储的地方几乎都可以使用IPFS来提升效率</p>
</blockquote>
<blockquote>
<p>下面是一张保存在ipfs网络的图片：</p>
</blockquote>
<p><img src="https://ipfs.io/ipfs/QmdDTor6dWzknFJPJuhJgrUYqd56WkFXYAxyxpEY7kUrEb" alt="" /></p>
<ul>
<li>在 /ipfs 和 /ipns 下面挂载全球文件系统：就是说我们所有的文件都可以存到上面.</li>
<li>挂载个人同步的文件夹, 可以自动进行版本管理, 自动备份. 也就意味着未来我们将拥有无限空间的网盘, 不用担心数据丢失, 不用担心隐私泄露(非对称加密). 是不是想到了什么? 现在比较流行的某度 (曾经把大家自动备份的照片全部共享了,
各种艳照啊)和企鹅网盘, 国外的dropbox, 跟IPFS云盘相比, 都将变得微不足道 。</li>
<li>作为加密文件和数据共享系统。IPFS天生视乎就具备这样的能力, 文件加密, 数据共享, 都是小菜一碟.</li>
<li>作为带版本控制的软件包管理系统.</li>
<li>作为虚拟机的根文件系统</li>
<li>作为利用管理程序, 把IPFS作为虚拟机的引导文件系统：在线操作系统</li>
<li>作为数据库：应用可以直接操作IPFS的Merkle DAG数据结构, 并且可以使用IPFS的版本控制, 缓存. 试想一下我们的数据库直接存在IPFS的文件系统是什么体验? 自动备份, 永不丢失, 安全加密, 无限空间, 高速连接,
想想就美好. 科技改变生活, 未来会有多美好....</li>
<li>作为加密通讯平台，谁都别想窃听消息通信了</li>
<li>作为加密CDN, 作为web的CDN, CDN功能全包了.</li>
<li>永久web, 不存在不能访问的链接, 跟 404 说 byebye.</li>
</ul>
<h2 id="ipfs的pow机制"><a class="header" href="#ipfs的pow机制">IPFS的POW机制</a></h2>
<h2 id="ipfs家族"><a class="header" href="#ipfs家族">IPFS家族</a></h2>
<blockquote>
<p><a href="https://protocol.ai/work/">Work | Protocol Labs</a></p>
</blockquote>
<h3 id="main-projects"><a class="header" href="#main-projects">Main Projects</a></h3>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20220618215731222.png" alt="image-20220618215731222" /></p>
<h3 id="contributions"><a class="header" href="#contributions">Contributions</a></h3>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20220618220109640.png" alt="image-20220618220109640" /></p>
<h3 id="movements"><a class="header" href="#movements">Movements</a></h3>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20220618220532130.png" alt="image-20220618220532130" /></p>
<h3 id="ipfs-与-filecoin"><a class="header" href="#ipfs-与-filecoin">IPFS 与 Filecoin</a></h3>
<h4 id="ipfs数据的分发和定位数据传输协议类似http协议"><a class="header" href="#ipfs数据的分发和定位数据传输协议类似http协议">IPFS：数据的分发和定位（数据传输协议，类似HTTP协议）</a></h4>
<ul>
<li>传输：数据在节点之间进行传输</li>
<li>定位：寻址，发现数据的存储位置</li>
<li>存储：自己提供存储（可以保证存储的安全性），其它节点不保证数据存储的安全性</li>
<li>用户：下载数据免费，自己提供服务器，自己搭建节点</li>
<li>存储内容：只存储节点自己感兴趣的内容</li>
</ul>
<h4 id="filecoin-数据存储类似一个云存储"><a class="header" href="#filecoin-数据存储类似一个云存储">Filecoin: 数据存储（类似一个云存储）</a></h4>
<ul>
<li>存储：付费存储，用户付费，矿工和Filecoin网络保证存储的安全性</li>
<li>下载：付费下载，用户付费，矿工负责发送数据</li>
<li>用户：不需要自己提供存储，也不需要自己提供节点</li>
<li>存储内容：收费存储一切</li>
</ul>
<h4 id="ipfs和filecoin共同依赖libp2p项目"><a class="header" href="#ipfs和filecoin共同依赖libp2p项目">IPFS和Filecoin共同依赖libp2p项目。</a></h4>
<blockquote>
<p>Filecoin是IPFS的激励层，二者互补形式一对协议。为我们的互联网提供了很好的基础设施。</p>
</blockquote>
<p>了解上述的基本内容后：</p>
<ul>
<li>如果开发者仅仅想要的是一个安全、快速的云存储，那么选择Filecoin即可。</li>
<li>如果开发者除了数据存储需求，还需要分发数据，那么选择IPFS即可。</li>
<li>如果开发者既有数据存储需求，又有数据的分发需求，那么可以单独选择IPFS，也可以IPFS+Filecoin一起。</li>
</ul>
<blockquote>
<p>注意：IPFS可以做Filecoin的事情，存储，而filecoin并不能做IPFS的事情，数据传输</p>
</blockquote>
<h2 id="使用ipfs的应用"><a class="header" href="#使用ipfs的应用">使用IPFS的应用</a></h2>
<ul>
<li><del><a href="https://github.com/AKASHAorg/Community/releases">akasha</a>： 基于以太坊和IPFS的社交网络</del></li>
<li><del>Alexandria：去中心化的内容发布平台</del></li>
<li><a href="https://github.com/MichaelMure/Arbore">Arbore</a>：朋友之间的文件共享系统--相信很快就可以抛弃某度的云盘了</li>
<li><a href="https://github.com/dtube/dtube">dtube</a>：利用IPFS作为存储的视频分享网站</li>
<li><a href="https://github.com/whyrusleeping/git-ipfs-rehost">git-ipfs-rehost</a>：可以把github上的项目存储到IPFS上</li>
<li><a href="https://github.com/ipfs-search/ipfs-search">ipfs-search</a>：基于IFPS的搜索引擎</li>
<li><a href="https://github.com/ipfs-shipyard/ipfs-share-files">ipfs-share</a>：基于IFPS的文件分享</li>
<li><a href="http://ipfs.pics/">ipfs.pics</a>：基于IFPS的图片分享网站</li>
<li><a href="https://github.com/orbitdb/orbit">Orbit</a>：基于IFPS的分布式聊天工具</li>
<li><a href="https://github.com/BusterLabs/Partyshare">Partyshare</a>：一个简单的文件共享系统</li>
<li>http://computes.io：基于IPFS的分布式计算机（这个牛，把世界上的计算资源收集起来，构建一个巨大的分布式计算机）</li>
<li><a href="https://github.com/OpenBazaar?type=source">OpenBazaar</a>：openbazaar是一个去中心化的淘宝，口号是“买卖自由/Buy and Sell
Freely”，问题是一旦用户停止运行软件，商店就下线了，借助于IPFS，openbazaar2.0 打造一个离线商店。</li>
<li>Ubuntu：著名的linux发行版本Ubuntu正在计算把发行版本转移到IPFS上来，目前正在讨论方案。</li>
</ul>
<blockquote>
<p>更多可在这里查看：
<a href="https://ipfs.io/ipfs/QmUQs8yuYbQ7VbMpRoL6RFz4dMuK4RqCCmPmJc5fK7P4Yc/">Awesome IPFS</a></p>
</blockquote>
<blockquote>
<p>一些过期项目：
<a href="https://github.com/ipfs-inactive?type=source">IPFS Inactive repositories</a></p>
</blockquote>
<h2 id="ipfs网络如何运行"><a class="header" href="#ipfs网络如何运行">IPFS网络如何运行</a></h2>
<h2 id="ipfs-nat-traversal"><a class="header" href="#ipfs-nat-traversal">IPFS: NAT traversal</a></h2>
<h2 id="bitswap"><a class="header" href="#bitswap">BitSwap</a></h2>
<h2 id="ipfs非rust实现版本"><a class="header" href="#ipfs非rust实现版本">IPFS非rust实现版本</a></h2>
<h2 id="参考资源-9"><a class="header" href="#参考资源-9">参考资源</a></h2>
<ul>
<li><a href="https://www.zhihu.com/column/ipfsguide">IPFS指南 - 知乎</a></li>
<li><a href="https://github.com/rs-ipfs/rust-ipfs">rs-ipfs/rust-ipfs: The InterPlanetary File System (IPFS), implemented in Rust.</a></li>
<li><a href="https://opencollective.com/rs-ipfs">Rust IPFS - Open Collective</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33170031">IPFS网络是如何运行的(p2p网络) - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33057094">IPFS: NAT traversal(NAT穿越) - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33148036">IPFS: BitSwap协议(数据块交换) - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34158682">IPFS非rust实现版本</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="利用ipfs构建自己的去中心化分布式网站"><a class="header" href="#利用ipfs构建自己的去中心化分布式网站">利用IPFS构建自己的去中心化分布式网站</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_website.html#%E5%88%A9%E7%94%A8ipfs%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99">利用IPFS构建自己的去中心化分布式网站</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_website.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:26:00 CST 2022 -->
<!--te-->
<h2 id="参考资源-10"><a class="header" href="#参考资源-10">参考资源</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/32869413">如何基于IPFS建一个静态网站 - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32682117">如何在IPFS里面上传一张图片 - 知乎</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ipfspubsub功能使用"><a class="header" href="#ipfspubsub功能使用">IPFS：pubsub功能使用</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_pubsub.html#ipfspubsub%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8">IPFS：pubsub功能使用</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_pubsub.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:25:59 CST 2022 -->
<!--te-->
<h2 id="参考资源-11"><a class="header" href="#参考资源-11">参考资源</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/36502849">IPFS: pubsub功能的使用 - 知乎</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ipfs伴侣插件使用"><a class="header" href="#ipfs伴侣插件使用">IPFS伴侣插件使用</a></h1>
<!--ts-->
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:25:57 CST 2022 -->
<!--te-->
<h2 id="参考资源-12"><a class="header" href="#参考资源-12">参考资源</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/35566466">【应用】IPFS伴侣浏览器插件V2.2.0版本升级的重大意义 - 知乎</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基于ipfs与ngrok构建网关"><a class="header" href="#基于ipfs与ngrok构建网关">基于IPFS与Ngrok构建网关</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_ngrok.html#%E5%9F%BA%E4%BA%8Eipfs%E4%B8%8Engrok%E6%9E%84%E5%BB%BA%E7%BD%91%E5%85%B3">基于IPFS与Ngrok构建网关</a>
<ul>
<li><a href="layer5_ecosystem/5_open_source/2_network/network/ipfs/ipfs_ngrok.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:25:58 CST 2022 -->
<!--te-->
<h2 id="参考资源-13"><a class="header" href="#参考资源-13">参考资源</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/35151037">【应用】（入门）基于IPFS和Ngrok构建自维护资源网关 - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35951053">【应用】（进阶）基于IPFS和Ngrok构建自维护资源网关 - 知乎</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络开发"><a class="header" href="#网络开发">网络开发</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="音视频处理"><a class="header" href="#音视频处理">音视频处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="游戏与图像处理"><a class="header" href="#游戏与图像处理">游戏与图像处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="rust与其他编程语言"><a class="header" href="#rust与其他编程语言">Rust与其他编程语言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="科学艺术研究"><a class="header" href="#科学艺术研究">科学艺术研究</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他工具"><a class="header" href="#其他工具">其他工具</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全参考"><a class="header" href="#安全参考">安全参考</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="商业观察"><a class="header" href="#商业观察">商业观察</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区块链"><a class="header" href="#区块链">区块链</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>
<ul>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#blockchains">Blockchains</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#blockchain-frameworks">Blockchain Frameworks</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#cross-chain">Cross-Chain</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#virtual-machines">Virtual Machines</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#general-purpose-consensus">General-Purpose Consensus</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#p2p-network-libraries">P2P Network Libraries</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#cryptography">Cryptography</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#layer2">Layer2</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#dapps">Dapps</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#other">Other</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/blockchain.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:26:14 CST 2022 -->
<!--te-->
<h2 id="blockchains"><a class="header" href="#blockchains">Blockchains</a></h2>
<ul>
<li><a href="https://developer.aleo.org/aleo/getting_started/overview">Aleo</a>. Leo is a rust flavoured zk language.</li>
<li><a href="https://alephzero.org/">Aleph Zero</a>. DAG, PoS, snark smart contracts (substrate based).</li>
<li><a href="https://anoma.network/">Anoma.network</a>. PoS blockchain with privacy.</li>
<li><a href="https://github.com/be-cash/bitcoin-cash">Bitcoin Cash</a>. A library for creating and parsing Bitcoin Cash trasactions.</li>
<li><a href="https://github.com/cryptape/cita">CITA</a>. A high performance blockchain kernel for enterprise users.</li>
<li><a href="https://github.com/CodeChain-io/codechain">CodeChain</a>. Programmable multi-asset chain.</li>
<li><a href="https://concordium.com/">Concordium</a>. Privacy centric (zk) PoS chain, yet with built in identities and rust smart
contracts.</li>
<li><a href="https://github.com/Conflux-Chain/conflux-rust">Conflux</a>. The Rust implementation of Conflux protocol.</li>
<li><a href="https://github.com/darwinia-network/darwinia">Darwinia</a>. Relay chain of Darwinia Network, can connect to Polkadot as
parachain in Polkadot Model.</li>
<li><a href="https://dusk.network/">Dusk.network</a>. Privacy PoS using zk (plonk).</li>
<li><a href="https://github.com/enigmampc/enigma-core">Enigma</a> secures the decentralized web.</li>
<li><a href="https://elrond.com/">Elrond</a>. Elrond (EGOLD( - scalable and usable blockchain, written is Rust and has smart
contracts in Rust.</li>
<li><a href="https://github.com/exonum/exonum">Exonum</a>. An extensible open-source framework for creating private/permissioned
blockchain applications.</li>
<li><a href="https://github.com/ChainSafe/forest">Forest</a>. An implementation of Filecoin written in Rust.</li>
<li><a href="https://github.com/FuelLabs/fuel-core">Fuel</a>. Rust full node implementation of the Fuel v2 protocol.</li>
<li><a href="https://github.com/gear-tech/gear">Gear</a>. Computational component of Polkadot network.</li>
<li><a href="https://github.com/mimblewimble/grin">Grin</a>. Minimal implementation of the MimbleWimble protocol.</li>
<li><a href="https://github.com/holochain/holochain">Holochain</a>. The core Holochain framework written in rust, a container, and
hdk-rust library for writing Zomes.</li>
<li><a href="https://github.com/HuobiGroup/huobi-chain">Huobi Chain</a>. The next generation high performance public chain for
financial infrastructure.</li>
<li><a href="https://github.com/interledger-rs/interledger-rs">Interledger</a>. An easy-to-use, high-performance Interledger
implementation written in Rust.</li>
<li><a href="https://github.com/Internet-of-People/iop-rs">Internet of People</a>. Decentralized software stack that provides the
building blocks and tools to support a decentralized society.</li>
<li><a href="https://github.com/libra/libra">Libra</a>. Global currency and financial infrastructure that empowers billions of
people.</li>
<li><a href="https://github.com/sigp/lighthouse">Lighthouse</a>. Fast and secure Ethereum 2.0 client.</li>
<li><a href="https://github.com/nearprotocol/nearcore">NEAR</a>. NEAR Protocol - scalable and usable blockchain.</li>
<li><a href="https://github.com/nervosnetwork/ckb">Nervos CKB</a>. Nervos CKB is a public permissionless blockchain, the common
knowledge layer of Nervos network.</li>
<li><a href="https://github.com/nymtech/nym">NYM</a>. Selective privacy via a mixnet preventing metadata analysis.</li>
<li><a href="https://github.com/nomic-io/nomic">Nomic</a>. Nomic is a high-performance Bitcoin sidechain which is part of the Cosmos
network.</li>
<li><a href="https://github.com/ChainSafe/mina-rs">Mina Protocol</a>. A rust implementation of the mina succinct blockchain.</li>
<li><a href="https://mirprotocol.org/">Mir Protocol</a>. A succinct blockchain powered by zero-knowledge proofs. (plonk based)</li>
<li><a href="https://github.com/openethereum/openethereum">OpenEthereum</a>. The Ethereum Rust client</li>
<li><a href="https://github.com/paritytech/parity-bitcoin">Parity Bitcoin</a>. The Parity Bitcoin client.</li>
<li><a href="https://github.com/paritytech/parity-ethereum">Parity Ethereum</a>. The fast, light, and robust EVM and WASM client.</li>
<li><a href="https://github.com/paritytech/parity-zcash">Parity Zcash</a>. Rust implementation of Zcash protocol.</li>
<li><a href="https://github.com/paritytech/polkadot">Polkadot</a>. Polkadot Node Implementation.</li>
<li><a href="https://github.com/PolymathNetwork/Polymesh">Polymesh</a>. The Polymesh blockchain (built on Substrate) is an identity
orientated chain for the issuance, lifecycle management and settlement of regulated securities.</li>
<li><a href="https://github.com/QANplatform/its_alive">QAN</a>. Post-quantum blockchain.</li>
<li><a href="https://github.com/radixdlt/radixdlt-scrypto">Radix</a>. Sharded smart contract DeFi platform.</li>
<li><a href="https://github.com/Setheum-Labs/Setheum">Setheum</a>. SETHEUM : “Secure Evergreen Truthful Heterogeneous Economically
Unbiased Market” is an Ethical DeFi-friendly Blockchain (built on Substrate) working on achieving mass adoption,
security, scalability, affordability, inclusivity and ethical DeFi Governance.</li>
<li><a href="https://github.com/paritytech/shasper">Shasper</a>. Parity Shasper beacon chain implementation using the Substrate
framework.</li>
<li><a href="https://github.com/solana-labs/solana">Solana</a>. Blockchain Rebuilt for Scale.</li>
<li><a href="https://github.com/blockstack/stacks-blockchain">Stacks 2.0</a>. Proof of Transfer blockchain from Blockstack.</li>
<li><a href="https://github.com/tari-project">Tari</a>. The Tari Digital Assets Protocol.</li>
<li><a href="https://github.com/informalsystems/tendermint-rs">Tendermint</a>. Tendermint is a high-performance blockchain consensus
engine for Byzantine fault tolerant applications.</li>
<li><a href="https://github.com/witnet/witnet-rust">Witnet</a>. Open source implementation of Witnet decentralized oracle network
protocol in Rust.</li>
<li><a href="https://github.com/xx-labs/xxchain">xx-network</a>. Post-quantum blockchain, mixnet privacy preventing metadata
analysis. (Substrate rust+go)</li>
<li><a href="https://github.com/ZcashFoundation/zebra">Zebra</a>. An ongoing Rust implementation of a Zcash node.</li>
<li><a href="https://github.com/LayerXcom/zero-chain">Zero-chain</a>. A privacy-preserving blockchain on Substrate.</li>
</ul>
<h2 id="blockchain-frameworks"><a class="header" href="#blockchain-frameworks">Blockchain Frameworks</a></h2>
<ul>
<li><a href="https://github.com/paritytech/substrate">Substrate</a>. The platform for blockchain innovators.</li>
<li><a href="https://github.com/stellar/slingshot">slingshot</a>. A new blockchain architecture under active development, with a
strong focus on scalability, privacy and safety.</li>
<li><a href="https://github.com/tendermint/rust-abci">Tendermint ABCI</a>. Tendermint ABCI server, written in the Rust programming
language.</li>
<li><a href="https://github.com/nomic-io/orga">Orga</a>. A high-performance state machine engine designed for Tendermint-based
blockchain applications.</li>
</ul>
<h2 id="cross-chain"><a class="header" href="#cross-chain">Cross-Chain</a></h2>
<ul>
<li><a href="https://comit.network/">Comit</a> is an open protocol facilitating trustless cross-blockchain applications.</li>
<li><a href="https://github.com/informalsystems/ibc-rs">IBC</a>. Rust implementation of Cosmos' Interblockchain Communication
Protocol
(IBC).</li>
</ul>
<h2 id="virtual-machines"><a class="header" href="#virtual-machines">Virtual Machines</a></h2>
<ul>
<li><a href="https://github.com/nervosnetwork/ckb-vm">CKB-VM</a>. RISC-V virtual machine.</li>
<li><a href="https://www.cosmwasm.com">CosmWasm</a>. Multi-chain smart contract platform built for the Cosmos ecosystem.</li>
<li><a href="https://github.com/paritytech/parity-ethereum/tree/master/evmbin">EVM Parity</a>. Parity implementation of EVM.</li>
<li><a href="https://github.com/FuelLabs/fuel-vm">FuelVM</a>
FuelVM interpreter in Rust.</li>
<li><a href="https://github.com/lunatic-solutions/lunatic">Lunatic</a>. Erlang-inspired runtime for WebAssembly.</li>
<li><a href="https://github.com/maticnetwork/miden">Polygon Miden</a>. SNARK based VM.</li>
<li><a href="https://github.com/spacemeshos/svm">SVM</a>
Spacemesh Virtual Machine.</li>
<li><a href="https://github.com/paritytech/wasmi">Wasmi</a>. WebAssembly interpreter.</li>
<li><a href="https://wasmer.io/">Wasmer</a>. A convenient Rust wrapper over WebAssembly backends.</li>
<li><a href="https://github.com/CraneStation/wasmtime">Wasmtime</a>. Standalone JIT-style runtime for WebAssembly, using Cranelift.</li>
<li><a href="https://github.com/matter-labs/zinc">Zinc</a>. Zinc zk smart contract language.</li>
</ul>
<h2 id="general-purpose-consensus"><a class="header" href="#general-purpose-consensus">General-Purpose Consensus</a></h2>
<ul>
<li><a href="https://github.com/pingcap/raft-rs">Raft</a>. Raft distributed consensus algorithm implemented in Rust.</li>
<li><a href="https://github.com/poanetwork/hbbft">Honey Badger</a>. An implementation of the paper &quot;Honey Badger of BFT Protocols&quot; in
Rust.</li>
<li><a href="https://github.com/MystenLabs/narwhal">Narwhal</a>. The consensus layer used by Sui.</li>
</ul>
<h2 id="p2p-network-libraries"><a class="header" href="#p2p-network-libraries">P2P Network Libraries</a></h2>
<ul>
<li><a href="https://github.com/placefortea/chamomile">chamomile</a>. P2P library. Support build robust stable connection on
p2p/distributed network.</li>
<li><a href="https://github.com/maidsafe/crust">crust</a>. Reliable P2P network connections in Rust with NAT traversal. One of the
most needed libraries for any server-less / decentralised projects.</li>
<li><a href="https://github.com/libp2p/rust-libp2p">rust-libp2p</a>. The Rust Implementation of the libp2p networking stack.</li>
<li><a href="https://github.com/driftluo/tentacle">Tentacle</a>. A multiplexed p2p network framework that supports custom protocols</li>
<li><a href="https://github.com/ustulation/p2p">P2P NAT-Traversal</a>. NAT Traversal techniques for p2p communication.</li>
<li><a href="https://github.com/maidsafe/qp2p">qp2p</a>. Peer-to-peer communications library for Rust based on QUIC protocol.</li>
<li><a href="https://github.com/maidsafe/sn_routing">sn_routing</a>. Routing - specialised storage DHT.</li>
</ul>
<h2 id="cryptography"><a class="header" href="#cryptography">Cryptography</a></h2>
<ul>
<li><a href="https://github.com/rust-cc/awesome-cryptography-rust">Awesome Cryptography Rust</a>.</li>
<li><a href="https://github.com/dalek-cryptography">Dalek Cryptography</a>.</li>
<li><a href="https://github.com/adria0/za">Za!</a>. An experimental rust zksnarks compiler with embeeded bellman-bn128 prover.</li>
<li><a href="https://github.com/0xProject/OpenZKP">OpenZKP</a>. Pure Rust implementations of Zero-Knowledge Proof systems.</li>
<li><a href="https://github.com/microsoft/Nova">Microsoft Nova</a>. Rust recursive snark without trusted setup.</li>
<li><a href="https://github.com/arkworks-rs">Arkworks</a>. An ecosystem for developing and programming with zkSNARKs</li>
</ul>
<h2 id="layer2"><a class="header" href="#layer2">Layer2</a></h2>
<ul>
<li><a href="https://github.com/OffchainLabs/arb-os">Arbitrum's arb-os</a>
ArbOS is the &quot;operating system&quot; that runs an eth Layer 2 on an Arbitrum chain,</li>
<li><a href="https://github.com/noir-lang/noir">Noir language</a>. Noir is a Domain Specific Language for SNARK proving systems. (
Aztec eth L2)</li>
<li><a href="https://penumbra.zone/">Penumbra</a>. PoS network providing privacy to the Cosmos ecosystem.</li>
<li><a href="https://github.com/rust-bitcoin/rust-lightning">Rust-Lightning</a>
is a Bitcoin Lightning library written in Rust. The main crate, lightning, does not handle networking, persistence, or
any other I/O. Thus, it is runtime-agnostic, but users must implement basic networking logic, chain interactions, and
disk storage.</li>
<li><a href="https://github.com/matter-labs/zksync">zkSync</a>. Matter Labs' scaling eth L2 engine secured by zero-knowledge proofs.</li>
</ul>
<h2 id="dapps"><a class="header" href="#dapps">Dapps</a></h2>
<ul>
<li><a href="https://github.com/project-serum/serum-dex">Serum-dex</a>. A decentralized exchange built on Solana.</li>
<li><a href="https://github.com/second-state/SewUp">SewUp</a>. A library to help you build your Ethereum webassembly contract with
Rust and just like develop in a common backend.</li>
</ul>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<ul>
<li><a href="https://github.com/iqlusioninc/abscissa">abscissa</a>. Micro-framework for CLI tools with strong focus on security.</li>
<li><a href="https://github.com/adria0/tesseracts">tesseracts</a>. A small block explorer for geth PoAs written in rust.</li>
<li><a href="https://github.com/nomic-io/merk">merk</a>. High performance Merkle key/value store written in Rust, based on RocksDB.</li>
</ul>
<h2 id="参考资源-14"><a class="header" href="#参考资源-14">参考资源</a></h2>
<ul>
<li><a href="https://github.com/rust-in-blockchain/awesome-blockchain-rust">rust-in-blockchain/awesome-blockchain-rust: Collect libraries and packages about blockchain/cryptography in Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate介绍与源码解读"><a class="header" href="#substrate介绍与源码解读">Substrate介绍与源码解读</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/7_business/blockchain/substrate_intro.html#substrate%E4%BB%8B%E7%BB%8D%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB">Substrate介绍与源码解读</a>
<ul>
<li><a href="layer5_ecosystem/7_business/blockchain/substrate_intro.html#gavin-wookpolkadot-and-substrate">Gavin Wook、Polkadot and Substrate</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/substrate_intro.html#%E9%A1%B9%E7%9B%AE%E6%A8%A1%E5%9D%97">项目模块</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/substrate_intro.html#%E5%8A%9F%E8%83%BD%E9%80%BB%E8%BE%91">功能逻辑</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/substrate_intro.html#%E7%89%B9%E8%89%B2%E4%BB%A3%E7%A0%81">特色代码</a></li>
<li><a href="layer5_ecosystem/7_business/blockchain/substrate_intro.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:26:16 CST 2022 -->
<!--te-->
<h2 id="gavin-wookpolkadot-and-substrate"><a class="header" href="#gavin-wookpolkadot-and-substrate">Gavin Wook、Polkadot and Substrate</a></h2>
<h2 id="项目模块"><a class="header" href="#项目模块">项目模块</a></h2>
<h2 id="功能逻辑"><a class="header" href="#功能逻辑">功能逻辑</a></h2>
<h2 id="特色代码"><a class="header" href="#特色代码">特色代码</a></h2>
<h2 id="参考资源-15"><a class="header" href="#参考资源-15">参考资源</a></h2>
<ul>
<li><a href="https://github.com/paritytech/substrate">paritytech/substrate: Substrate: The platform for blockchain innovators</a></li>
<li><a href="https://www.zhihu.com/column/c_74315572">链块与分散的数据 - 知乎</a></li>
<li><a href="https://web.archive.org/web/20220618042220/https://zhuanlan.zhihu.com/p/47805322">substrate 源码解析与运用 - 介绍 - 知乎</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nervosckb"><a class="header" href="#nervosckb">nervos/ckb</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/7_business/blockchain/nervos_ckb_anatomy.html#nervosckb">nervos/ckb</a>
<ul>
<li><a href="layer5_ecosystem/7_business/blockchain/nervos_ckb_anatomy.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:26:15 CST 2022 -->
<!--te-->
<h2 id="参考资源-16"><a class="header" href="#参考资源-16">参考资源</a></h2>
<ul>
<li><a href="https://github.com/nervosnetwork/ckb">nervosnetwork/ckb: The Nervos CKB is a public permissionless blockchain, and the layer 1 of Nervos network.</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="solana"><a class="header" href="#solana">Solana</a></h1>
<!--ts-->
<ul>
<li><a href="layer5_ecosystem/7_business/blockchain/solana.html#solana">Solana</a>
<ul>
<li><a href="layer5_ecosystem/7_business/blockchain/solana.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: kuanhsiaokuo, at: Sat Jun 18 22:26:15 CST 2022 -->
<!--te-->
<h2 id="参考资源-17"><a class="header" href="#参考资源-17">参考资源</a></h2>
<ul>
<li><a href="https://github.com/solana-labs/solana">solana-labs/solana: Web-Scale Blockchain for fast, secure, scalable, decentralized apps and marketplaces.</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生产实践"><a class="header" href="#生产实践">生产实践</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优秀产品"><a class="header" href="#优秀产品">优秀产品</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基础库"><a class="header" href="#基础库">基础库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="框架引擎"><a class="header" href="#框架引擎">框架引擎</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="checklist"><a class="header" href="#checklist">Checklist</a></h1>

            </main>

            <script src="https://utteranc.es/client.js"
                    repo="RustMagazine/rust_magazine_2022"
                    issue-term="title"
                    theme="github-light"
                    crossorigin="anonymous"
                    async></script>

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
    </nav>

</div>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
<script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="mermaid.min.js"></script>
    <script type="text/javascript" src="mermaid-init.js"></script>
    <script type="text/javascript" src="smart-anchor.js"></script>
    <script type="text/javascript" src="sidebar.js"></script>
        <script type="text/javascript">
            window.addEventListener('load', function () {
                MathJax.Hub.Register.StartupHook('End', function () {
                    window.setTimeout(window.print, 100);
                });
            });
        </script>
</body>
</html>
