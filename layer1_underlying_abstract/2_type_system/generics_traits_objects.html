<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>泛型、特征及特征对象 - Programming Anatomy In Rust</title>
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust为例分享学习编程常考虑的方方面面">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../style.css">
        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "../../";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/layer1_underlying_abstract.html"><strong aria-hidden="true">1.</strong> Layer1: 底层抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/1_virtual_memory/virtual_memory.html"><strong aria-hidden="true">1.1.</strong> 虚拟内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/1_virtual_memory/memory_manage_safety.html"><strong aria-hidden="true">1.1.1.</strong> 内存管理与内存安全</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/1_virtual_memory/ownership_scope_lifetime.html"><strong aria-hidden="true">1.1.2.</strong> 所有权、作用域与生命周期</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/type_system.html"><strong aria-hidden="true">1.2.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/primitive_types.html"><strong aria-hidden="true">1.2.1.</strong> 基础内置类型</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/collections.html"><strong aria-hidden="true">1.2.2.</strong> 集合类型</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/user_defined_types.html"><strong aria-hidden="true">1.2.3.</strong> 自定义类型</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/generics_traits_objects.html" class="active"><strong aria-hidden="true">1.2.4.</strong> 泛型、特征及特征对象</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/language_grammar.html"><strong aria-hidden="true">1.3.</strong> 语言语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/keywords_glossary.html"><strong aria-hidden="true">1.3.1.</strong> 词法结构扫盲</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/binding_match.html"><strong aria-hidden="true">1.3.2.</strong> 绑定、赋值与匹配</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/logical_decision_loops.html"><strong aria-hidden="true">1.3.3.</strong> 逻辑判断与循环♻️</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/statements_expressions.html"><strong aria-hidden="true">1.3.4.</strong> 语句与表达式</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/layer2_design_abstract.html"><strong aria-hidden="true">2.</strong> Layer2: 设计抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer2_design_abstract/4_programming_paradigm/4_programming_paradigm.html"><strong aria-hidden="true">2.1.</strong> 编程范式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer2_design_abstract/4_programming_paradigm/fp.html"><strong aria-hidden="true">2.1.1.</strong> 函数式编程</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/4_programming_paradigm/oop.html"><strong aria-hidden="true">2.1.2.</strong> 面向对象编程</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/4_programming_paradigm/gp.html"><strong aria-hidden="true">2.1.3.</strong> 泛型编程</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/5_design_pattern/5_design_pattern.html"><strong aria-hidden="true">2.2.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/6_module_manage/6_module_manage.html"><strong aria-hidden="true">2.3.</strong> 模块管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer2_design_abstract/6_module_manage/module_relate.html"><strong aria-hidden="true">2.3.1.</strong> 模块使用</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/6_module_manage/cargo_basic.html"><strong aria-hidden="true">2.3.2.</strong> Cargo基础</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/6_module_manage/cargo_plugins.html"><strong aria-hidden="true">2.3.3.</strong> Cargo扩展</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../layer3_task_abstract/layer3_task_abstract.html"><strong aria-hidden="true">3.</strong> Layer3: 任务抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer3_task_abstract/7_concurrency/7_concurrency.html"><strong aria-hidden="true">3.1.</strong> 并发编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer3_task_abstract/7_concurrency/io_models.html"><strong aria-hidden="true">3.1.1.</strong> 系统IO模型</a></li><li class="chapter-item expanded "><a href="../../layer3_task_abstract/7_concurrency/1_multi_models/multi_models.html"><strong aria-hidden="true">3.1.2.</strong> 多线程模型</a></li><li class="chapter-item expanded "><a href="../../layer3_task_abstract/7_concurrency/2_async_models/async_models.html"><strong aria-hidden="true">3.1.3.</strong> 异步模型</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer3_task_abstract/8_meta_programming/8_meta_programming.html"><strong aria-hidden="true">3.2.</strong> 元编程</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer4_protocol_abstract/layer4_protocol_abstract.html"><strong aria-hidden="true">4.</strong> Layer4: 协议抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer4_protocol_abstract/9_multilingual_programming/9_multilingual_programming.html"><strong aria-hidden="true">4.1.</strong> 跨语言编程</a></li><li class="chapter-item expanded "><a href="../../layer4_protocol_abstract/10_computer_network/10_computer_network.html"><strong aria-hidden="true">4.2.</strong> 计算机网络</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/layer5_ecosystem.html"><strong aria-hidden="true">5.</strong> Layer5: 生态环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/learning_resource.html"><strong aria-hidden="true">5.1.</strong> 学习资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/1_books/books.html"><strong aria-hidden="true">5.1.1.</strong> 书籍整理</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/2_courses/courses.html"><strong aria-hidden="true">5.1.2.</strong> 线上课程</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/3_blogs/blogs.html"><strong aria-hidden="true">5.1.3.</strong> 博客文章</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/4_videos/videos.html"><strong aria-hidden="true">5.1.4.</strong> 在线视频</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/5_projects/projects.html"><strong aria-hidden="true">5.1.5.</strong> 开源项目</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/2_lang_update/lang_update.html"><strong aria-hidden="true">5.2.</strong> 官方动态</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/3_community/community.html"><strong aria-hidden="true">5.3.</strong> 社区热点</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/4_academic/academic.html"><strong aria-hidden="true">5.4.</strong> 学术讨论</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/open_source.html"><strong aria-hidden="true">5.5.</strong> 开源观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/underlying.html"><strong aria-hidden="true">5.5.1.</strong> 底层开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/command/command.html"><strong aria-hidden="true">5.5.1.1.</strong> 命令行工具</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/data/data.html"><strong aria-hidden="true">5.5.1.2.</strong> 数据处理</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/embedded/embedded.html"><strong aria-hidden="true">5.5.1.3.</strong> 嵌入式</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/os/os.html"><strong aria-hidden="true">5.5.1.4.</strong> 系统开发</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/performance/performance.html"><strong aria-hidden="true">5.5.1.5.</strong> 性能工具</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/network.html"><strong aria-hidden="true">5.5.2.</strong> 网络相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/cloud/cloud.html"><strong aria-hidden="true">5.5.2.1.</strong> 云原生</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/frontend/frontend.html"><strong aria-hidden="true">5.5.2.2.</strong> 前端基建</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/network/network.html"><strong aria-hidden="true">5.5.2.3.</strong> 网络基建</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/web/web.html"><strong aria-hidden="true">5.5.2.4.</strong> web开发</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/3_media/media.html"><strong aria-hidden="true">5.5.3.</strong> 多媒体</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/3_media/av/av.html"><strong aria-hidden="true">5.5.3.1.</strong> 音视频处理</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/3_media/game/game.html"><strong aria-hidden="true">5.5.3.2.</strong> 游戏开发</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/4_other/other.html"><strong aria-hidden="true">5.5.4.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/4_other/lang-with-rust/lang_with_rust.html"><strong aria-hidden="true">5.5.4.1.</strong> Rust与其他语言</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/4_other/scientific-research/scientific_research.html"><strong aria-hidden="true">5.5.4.2.</strong> 科学艺术研究</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/4_other/tools/tools.html"><strong aria-hidden="true">5.5.4.3.</strong> 其他工具</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/6_security/security.html"><strong aria-hidden="true">5.6.</strong> 安全参考</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/7_business/business.html"><strong aria-hidden="true">5.7.</strong> 商业观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/7_business/blockchain/blockchain.html"><strong aria-hidden="true">5.7.1.</strong> 区块链</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/7_business/practices/practices.html"><strong aria-hidden="true">5.7.2.</strong> 生产实践</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/7_business/products/products.html"><strong aria-hidden="true">5.7.3.</strong> 优秀产品</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/8_libs/libs.html"><strong aria-hidden="true">5.8.</strong> 基础库</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/9_frameworks/frameworks.html"><strong aria-hidden="true">5.9.</strong> 框架引擎</a></li></ol></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
        <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Programming Anatomy In Rust</h1>

            <div class="right-buttons">
                    <a href="../../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/programming_anatomy_in_rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="泛型特征及特征对象"><a class="header" href="#泛型特征及特征对象">泛型、特征及特征对象</a></h1>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/rust-traits-deep-dive.png" alt="rust-traits-deep-dive" /></p>
<!--ts-->
<ul>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81%E5%8F%8A%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1">泛型、特征及特征对象</a>
<ul>
<li><a href="#%E6%B3%9B%E5%9E%8B">泛型</a>
<ul>
<li><a href="#%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E5%87%BA%E5%8F%91">从代码复用出发</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E4%B8%8D%E8%B6%B3">函数作用不足</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E8%BF%98%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B%E6%9D%A5%E5%A4%8D%E7%94%A8%E4%BB%A3%E7%A0%81">静态类型语言还需要泛型来复用代码</a></li>
</ul>
</li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E4%B8%80%E7%A7%8D%E5%8D%95%E6%80%81%E5%8C%96">泛型本质上是一种单态化</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F">泛型使用方式</a>
<ul>
<li><a href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0">泛型函数</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93">泛型结构体</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E6%9E%9A%E4%B8%BE%E4%BD%93">泛型枚举体</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81">泛型特征</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">泛型方法</a></li>
</ul>
</li>
<li><a href="#impl-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%9D%97">impl: 泛型实现块</a>
<ul>
<li><a href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0">泛型实现</a></li>
<li><a href="#%E4%B8%93%E9%97%A8%E5%8C%96%E6%B3%9B%E5%9E%8B">专门化泛型</a></li>
</ul>
</li>
<li><a href="#%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BE%8B%E5%8C%96">指定类型进行实例化</a>
<ul>
<li><a href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%8E%A8%E6%96%AD">基于类型实例化推断</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%9F%90%E4%BA%9B%E6%96%B9%E6%B3%95">泛型函数调用某些方法</a></li>
<li><a href="#turbofish-">turbofish: ::&lt;&gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%89%B9%E5%BE%81">特征</a>
<ul>
<li><a href="#%E4%BB%8E%E5%A4%9A%E6%80%81%E5%92%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B-%E6%8E%A5%E5%8F%A3%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B%E8%BF%98%E6%98%AF%E7%89%B9%E5%BE%81">从多态和代码复用的角度来看: 接口、鸭子类型还是特征？</a>
<ul>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="#%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型</a></li>
<li><a href="#%E7%89%B9%E5%BE%81-1">特征</a></li>
</ul>
</li>
<li><a href="#%E7%89%B9%E5%BE%81%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88">特征到底是什么？</a></li>
<li><a href="#%E7%89%B9%E5%BE%81%E7%9A%84%E5%A4%9A%E7%A7%8D%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F">特征的多种表现形式</a>
<ul>
<li><a href="#%E6%A0%87%E8%AE%B0%E7%89%B9%E5%BE%81">标记(特征)</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%89%B9%E5%BE%81">简单(特征)</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81-1">泛型(特征)</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E7%89%B9%E5%BE%81">关联类型(特征)</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF%E7%89%B9%E5%BE%81">继承(特征)</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%89%B9%E5%BE%81">一些常用内置特征</a>
<ul>
<li><a href="#debug">Debug</a></li>
<li><a href="#partialeq-%E5%92%8C-eq">PartialEq 和 Eq</a></li>
<li><a href="#copy%E5%92%8Cclone">Copy和Clone</a></li>
<li><a href="#display">Display</a></li>
<li><a href="#add">Add</a></li>
<li><a href="#into-%E5%92%8C-from">Into 和 From</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E4%BE%8B%E5%AD%90">一个完整例子</a></li>
</ul>
</li>
<li><a href="#%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81">特征区间：泛型+特征</a>
<ul>
<li><a href="#%E5%BC%95%E5%87%BA%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4">引出特征区间</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%8D%95%E4%BD%93%E5%8C%96">代码单体化</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%96%B9%E6%B3%95">指定特征区间的四个方法</a>
<ul>
<li><a href="#%E5%8C%BA%E9%97%B4%E5%86%85%E6%B3%9B%E5%9E%8B-fn-fn_namet-target_traitval-t">区间内泛型: fn fn_name&lt;T: target_trait&gt;(val: T)</a></li>
<li><a href="#where%E8%AF%AD%E5%8F%A5-%E5%BD%93%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D%E8%BF%87%E9%95%BF%E6%97%B6%E4%BD%BF%E7%94%A8">where语句: 当第一种方法签名过长时使用</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E5%A4%9A%E4%B8%AA%E7%89%B9%E5%BE%81">使用&quot;+&quot;组合多个特征</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8impl%E7%89%B9%E5%BE%81%E8%AF%AD%E6%B3%95-%E9%97%AD%E5%8C%85%E5%B8%B8%E7%94%A8">使用impl特征语法: 闭包常用</a></li>
</ul>
</li>
<li><a href="#%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">特征区间的使用场景</a>
<ul>
<li><a href="#%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BB%BA%E8%AE%AE">在类型上使用：不建议</a></li>
<li><a href="#%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0impl%E4%BB%A3%E7%A0%81%E5%9D%97">泛型函数+impl代码块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1-%E5%A4%9A%E6%80%81%E7%89%B9%E5%BE%81%E7%B1%BB%E5%9E%8B">特征对象: 多态特征类型</a>
<ul>
<li><a href="#%E5%88%86%E5%8F%91dispatch">分发(dispatch)</a>
<ul>
<li><a href="#%E5%88%86%E5%8F%91%E6%96%B9%E5%BC%8F%E9%9D%99%E6%80%81-or-%E5%8A%A8%E6%80%81">分发方式：静态 or 动态</a></li>
</ul>
</li>
<li><a href="#%E5%8C%BA%E5%88%AB%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E4%B8%8E%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1">区别特征区间与特征对象</a></li>
<li><a href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1%E5%85%B7%E4%BD%93%E8%AF%B4%E8%AF%B4">特征对象具体说说</a>
<ul>
<li><a href="#%E6%8C%87%E5%AE%9A%E4%B8%BA%E5%AE%9E%E7%8E%B0%E6%9F%90%E4%B8%AA%E7%89%B9%E5%BE%81">指定为实现某个特征</a></li>
<li><a href="#%E7%94%A8%E8%83%96%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0">用胖指针实现</a></li>
<li><a href="#%E6%98%AFrust%E6%89%A7%E8%A1%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91%E7%9A%84%E6%96%B9%E5%BC%8F">是Rust执行动态分发的方式</a></li>
<li><a href="#%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8B%E5%8F%AA%E8%83%BD%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E5%88%9B%E5%BB%BA">不定长类型只能作为引用创建</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93%E7%89%B9%E5%BE%81%E7%89%B9%E5%BE%81%E5%8C%BA%E9%97%B4%E5%92%8C%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1">总结特征、特征区间和特征对象</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Tue Jun 14 03:07:41 UTC 2022 -->
<!--te-->
<h2 id="泛型"><a class="header" href="#泛型">泛型</a></h2>
<h3 id="从代码复用出发"><a class="header" href="#从代码复用出发">从代码复用出发</a></h3>
<h4 id="函数作用不足"><a class="header" href="#函数作用不足">函数作用不足</a></h4>
<p>一直以来，函数的实现方式就是基于c语言的goto指令：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20220613150721312.png" alt="image-20220613150721312" /></p>
<p>通过进一步强化，就得到函数的实现方式：</p>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/image-20220613150804039.png" alt="image-20220613150804039" /></p>
<blockquote>
<p>但是也就这样了，函数只能实现流程上的复用，不能实现类型上的复用。这一点其实在python、js这些动态类型语言上面就不存在这个问题。对于Rust这种静态类型语言，对函数入参类型要求十分严格，于是泛型就应运而生。</p>
</blockquote>
<h4 id="静态类型语言还需要泛型来复用代码"><a class="header" href="#静态类型语言还需要泛型来复用代码">静态类型语言还需要泛型来复用代码</a></h4>
<blockquote>
<p>泛型编程是一种仅适用于静态类型编程语言的技术。它首次出现在 ML 语言中,是一种静态类型的函数式语言。</p>
</blockquote>
<p>像 Python 这样的动态语言采用的是简单类型 (duck typing) , 其中的 API 是根据它们可以做什么,而不是它们是什么来处理参数的,因此不依赖于泛型。</p>
<p>泛型是语言设计特性的一部分, 可以实现代码复用, 并遵循不重复自己的原则 (Don't Repeat Yourself,DRY) 。采用这种技术,你可以使用类型占位符来编写算法、函数、方法及类型, 并在这些类型上指定一个类型变量(
使用单个字母,通常是 T、K 或 V) ,告知编译器在任何代码中实例化它们时要填充的实际类型。这些类型被称为泛型或元素。单个字母(例如类型 T)被称为泛型参数。当你使用或实例化任何泛型元素时,它们会被替换成诸如 u32 这样的具体类型。</p>
<h3 id="泛型本质上是一种单态化"><a class="header" href="#泛型本质上是一种单态化">泛型本质上是一种单态化</a></h3>
<p>每次将泛型元素与具体类型一起使用时,都会在编译时用类型变量 T 生成该代码的特定副本,并将其替换为具体类型。<strong>这种在编译时生成包含具体类型的专用函数的过程被称为单态化,这是执行与多态函数相反的过程。</strong></p>
<h3 id="泛型使用方式"><a class="header" href="#泛型使用方式">泛型使用方式</a></h3>
<blockquote>
<p>在使用泛型时，应该多去考虑它与不同元素结合使用的场景背后的思维方式。泛型可以与结构体、枚举、函数、特征、方法及代码实现块。它们的一个共同特征是泛型的参数是由一对尖头括号分隔,并包含于其中。</p>
</blockquote>
<h4 id="泛型函数"><a class="header" href="#泛型函数">泛型函数</a></h4>
<p>为了创建泛型函数,我们需要将泛型参数放在函数名之后和圆括号之前,如下所示:</p>
<pre><pre class="playground"><code class="language-rust  editable">// generic_function.rs

fn give_me&lt;T&gt;(value: T) {
    let _ = value;
}

fn main() {
    let a = &quot;generics&quot;;
    let b = 1024;
    give_me(a);
    give_me(b);
}
</code></pre></pre>
<h4 id="泛型结构体"><a class="header" href="#泛型结构体">泛型结构体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// generic_struct.rs

struct Container&lt;T&gt; {
    item: T,
}

impl&lt;T&gt; Container&lt;T&gt; {
    fn new(item: T) -&gt; Self {
        Container { item }
    }
}

impl Container&lt;u32&gt; {
    fn sum(item: u32) -&gt; Self {
        Container { item }
    }
}

fn main() {
    // todo
}
</code></pre></pre>
<h4 id="泛型枚举体"><a class="header" href="#泛型枚举体">泛型枚举体</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// generic_enum.rs

enum Transmission&lt;T&gt; {
    Signal(T),
    NoSignal,
}

fn main() {
    // stuff
}
</code></pre></pre>
<h4 id="泛型特征"><a class="header" href="#泛型特征">泛型特征</a></h4>
<h4 id="泛型方法"><a class="header" href="#泛型方法">泛型方法</a></h4>
<h3 id="impl-泛型实现块"><a class="header" href="#impl-泛型实现块">impl: 泛型实现块</a></h3>
<h4 id="泛型实现"><a class="header" href="#泛型实现">泛型实现</a></h4>
<blockquote>
<p>当为任何泛型编写 impl 代码块时,都需要在使用它之前声明泛型参数。T 就像一个变量—— 一个类型变量,我们需要先声明它 impl代码块实际上意味着我们正在为所有类型 T 实现这些方法,它们会出现在 Container<T>中。这个 impl 代码块是一个泛型实现。 因此,生成的每个具体 Container 都将有这些方法。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// generic_struct_impl.rs

struct Container&lt;T&gt; {
    item: T,
}

impl&lt;T&gt; Container&lt;T&gt; {
    fn new(item: T) -&gt; Self {
        Container { item }
    }
}

fn main() {
    // stuff
}
</code></pre></pre>
<h4 id="专门化泛型"><a class="header" href="#专门化泛型">专门化泛型</a></h4>
<blockquote>
<p>在这里, 由于 u32 是作为具体类型存在的, 因此我们不需要 impl 之后的<T>, 这是 impl 代码块的另外一个特性,它允许你通过独立实现方法来专门化泛型。 现在,我们也可以通过将 T 替换为任何具体类型来为 Container<T>编写更具体的 impl 代码块。以下就是它的实例:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">impl Container&lt;u32&gt; { 
    fn sum(item: u32) -&gt; Self {
        Container { item }
    } 
}
</code></pre></pre>
<h3 id="指定类型进行实例化"><a class="header" href="#指定类型进行实例化">指定类型进行实例化</a></h3>
<blockquote>
<p>每当我们进行实例化时, 编译器需要在其类型签名中知道 T 的具体类型以便替换,这为其提供了将泛型代码单态化的类型信息。 而具体类型的确定主要有三种方式：</p>
</blockquote>
<ol>
<li>大多数情况下,具体类型是基于类型的实例化推断.</li>
<li>对泛型函数调用某些方法来接收具体类型。</li>
<li>在极个别情况下, 我们需要通过使用 <code>turbofish (::&lt;&gt;)</code>运算符输入具体类型来替代泛型以便辅助编译器识别。</li>
</ol>
<h4 id="基于类型实例化推断"><a class="header" href="#基于类型实例化推断">基于类型实例化推断</a></h4>
<p>这是最常见的方式，主要基于类型特征(trait)。</p>
<h4 id="泛型函数调用某些方法"><a class="header" href="#泛型函数调用某些方法">泛型函数调用某些方法</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// using_generic_func.rs

use std::str;

fn main() {
    let num_from_str = str::parse::&lt;u8&gt;(&quot;34&quot;).unwrap();
    println!(&quot;Parsed number {}&quot;, num_from_str);
}
</code></pre></pre>
<h4 id="turbofish-"><a class="header" href="#turbofish-">turbofish: ::&lt;&gt;</a></h4>
<ol>
<li>如果没有任何类型特征，代码将无法编译：👇</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">fn main() {
    let a = Vec::new();
}
</code></pre></pre>
<ol start="2">
<li>这时可以用下列三种方式指定</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">// using_generic_vec.rs

fn main() {
    // providing a type
    let v1: Vec&lt;u8&gt; = Vec::new();

    // or calling method
    let mut v2 = Vec::new();
    v2.push(2); // v2 is now Vec&lt;i32&gt;

    // or using turbofish
    let v3 = Vec::&lt;u8&gt;::new(); // not so readable
}
</code></pre></pre>
<h2 id="特征"><a class="header" href="#特征">特征</a></h2>
<h3 id="从多态和代码复用的角度来看-接口鸭子类型还是特征"><a class="header" href="#从多态和代码复用的角度来看-接口鸭子类型还是特征">从多态和代码复用的角度来看: 接口、鸭子类型还是特征？</a></h3>
<p>从多态和代码复用的角度来看, 在代码中将类型的共享行为和公共属性与其自身隔离通常是一个好主意,并且能拥有专属于自己的方法。在这样做时,我们允许不同类型通过通用属性互相关联,使我们能够为 API 编程,使其参数更通用或更具包容性。</p>
<blockquote>
<p>这意味着我们可以接收具有这些通用属性的类型,而不仅限于某种特定类型。</p>
</blockquote>
<h4 id="接口"><a class="header" href="#接口">接口</a></h4>
<p>类似 Java 和 C#的面向对象编程语言中,接口表达了相同的理念,我们可以在其中定义多种类型能够实现的共享行为。例如,我们可以使用单个 sort 函数接收实现 Comparable 或者 Comparator
接口的元素列表,而不是使用多个 sort 函数接收整数值列表,以及用其他函数接收字符串值列表。这使得我们可以将任何可比较(Comparable)的内容传递给 sort 函数。</p>
<h4 id="鸭子类型"><a class="header" href="#鸭子类型">鸭子类型</a></h4>
<p>而Python同样有明确的特性，被称为&quot;鸭子类型&quot;.</p>
<blockquote>
<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>
</blockquote>
<p>在鸭子类型中，关注点在于对象的行为，能做什么；而不是关注对象所属的类型。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为“鸭子”的对象，并调用它的“走”和“叫”方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的“走”和“叫”方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的“走”和“叫”方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p>
<p>鸭子类型通常得益于“不”测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。</p>
<p>在常规类型中，我们能否在一个特定场景中使用某个对象取决于这个对象的类型，而在鸭子类型中，则取决于这个对象是否具有某种属性或者方法——即只要具备特定的属性或方法，能通过鸭子测试，就可以使用。</p>
<h4 id="特征-1"><a class="header" href="#特征-1">特征</a></h4>
<p>Rust也有一个类似且功能强大的结构,被称为特征。Rust中的特征以多种形式存在, 我们将介绍一些最常见的形式并了解一些与它们简单交互的方式。此外,当特征与泛型搭配使用时,可以限制传递到 API
的参数范围。我们将会对特征进行比较深入的了解。</p>
<h3 id="特征到底是什么"><a class="header" href="#特征到底是什么">特征到底是什么？</a></h3>
<h3 id="特征的多种表现形式"><a class="header" href="#特征的多种表现形式">特征的多种表现形式</a></h3>
<h4 id="标记特征"><a class="header" href="#标记特征">标记(特征)</a></h4>
<h4 id="简单特征"><a class="header" href="#简单特征">简单(特征)</a></h4>
<h4 id="泛型特征-1"><a class="header" href="#泛型特征-1">泛型(特征)</a></h4>
<h4 id="关联类型特征"><a class="header" href="#关联类型特征">关联类型(特征)</a></h4>
<h4 id="继承特征"><a class="header" href="#继承特征">继承(特征)</a></h4>
<h3 id="一些常用内置特征"><a class="header" href="#一些常用内置特征">一些常用内置特征</a></h3>
<h4 id="debug"><a class="header" href="#debug">Debug</a></h4>
<p>这个特征有助于在控制台上输出类型以便进行调试。在组合类型的情况下,类型将以类似 JSON 的格式输出,其中带有花括号和其他括号,如果类型是字符串,将会用引号标识。这适用于 Rust 中的大多数内置类型。</p>
<h4 id="partialeq-和-eq"><a class="header" href="#partialeq-和-eq">PartialEq 和 Eq</a></h4>
<p>这些特征允许两个元素相互比较以验证是否相等</p>
<h4 id="copy和clone"><a class="header" href="#copy和clone">Copy和Clone</a></h4>
<p>这些特征定义了类型的复制方式。 简而言之,当在任何自定义类型上自动派生时,这些特征允许用户从实例创建新的副本:</p>
<ol>
<li>可以在实现 Copy 时隐式创建</li>
<li>也可以在实现 Clone 时通过调用 clone() 显式创建。</li>
</ol>
<blockquote>
<p>请注意,Copy 依赖于在类型上实现的 Clone 特征</p>
</blockquote>
<h4 id="display"><a class="header" href="#display">Display</a></h4>
<h4 id="add"><a class="header" href="#add">Add</a></h4>
<h4 id="into-和-from"><a class="header" href="#into-和-from">Into 和 From</a></h4>
<h3 id="一个完整例子"><a class="header" href="#一个完整例子">一个完整例子</a></h3>
<pre><pre class="playground"><code class="language-rust  editable">// complex/src/lib.rs

use std::ops::Add;

/*
将#[derive(Default)] 属性实现为一个过程宏,可以自动实现它修饰的类型的特征。
此自动派生要求任何自定义类型的字段(例如结构体或枚举)本身必须实现 Default 特征。
使用它们继承特征仅适用于结构体、枚举及联合。
*/
#[derive(Default, Debug, PartialEq, Copy, Clone)]
struct Complex&lt;T&gt; {
    // Real part
    re: T,
    // Complex part
    im: T,
}

impl&lt;T&gt; Complex&lt;T&gt; {
    // new 函数实际上并不是一个特殊的构造函数(如果你只了解带有构造函数的语言),
    // 而是社区采用的一个常用名称(作为创建新类型实例的方法名) 。
    fn new(re: T, im: T) -&gt; Self {
        Complex { re, im }
    }
}

// 来自 std::ops 模块的 Add 特征允许我们使用“+”运算符将两个复数相加
/*
1. impl&lt;T: Add&lt;T, Output=T&gt;表示我们正在为泛型 T 实现 Add,其中 T 实现 Add&lt;T, Output=T&gt;。
2. &lt;T, Output=T&gt;部分表示 Add 特征的实现必须具有相同的输入和输出类型
3. Add for Complex&lt;T&gt;部分表示为 Complex&lt;T&gt;类型实现 Add 特征
4. T:Add 表示必须实现 Add 特征。如果没有实现,那么我们不能使用“+”运算符
*/
impl&lt;T: Add&lt;T, Output=T&gt;&gt; Add for Complex&lt;T&gt; {
    type Output = Complex&lt;T&gt;;
    // Add 特征提供的核心功能,是我们在两种实现类型之间使用“+”运算符时调用的方法。
    // 它是一个实例方法,通过值获取 self 并接收 rhs 作为参数,即特征定义中的 RHS。
    fn add(self, rhs: Complex&lt;T&gt;) -&gt; Self::Output {
        Complex { re: self.re + rhs.re, im: self.im + rhs.im }
    }
}

// 来自 std::convert 模块的 Into 和 From 特征使用户能够根据其他类型创建复数类型
/*
1. 如果我们可以从内置基元类型 (例如双元素元组) 构造 Complex 类型
   其中第 1 个元素是实部,第 2 个元素是虚部,将会很方便。
   我们可以通过实现 From 特征来达到此目的。
2. 此特征定义了一个 from 方法, 为我们提供了在类型之间进行转换的一般方法
3. 第一个&lt;T&gt;是泛型 T 的声明, 第二个和第三个&lt;T&gt;是泛型类型 T 的用途。 我们会根据(T,T) 类型创建它
*/
impl&lt;T&gt; From&lt;(T, T)&gt; for Complex&lt;T&gt; {
    /*
        当我们实现它时, 只需要用我们希望实现它的类型替换 T 并实现 from 方法,
        然后我们就可以在相关类型上调用该方法。
        这是一个将 Complex 值转换为双元素元组类型的实现, Rust本身就能识别它
    */
    fn from(value: (T, T)) -&gt; Complex&lt;T&gt; {
        Complex { re: value.0, im: value.1 }
    }
}

use std::fmt::{Formatter, Display, Result};

// Display 特征能够输出人类可读版本的复数类型
impl&lt;T: Display&gt; Display for Complex&lt;T&gt; {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result {
        // 为了让用户能够以数学符号的形式查看复数类型
        write!(f, &quot;{} + {}i&quot;, self.re, self.im)
    }
}

// 一个简单的初始化测试用例。
#[cfg(test)]
mod tests {
    use crate::Complex;

    #[test]
    fn complex_basics() {
        let first = Complex::new(3, 5);
        let second: Complex&lt;i32&gt; = Complex::default();
        assert_eq!(first.re, 3);
        assert_eq!(first.im, 5);
        assert!(second.re == second.im);
    }

    #[test]
    fn complex_addition() {
        let a = Complex::new(1, -2);
        let b = Complex::default();
        let res = a + b;
        assert_eq!(res, a);
    }

    #[test]
    fn complex_from() {
        let a = (2345, 456);
        let complex = Complex::from(a);
        assert_eq!(complex.re, 2345);
        assert_eq!(complex.im, 456);
    }

    #[test]
    fn complex_display() {
        let my_imaginary = Complex::new(2345, 456);
        println!(&quot;{}&quot;, my_imaginary);
    }
}
// 最后使用cargo test -- --nocapture执行
</code></pre></pre>
<h2 id="特征区间泛型特征"><a class="header" href="#特征区间泛型特征">特征区间：泛型+特征</a></h2>
<h3 id="引出特征区间"><a class="header" href="#引出特征区间">引出特征区间</a></h3>
<p>首先看一下如下代码：</p>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_intro.rs

struct Game;

struct Enemy;

struct Hero;
/*
在 Game 类型上我们有一个泛型函数 load,它可以接收任何游戏实体,
并通过任意 T 调用 init()将其加载到我们的游戏世界中。
但是,这个示例无法通过编译
*/
impl Game {
    fn load&lt;T&gt;(&amp;self, entity: T) {
        entity.init(); // method not found in `T`
    }
}

fn main() {
    let game = Game;
    game.load(Enemy);
    game.load(Hero);
}
</code></pre></pre>
<ol>
<li>因此, 任何类型为 T 的泛型函数都不能知道或默认假定 init()方法存在于 T 之上。</li>
<li>如果确实如此,那么它根本不是泛型,并且它们只能接收具有 init()方法的类型。</li>
<li><strong>因此,有一种方法可以让编译器知道这一点,并约束 load 通过特征能够接收的类型集,这就需要用到特征区间</strong>。</li>
</ol>
<blockquote>
<p>我们可以定义一个名为 Loadable 的特征,并在我们的 Enemy 和 Hero 类型上实现它。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_intro.rs

struct Game;

struct Enemy;

struct Hero;

trait Loadable {
    fn init(&amp;self);
}
/*
我们分别为 Enemy 和 Hero 实现了 Loadable,还修改了 load 方法
*/
impl Loadable for Enemy {
    fn init(&amp;self) {
        println!(&quot;Enemy loaded&quot;);
    }
}

impl Loadable for Hero {
    fn init(&amp;self) {
        println!(&quot;Hero loaded&quot;);
    }
}

impl Game {
    /*
        我们必须在泛型声明旁边放置几个符号来指定特征,我们称之为特征区间
    */
    fn load&lt;T: Loadable&gt;(&amp;self, entity: T) {
        entity.init();
    }
}

fn main() {
    let game = Game;
    game.load(Enemy);
    game.load(Hero);
}
</code></pre></pre>
<ol>
<li>注意, “:Loadable”部分表明了我们指定特征范围的方式。特征区间允许我们限制泛型 API 可以接收的参数范围。</li>
</ol>
<h3 id="代码单体化"><a class="header" href="#代码单体化">代码单体化</a></h3>
<ol>
<li>指定泛型元素上的绑定的特征类似于我们为变量指定类型的方式</li>
<li>但是此处的变量是泛型 T,类型是某些特征。例如 <strong>T:SomeTrait</strong>。</li>
<li>定义泛型函数时几乎总是会用到特征区间。</li>
<li>如果定义的泛型函数中的 T 不包含任何特征区间,我们就不能通过任何方法调用,因 Rust 不知道给定方法实现的方式。</li>
<li>它需要知道 T 是否具有某个 foo 方法,以便<strong>将代码单体化</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_basics.rs

// 我们有一个方法 add_thing,它可以添加任何类型 T。
fn add_thing&lt;T&gt;(fst: T, snd: T) {
    // 编译器向用户建议在 T 上添加特征区间 Add
    // help: consider restricting type parameter `T`
    let _ = fst + snd;
}

fn main() {
    add_thing(2, 2);
}
</code></pre></pre>
<blockquote>
<p>修正后</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bound_basics_fixed.rs

use std::ops::Add;

// 代码修改之后,我们将“:Add”添加到了 T 的后面,之后代码通过了编译
fn add_thing&lt;T: Add&gt;(fst: T, snd: T) {
    let _ = fst + snd;
}

fn main() {
    add_thing(2, 2);
}
</code></pre></pre>
<h3 id="指定特征区间的四个方法"><a class="header" href="#指定特征区间的四个方法">指定特征区间的四个方法</a></h3>
<h4 id="区间内泛型-fn-fn_namet-target_traitval-t"><a class="header" href="#区间内泛型-fn-fn_namet-target_traitval-t">区间内泛型: fn fn_name&lt;T: target_trait&gt;(val: T)</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 指定特征区间的一种方法, 它会接收任何实现了 Display 特征的类型
fn show_me&lt;T: Display&gt;(val: T) {
    //可以使用{}格式化字符串，因为有Display特征区间
    printin!(&quot;{}&quot;, val);
}
<span class="boring">}
</span></code></pre></pre>
<ol>
<li>这是在泛型函数的类型签名的长度较短时声明特征区间的常见语法。</li>
<li>在指定类型的特征区间时,此语法也有效</li>
</ol>
<h4 id="where语句-当第一种方法签名过长时使用"><a class="header" href="#where语句-当第一种方法签名过长时使用">where语句: 当第一种方法签名过长时使用</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt;
    where F: FromStr { ... }
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>注意“where F: FromStr”部分告诉我们 F 类型必须实现 FromStr 特征。where 语句将特征区间和函数签名解耦,并使其可读</p>
</blockquote>
<h4 id="使用组合多个特征"><a class="header" href="#使用组合多个特征">使用&quot;+&quot;组合多个特征</a></h4>
<ul>
<li>先看一下标准库中 HashMap 类型的 impl 代码块:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// HashMap 键类型的 K 必须实现 Hash 特征和 Eq 特征
impl&lt;K: Hash + Eq, V&gt; HashMap&lt;K, V, RandomState&gt;
{}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>一个更加具体的例子</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable">// traits_composition.rs

trait Eat {
    fn eat(&amp;self) {
        println!(&quot;eat&quot;);
    }
}

trait Code {
    fn code(&amp;self) {
        println!(&quot;code&quot;);
    }
}

trait Sleep {
    fn sleep(&amp;self) {
        println!(&quot;sleep&quot;);
    }
}

// 创建了一个新的特征 Programmer,它由 3 个特征组合而成:Eat、Code、 Sleep。
// 通过这种方式, 我们对类型设置了约束:
// 因此如果类型 T 实现了 Programmer, 那么它必须实现上述所有特征
trait Programmer: Eat + Code + Sleep {
    fn animate(&amp;self) {
        self.eat();
        self.code();
        self.sleep();
        println!(&quot;repeat!&quot;);
    }
}

struct Bob;

impl Programmer for Bob {}

impl Eat for Bob {}

impl Code for Bob {}

impl Sleep for Bob {}

fn main() {
    Bob.animate();
}
</code></pre></pre>
<h4 id="使用impl特征语法-闭包常用"><a class="header" href="#使用impl特征语法-闭包常用">使用impl特征语法: 闭包常用</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// impl_trait_syntax.rs

use std::fmt::Display;

/*
直接使用了 impl Display,而不是指定 T:Display。这是 impl 特征语法。
这为我们返回复杂或不方便表示的类型(例如函数的闭包)提供了便利
*/
fn show_me(val: impl Display) {
    println!(&quot;{}&quot;, val);
}

fn main() {
    show_me(&quot;Trait bounds are awesome&quot;);
}
</code></pre></pre>
<blockquote>
<p>如果没有这种语法,则必须使用 Box 智能指针类型将其放在指针后面返回,这涉及堆分配。
闭包的底层结构由实现了一系列特征的结构体组成。<strong>Fn(T) -&gt; U</strong> 特征就是其中之一</p>
</blockquote>
<p>闭包使用示例：</p>
<pre><pre class="playground"><code class="language-rust  editable">// impl_trait_closure.rs
// 它接收两个数字,并返回将这两个数字相加的闭包
fn lazy_adder(a: u32, b: u32) -&gt; impl Fn() -&gt; u32 {
    move || a + b
}

fn main() {
    // 调用 lazy_adder,传入两个数字。
    // 这会在 lazy_adder 中创建一个闭包,但不会对其进行求值
    let add_later = lazy_adder(1024, 2048);
    println!(&quot;{:?}&quot;, add_later());
}
</code></pre></pre>
<p>还可以在入参和返回使用：</p>
<pre><pre class="playground"><code class="language-rust  editable">// impl_trait_both.rs

use std::fmt::Display;

/*
1. 会接收任何 Display 特征的参数
2. 返回的类型是 impl Display
*/
fn surround_with_braces(val: impl Display) -&gt; impl Display {
    format!(&quot;{{{}}}&quot;, val)
}

fn main() {
    println!(&quot;{}&quot;, surround_with_braces(&quot;Hello&quot;));
}
</code></pre></pre>
<ol>
<li>通常建议将特征区间的 impl 特征语法用做函数的返回类型。</li>
<li>在参数位置使用它意味着我们不能使用 turbofish 运算符。</li>
<li>如果某些相关代码使用 turbofish 运算符来调用软件包中的某个方法,那么可能导致 API 不兼容。</li>
<li>只有当我们没有可用的具体类型时才应该使用它, 就像闭包那样。</li>
</ol>
<h3 id="特征区间的使用场景"><a class="header" href="#特征区间的使用场景">特征区间的使用场景</a></h3>
<h4 id="在类型上使用不建议"><a class="header" href="#在类型上使用不建议">在类型上使用：不建议</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_types.rs

use std::fmt::Display;

// 写法一：区间内泛型
struct Foo&lt;T: Display&gt; {
    bar: T,
}

// 写法二：where语句解耦
struct Bar&lt;F&gt;
    where
        F: Display,
{
    inner: F,
}

fn main() {}
</code></pre></pre>
<blockquote>
<p>不过,我们并不鼓励在类型上使用特征区间,因为它对类型自身施加了限制。
通常, 我们希望类型尽可能是泛型,从而允许我们使用任何类型创建实例,并使用函数或方法中的特征区间对其行为进行限制。</p>
</blockquote>
<h4 id="泛型函数impl代码块"><a class="header" href="#泛型函数impl代码块">泛型函数+impl代码块</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// trait_bounds_functions.rs

use std::fmt::Debug;

trait Eatable {
    fn eat(&amp;self);
}

// 指定类型必须是 Debug,以便其可以在方法内部输出到控制台
#[derive(Debug)]
struct Food&lt;T&gt;(T);

#[derive(Debug)]
struct Apple;

// 为了让 apple 是“可食用”的,我们实现了 Food 的 Eatable 特征
impl&lt;T&gt; Eatable for Food&lt;T&gt;
    where
        T: Debug,
{
    fn eat(&amp;self) {
        println!(&quot;Eating {:?}&quot;, self);
    }
}

// 注意 eat 的特点,类型 T 必须实现 Eatable 特征。
fn eat&lt;T&gt;(val: T)
    where
        T: Eatable,
{
    val.eat();
}

fn main() {
    let apple = Food(Apple);
    eat(apple);
}
</code></pre></pre>
<h2 id="特征对象-多态特征类型"><a class="header" href="#特征对象-多态特征类型">特征对象: 多态特征类型</a></h2>
<h3 id="分发dispatch"><a class="header" href="#分发dispatch">分发(dispatch)</a></h3>
<blockquote>
<p>分发是一个从面向对象编程范式中借鉴的概念,主要用于描述被称为多态的上下文中的一种特性。 在面向对象程序设计(Object-Oriented Programming,OOP)中,当 API 是泛型或者接收实现为接口的参数时,必须弄清楚参数在传递给 API 的类型实例上调用什么方法实现。多态的上下文中的方法解析过程被称为分发,调用该方法被称为分发化(dispatching) 。</p>
</blockquote>
<h4 id="分发方式静态-or-动态"><a class="header" href="#分发方式静态-or-动态">分发方式：静态 or 动态</a></h4>
<blockquote>
<p>在支持多态的主流语言中,分发可以通过以下任意一种方式进行。</p>
</blockquote>
<ol>
<li>静态分发：编译期决定</li>
</ol>
<p>当在编译期决定要调用的方法时,它被称为静态分发或早期绑定。方法的签名用于决定调用的方法,所有这些都在编译期决定。在 Rust 中,泛型展示了这种形式的分发, 因为即使泛型函数可以接收许多参数, 也会在编译期使用具体类型生成函数的专用副本。</p>
<p>2.动态分发: 运行期决定，资源开销更大</p>
<p>在面向对象的语言中,有时直到运行时才能确定调用的方法。这是因为具体类型被隐藏,并且只有接口方法可用于调用该类型。 在 Java 中,当函数只有参数时就是这种情况,即接口。 这种情况只能通过动态分发来处理。在动态分发过程中,可通过对
vtable 接口的实现列表进行查找,并调用该方法来动态确定相关方法。vtable 是一个函数指针列表,指向每个类型的实现方法。由于方法调用过程中存在额外的间接指针引用,所以这需要更多的资源开销</p>
<h3 id="区别特征区间与特征对象"><a class="header" href="#区别特征区间与特征对象">区别特征区间与特征对象</a></h3>
<table><thead><tr><th align="center">特征使用方式</th><th align="center">分发方式</th><th align="center">实现方式</th><th align="center">绑定时期</th><th></th></tr></thead><tbody>
<tr><td align="center">特征区间</td><td align="center">静态分发</td><td align="center">限定泛型</td><td align="center">编译期(早期绑定)</td><td></td></tr>
<tr><td align="center">特征对象</td><td align="center">动态分发</td><td align="center">胖指针</td><td align="center">运行期多态(后期绑定)</td><td></td></tr>
</tbody></table>
<h3 id="特征对象具体说说"><a class="header" href="#特征对象具体说说">特征对象具体说说</a></h3>
<h4 id="指定为实现某个特征"><a class="header" href="#指定为实现某个特征">指定为实现某个特征</a></h4>
<p>特征对象是一种创建多态 API 的方法,可以将参数指定为实现某个特征的东西,而不是泛型或具体类型。这种方法被声明为实现某个特征 API,即特征对象。</p>
<h4 id="用胖指针实现"><a class="header" href="#用胖指针实现">用胖指针实现</a></h4>
<p>特征对象类似 C++中的虚方法。特征对象实现为胖指针,并且是不定长类型,这意味着它们只能在引用符号(&amp;)后面使用。特征对象胖指针具有指向与对象关联的实际数据的第一指针,而第二指针指向虚拟表(vtable) ,它是在固定偏移处为每个对象的方法保留一个函数指针的结构体。</p>
<h4 id="是rust执行动态分发的方式"><a class="header" href="#是rust执行动态分发的方式">是Rust执行动态分发的方式</a></h4>
<p>特征对象是 Rust 执行动态分发的方式,我们没有实际的具体类型信息。通过跳转到vtable 并调用适当的方法完成方法解析。</p>
<p>特征对象的另一个用例是,它们允许用户对可以具有多种类型的集合进行操作,但是在运行时需要额外的间接指针引用开销</p>
<pre><pre class="playground"><code class="language-rust  editable">// trait_objects.rs

use std::fmt::Debug;

#[derive(Debug)]
struct Square(f32);

#[derive(Debug)]
struct Rectangle(f32, f32);

trait Area: Debug {
    fn get_area(&amp;self) -&gt; f32;
}

impl Area for Square {
    fn get_area(&amp;self) -&gt; f32 {
        self.0 * self.0
    }
}

impl Area for Rectangle {
    fn get_area(&amp;self) -&gt; f32 {
        self.0 * self.1
    }
}

fn main() {
    /*
        shapes 的元素类型是&amp;dyn Area,这是一种表示为特征的类型。
        特征对象是由 dyn Area 表示的, 意味着它是指向 Area 特征某些实现的指针。
        特征对象形式的类型允许用户在集合类型(例如 Vec)中存储不同类型

        Square 和 Rectangle 会隐式转换成特征对象,因为我们给它们推送了一个引用。
        我们还可以通过手动转换某个特征对象来构造一个类型,但这是一种比较少见的情况.
        只有在编译器自身无法将类型作为特征对象转换时使用。
    */
    let shapes: Vec&lt;&amp;dyn Area&gt; = vec![&amp;Square(3f32), &amp;Rectangle(4f32, 2f32)];
    for s in shapes {
        println!(&quot;{:?}&quot;, s);
    }
}
</code></pre></pre>
<h4 id="不定长类型只能作为引用创建"><a class="header" href="#不定长类型只能作为引用创建">不定长类型只能作为引用创建</a></h4>
<blockquote>
<p>请注意,我们只能创建在编译时知道类型尺寸的特征对象。</p>
</blockquote>
<p>dyn Trait 是一个不定长类型,只能作为引用创建。我们还可以通过将特征对象置于其他指针类型之后来创建特征对象,例如 Box、Rc、Arc 等</p>
<pre><pre class="playground"><code class="language-rust  editable">// dyn_trait.rs

use std::fmt::Display;

fn show_me(item: &amp;dyn Display) {
    println!(&quot;{}&quot;, item);
}

fn main() {
    show_me(&amp;&quot;Hello trait object&quot;);
}
</code></pre></pre>
<h2 id="总结特征特征区间和特征对象"><a class="header" href="#总结特征特征区间和特征对象">总结特征、特征区间和特征对象</a></h2>
<p>特征和泛型通过单态化(早期绑定)或运行时多态(后期绑定)提供了两种代码复用的方式。
何时使用它们取决于具体情况和相关应用程序的需求：</p>
<ol>
<li>通常,错误类型会被分配到动态分发的序列,因为它们应该是很少被执行的代码路径。</li>
<li>单态化对小型的应用场景来说非常方便,但是缺点是导致了代码的膨胀和重复,这会影响缓存效率,并增加二进制文件的大小。</li>
</ol>
<blockquote>
<p>但是,在这两个选项中,静态分发应该是首选,除非系统对二进制文件大小存在严格的限制。</p>
</blockquote>
<h2 id="参考资源"><a class="header" href="#参考资源">参考资源</a></h2>
<ol>
<li>&lt;精通rust(第二版)&gt;-第四章：类型、泛型和特征</li>
<li><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">Advanced Traits - The Rust Programming Language</a></li>
<li><a href="https://blog.logrocket.com/rust-traits-a-deep-dive/">Rust traits: A deep dive - LogRocket Blog</a></li>
<li>《代码之髓》- 第五章：函数</li>
<li><a href="https://zh.m.wikipedia.org/zh-hans/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型 - 维基百科，自由的百科全书</a></li>
</ol>

            </main>

            <script src="https://utteranc.es/client.js"
                    repo="RustMagazine/rust_magazine_2022"
                    issue-term="title"
                    theme="github-light"
                    crossorigin="anonymous"
                    async></script>

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../../layer1_underlying_abstract/2_type_system/user_defined_types.html" class="mobile-nav-chapters previous"
                       title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../layer1_underlying_abstract/3_language_grammar/language_grammar.html" class="mobile-nav-chapters next"
                       title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../../layer1_underlying_abstract/2_type_system/user_defined_types.html" class="nav-chapters previous" title="Previous chapter"
               aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            <a rel="next" href="../../layer1_underlying_abstract/3_language_grammar/language_grammar.html" class="nav-chapters next" title="Next chapter"
               aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
    </nav>

</div>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
<script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="../../book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="../../mermaid.min.js"></script>
    <script type="text/javascript" src="../../mermaid-init.js"></script>
    <script type="text/javascript" src="../../smart-anchor.js"></script>
    <script type="text/javascript" src="../../sidebar.js"></script>
</body>
</html>
