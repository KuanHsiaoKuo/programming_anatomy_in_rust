<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js rust">
<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>所有权三件套 - Programming Anatomy In Rust</title>
    <!-- Custom HTML head -->
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="以rust为例分享学习编程常考虑的方方面面">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff"/>

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../style.css">
        <link rel="stylesheet" href="../../././assets/css/mdbook-admonish.css">
        <!-- MathJax -->
        <script async type="text/javascript"
                src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<!-- Provide site root to javascript -->
<script type="text/javascript">
    var path_to_root = "../../";
    var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
</script>

<!-- Work around some values being stored in localStorage wrapped in quotes -->
<script type="text/javascript">
    try {
        var theme = localStorage.getItem('mdbook-theme');
        var sidebar = localStorage.getItem('mdbook-sidebar');

        if (theme.startsWith('"') && theme.endsWith('"')) {
            localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
        }

        if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
            localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
        }
    } catch (e) {
    }
</script>

<!-- Set the theme before any content is loaded, prevents flash -->
<script type="text/javascript">
    var theme;
    try {
        theme = localStorage.getItem('mdbook-theme');
    } catch (e) {
    }
    if (theme === null || theme === undefined) {
        theme = default_theme;
    }
    var html = document.querySelector('html');
    html.classList.remove('no-js')
    html.classList.remove('rust')
    html.classList.add(theme);
    html.classList.add('js');
</script>

<!-- Hide / unhide sidebar before it is displayed -->
<script type="text/javascript">
    var html = document.querySelector('html');
    var sidebar = 'hidden';
    if (document.body.clientWidth >= 1080) {
        try {
            sidebar = localStorage.getItem('mdbook-sidebar');
        } catch (e) {
        }
        sidebar = sidebar || 'visible';
    }
    html.classList.remove('sidebar-visible');
    html.classList.add("sidebar-" + sidebar);
</script>

<nav id="sidebar" class="sidebar" aria-label="Table of contents">
    <div class="sidebar-scrollbox">
        <ol class="chapter"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/layer1_underlying_abstract.html"><strong aria-hidden="true">1.</strong> Layer1: 底层抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/1_virtual_memory/virtual_memory.html"><strong aria-hidden="true">1.1.</strong> 虚拟内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/1_virtual_memory/memory_manage_safety.html"><strong aria-hidden="true">1.1.1.</strong> 内存管理与内存安全</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/1_virtual_memory/ownership_borrow_lifetime.html" class="active"><strong aria-hidden="true">1.1.2.</strong> 所有权三件套</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/type_system.html"><strong aria-hidden="true">1.2.</strong> 类型系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/primitive_types.html"><strong aria-hidden="true">1.2.1.</strong> 基础内置类型</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/collections.html"><strong aria-hidden="true">1.2.2.</strong> 集合类型</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/user_defined_types.html"><strong aria-hidden="true">1.2.3.</strong> 自定义类型</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/2_type_system/generics_traits_objects.html"><strong aria-hidden="true">1.2.4.</strong> 泛型、特征及特征对象</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/language_grammar.html"><strong aria-hidden="true">1.3.</strong> 语言语法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/keywords_glossary.html"><strong aria-hidden="true">1.3.1.</strong> 词法结构扫盲</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/binding_match.html"><strong aria-hidden="true">1.3.2.</strong> 绑定、赋值与匹配</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/logical_decision_loops.html"><strong aria-hidden="true">1.3.3.</strong> 逻辑判断与循环♻️</a></li><li class="chapter-item expanded "><a href="../../layer1_underlying_abstract/3_language_grammar/statements_expressions.html"><strong aria-hidden="true">1.3.4.</strong> 语句与表达式</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/layer2_design_abstract.html"><strong aria-hidden="true">2.</strong> Layer2: 设计抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer2_design_abstract/4_programming_paradigm/4_programming_paradigm.html"><strong aria-hidden="true">2.1.</strong> 编程范式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer2_design_abstract/4_programming_paradigm/fp.html"><strong aria-hidden="true">2.1.1.</strong> 函数式编程</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/4_programming_paradigm/oop.html"><strong aria-hidden="true">2.1.2.</strong> 面向对象编程</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/4_programming_paradigm/gp.html"><strong aria-hidden="true">2.1.3.</strong> 泛型编程</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/5_design_pattern/5_design_pattern.html"><strong aria-hidden="true">2.2.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/6_module_manage/6_module_manage.html"><strong aria-hidden="true">2.3.</strong> 模块管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer2_design_abstract/6_module_manage/module_relate.html"><strong aria-hidden="true">2.3.1.</strong> 模块使用</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/6_module_manage/cargo_project_lifetime.html"><strong aria-hidden="true">2.3.2.</strong> Cargo与项目生命周期</a></li><li class="chapter-item expanded "><a href="../../layer2_design_abstract/6_module_manage/rust_plugins.html"><strong aria-hidden="true">2.3.3.</strong> Rust扩展工具</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../layer3_task_abstract/layer3_task_abstract.html"><strong aria-hidden="true">3.</strong> Layer3: 任务抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer3_task_abstract/7_concurrency/7_concurrency.html"><strong aria-hidden="true">3.1.</strong> 并发编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer3_task_abstract/7_concurrency/io_models.html"><strong aria-hidden="true">3.1.1.</strong> 系统IO模型</a></li><li class="chapter-item expanded "><a href="../../layer3_task_abstract/7_concurrency/1_multi_models/multi_models.html"><strong aria-hidden="true">3.1.2.</strong> 多线程模型</a></li><li class="chapter-item expanded "><a href="../../layer3_task_abstract/7_concurrency/2_async_models/async_models.html"><strong aria-hidden="true">3.1.3.</strong> 异步模型</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer3_task_abstract/8_meta_programming/8_meta_programming.html"><strong aria-hidden="true">3.2.</strong> 元编程</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer4_protocol_abstract/layer4_protocol_abstract.html"><strong aria-hidden="true">4.</strong> Layer4: 协议抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer4_protocol_abstract/9_multilingual_programming/9_multilingual_programming.html"><strong aria-hidden="true">4.1.</strong> 跨语言编程</a></li><li class="chapter-item expanded "><a href="../../layer4_protocol_abstract/10_computer_network/10_computer_network.html"><strong aria-hidden="true">4.2.</strong> 计算机网络</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/layer5_ecosystem.html"><strong aria-hidden="true">5.</strong> Layer5: 生态环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/learning_resource.html"><strong aria-hidden="true">5.1.</strong> 学习资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/1_books/books.html"><strong aria-hidden="true">5.1.1.</strong> 书籍整理</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/2_courses/courses.html"><strong aria-hidden="true">5.1.2.</strong> 线上课程</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/3_blogs/blogs.html"><strong aria-hidden="true">5.1.3.</strong> 博客文章</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/4_videos/videos.html"><strong aria-hidden="true">5.1.4.</strong> 在线视频</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/1_learning_resource/5_projects/projects.html"><strong aria-hidden="true">5.1.5.</strong> 开源项目</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/2_lang_update/lang_update.html"><strong aria-hidden="true">5.2.</strong> 官方动态</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/3_community/community.html"><strong aria-hidden="true">5.3.</strong> 社区热点</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/4_academic/academic.html"><strong aria-hidden="true">5.4.</strong> 学术讨论</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/open_source.html"><strong aria-hidden="true">5.5.</strong> 开源观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/underlying.html"><strong aria-hidden="true">5.5.1.</strong> 底层开发</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/command/command.html"><strong aria-hidden="true">5.5.1.1.</strong> 命令行工具</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/data/data.html"><strong aria-hidden="true">5.5.1.2.</strong> 数据处理</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/embedded/embedded.html"><strong aria-hidden="true">5.5.1.3.</strong> 嵌入式</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/os/os.html"><strong aria-hidden="true">5.5.1.4.</strong> 系统开发</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/1_underlying/performance/performance.html"><strong aria-hidden="true">5.5.1.5.</strong> 性能工具</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/network.html"><strong aria-hidden="true">5.5.2.</strong> 网络相关</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/cloud/cloud.html"><strong aria-hidden="true">5.5.2.1.</strong> 云原生</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/frontend/frontend.html"><strong aria-hidden="true">5.5.2.2.</strong> 前端基建</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/network/network.html"><strong aria-hidden="true">5.5.2.3.</strong> 网络基建</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/2_network/web/web.html"><strong aria-hidden="true">5.5.2.4.</strong> web开发</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/3_media/media.html"><strong aria-hidden="true">5.5.3.</strong> 多媒体</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/3_media/av/av.html"><strong aria-hidden="true">5.5.3.1.</strong> 音视频处理</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/3_media/game/game.html"><strong aria-hidden="true">5.5.3.2.</strong> 游戏开发</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/4_other/other.html"><strong aria-hidden="true">5.5.4.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/4_other/lang-with-rust/lang_with_rust.html"><strong aria-hidden="true">5.5.4.1.</strong> Rust与其他语言</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/4_other/scientific-research/scientific_research.html"><strong aria-hidden="true">5.5.4.2.</strong> 科学艺术研究</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/5_open_source/4_other/tools/tools.html"><strong aria-hidden="true">5.5.4.3.</strong> 其他工具</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/6_security/security.html"><strong aria-hidden="true">5.6.</strong> 安全参考</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/7_business/business.html"><strong aria-hidden="true">5.7.</strong> 商业观察</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../layer5_ecosystem/7_business/blockchain/blockchain.html"><strong aria-hidden="true">5.7.1.</strong> 区块链</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/7_business/practices/practices.html"><strong aria-hidden="true">5.7.2.</strong> 生产实践</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/7_business/products/products.html"><strong aria-hidden="true">5.7.3.</strong> 优秀产品</a></li></ol></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/8_libs/libs.html"><strong aria-hidden="true">5.8.</strong> 基础库</a></li><li class="chapter-item expanded "><a href="../../layer5_ecosystem/9_frameworks/frameworks.html"><strong aria-hidden="true">5.9.</strong> 框架引擎</a></li></ol></li><li class="chapter-item expanded "><a href="../../checklist.html">Checklist</a></li></ol>
    </div>
    <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
</nav>

<div id="page-wrapper" class="page-wrapper">

    <div class="page">
        <div id="menu-bar-hover-placeholder"></div>
        <div id="menu-bar" class="menu-bar sticky bordered">
            <div class="left-buttons">
                <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                    <i class="fa fa-bars"></i>
                </button>
                <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                    <i class="fa fa-paint-brush"></i>
                </button>
                <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                    <li role="none">
                        <button role="menuitem" class="theme" id="light">Light</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="rust">Rust (default)</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="coal">Coal</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="navy">Navy</button>
                    </li>
                    <li role="none">
                        <button role="menuitem" class="theme" id="ayu">Ayu</button>
                    </li>
                </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
            </div>

            <h1 class="menu-title">Programming Anatomy In Rust</h1>
            <h3 class="menu-bar"> -- 练武不练功 到头一场空 -- </h3>
            <div class="right-buttons">
                    <a href="../../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>
                    <a href="https://github.com/KuanHsiaoKuo/programming_anatomy_in_rust.git" title="Git repository" aria-label="Git repository">
                        <i id="git-repository-button" class="fa fa-rust"></i>
                    </a>
            </div>
        </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar"
                           placeholder="Search this book ..." aria-controls="searchresults-outer"
                           aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
        <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
        <script type="text/javascript">
            document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
            document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
            Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
            });
        </script>

        <div id="content" class="content">
            <main>

                <!-- Page table of contents -->
                <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                </div>
                <h1 id="所有权三件套所有权借用与生命周期"><a class="header" href="#所有权三件套所有权借用与生命周期">所有权三件套：所有权、借用与生命周期</a></h1>
<p><img src="https://raw.githubusercontent.com/KuanHsiaoKuo/writing_materials/main/imgs/Ownership.jpeg" alt="Ownership" /></p>
<!--ts-->
<ul>
<li><a href="#%E6%89%80%E6%9C%89%E6%9D%83%E4%B8%89%E4%BB%B6%E5%A5%97%E6%89%80%E6%9C%89%E6%9D%83%E5%80%9F%E7%94%A8%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">所有权三件套：所有权、借用与生命周期</a>
<ul>
<li><a href="#%E7%BB%BC%E8%BF%B0">综述</a></li>
<li><a href="#%E6%89%80%E6%9C%89%E6%9D%83">所有权</a>
<ul>
<li><a href="#%E8%B5%84%E6%BA%90%E6%89%80%E6%9C%89%E8%80%85">资源所有者</a></li>
<li><a href="#%E8%B5%84%E6%BA%90%E6%89%80%E6%9C%89%E8%80%85%E8%B4%9F%E8%B4%A3%E9%87%8A%E6%94%BE">资源所有者负责释放</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E9%9D%A0gc%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%84%E7%90%86">动态语言靠GC在运行期处理</a></li>
<li><a href="#%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80%E5%9C%A8%E7%BC%96%E8%AF%91%E6%9C%9F%E8%A7%84%E5%AE%9A">静态语言在编译期规定</a></li>
</ul>
</li>
<li><a href="#rust%E7%9A%84%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99">Rust的所有权规则</a></li>
<li><a href="#%E6%8F%A3%E6%91%A9%E6%89%80%E6%9C%89%E6%9D%83%E5%90%AB%E4%B9%89">揣摩所有权含义</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%89%80%E6%9C%89%E6%9D%83%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0">作用域：所有权考虑因素</a>
<ul>
<li><a href="#%E5%A4%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E6%83%85%E5%86%B5%E5%88%86%E6%9E%90">多作用域的情况分析</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF%E6%8E%A8%E6%96%AD%E6%89%80%E6%9C%89%E6%9D%83%E6%97%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7">作用域是推断所有权时的一个重要属性</a></li>
</ul>
</li>
<li><a href="#%E5%BC%95%E5%85%A5%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89">引入移动和复制语义</a>
<ul>
<li><a href="#%E8%AF%AD%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D">语义是什么意思</a></li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E5%8F%98%E9%87%8F%E8%AE%BF%E9%97%AE%E6%88%96%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E6%97%B6%E9%BB%98%E8%AE%A4">移动语义：变量访问或重新分配时默认</a></li>
<li><a href="#%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89">复制语义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8copy%E7%89%B9%E5%BE%81%E6%9B%B4%E6%94%B9%E8%AF%AD%E4%B9%89">使用Copy特征更改语义</a></li>
<li><a href="#copy-%E7%89%B9%E5%BE%81%E4%BE%9D%E8%B5%96%E4%BA%8Eclone-%E7%89%B9%E5%BE%81">Copy 特征依赖于Clone 特征</a></li>
</ul>
</li>
<li><a href="#%E5%8C%BA%E5%88%AB%E4%B8%80%E4%B8%8Bcopy%E4%B8%8Eclone-trait">区别一下Copy与Clone trait</a>
<ul>
<li><a href="#copy">Copy</a></li>
<li><a href="#clone">Clone</a></li>
</ul>
</li>
<li><a href="#copy%E4%B8%8Eclone%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">Copy与Clone的使用原则</a>
<ul>
<li><a href="#%E4%BD%95%E6%97%B6%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0-copy">何时在类型上实现 Copy</a></li>
<li><a href="#%E4%BD%95%E6%97%B6%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0-clone">何时在类型上实现 Clone。</a></li>
</ul>
</li>
<li><a href="#%E6%89%80%E6%9C%89%E6%9D%83%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">所有权使用场景</a>
<ul>
<li><a href="#let%E7%BB%91%E5%AE%9A%E7%A4%BA%E4%BE%8B">let绑定示例</a></li>
<li><a href="#%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E5%87%BD%E6%95%B0">将参数传递给函数</a></li>
<li><a href="#match%E8%A1%A8%E8%BE%BE%E5%BC%8F">match表达式</a></li>
<li><a href="#impl%E4%BB%A3%E7%A0%81%E5%9D%97">impl代码块</a></li>
<li><a href="#%E9%97%AD%E5%8C%85">闭包</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%80%9F%E7%94%A8-%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E8%A7%84%E9%81%BF%E6%89%80%E6%9C%89%E6%9D%83%E8%A7%84%E5%88%99%E9%99%90%E5%88%B6">借用: 通过引用规避所有权规则限制</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%80%9F%E7%94%A8%E5%BC%95%E7%94%A8">为何需要借用/引用</a></li>
<li><a href="#%E5%80%9F%E7%94%A8-or-%E5%BC%95%E7%94%A8">借用 or 引用？</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E5%80%9F%E7%94%A8%E6%96%B9%E5%BC%8F">两种借用方式</a>
<ul>
<li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8">不可变借用：&amp;</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%80%9F%E7%94%A8mut">可变借用：&amp;mut</a></li>
</ul>
</li>
<li><a href="#%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99">借用规则</a></li>
<li><a href="#%E5%A6%82%E6%9E%9C%E8%BF%9D%E5%8F%8D%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99">如果违反借用规则</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%80%9F%E7%94%A8">函数中的借用</a></li>
<li><a href="#%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%80%9F%E7%94%A8">匹配中的借用</a></li>
<li><a href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8">从函数返回引用：</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99%E7%9A%84%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B">基于借用规则的方法类型</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%88%E5%AF%B9%E5%BC%95%E7%94%A8%E9%99%84%E5%8A%A0%E7%9A%84%E4%BF%A1%E6%81%AF">生命周期：针对引用附加的信息</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%BA%90">参考资源</a></li>
</ul>
</li>
</ul>
<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Jun 15 07:56:44 UTC 2022 -->
<!--te-->
<h2 id="综述"><a class="header" href="#综述">综述</a></h2>
<pre><code class="language-text">┌───────────────────────────────────┐
│                                   │
│                                   │
│         .───────.       ┌──────┐  │
│       ,'         `.     │Borrow│  │
│     ,'             `.   └──────┘  │
│    ;   ┌─────────┐   :            │
│    │   │OwnerShip│   │            │
│    │   └─────────┘   │            │
│    :     ┌─────┐     ; ┌────────┐ │
│     ╲    │Scope│    ╱  │Lifetime│ │
│      `.  └─────┘  ,'   └────────┘ │
│        `.       ,'                │
│          `─────'                  │
│                                   │
│                                   │
└───────────────────────────────────┘
</code></pre>
<p>所有权、作用域、借用与生命周期是 Rust 的内存安全及其零成本抽象原则的核心。 它们让 Rust 能够在编译期检测程序中内存安全违规,在离开作用域时自动释放相关资源等情况。
所有权有点类似核心原则,而借用和生命周期是对语言类型系统的扩展。在代码的不同上下文中加强或有时放松所有权原则,可确保编译期内存管理正常运作。</p>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<h3 id="资源所有者"><a class="header" href="#资源所有者">资源所有者</a></h3>
<p>程序中资源的真正所有者的概念因语言而异。这里的含义是通过资源, 主要包含下列内容：</p>
<ol>
<li>共同引用在堆或堆栈上保存值的任何变量</li>
<li>或者是包含打开文件描述符、数据库连接套接字、网络套接字及类似内容的变量。</li>
</ol>
<p>从它们存在到完成程序调用及其之后的时间,都会占用一些内存。</p>
<h3 id="资源所有者负责释放"><a class="header" href="#资源所有者负责释放">资源所有者负责释放</a></h3>
<blockquote>
<p>资源所有者的一个重要职责就是明智地释放它们使用的内存,因为如果无法在适当的位置和时间执行取消内存分配,就可能导致内存泄漏。</p>
</blockquote>
<h4 id="动态语言靠gc在运行期处理"><a class="header" href="#动态语言靠gc在运行期处理">动态语言靠GC在运行期处理</a></h4>
<p>在使用 Python 等动态语言编程时,可以将多个所有者或别名添加到 list 对象中,从而使用执行该对象的众多变量之一添加或删除 list 中的项目。变量不需要关心如何释放对象使用过的内存,因为 GC
会处理这些事情,并且一旦指向对象的所有引用都消失,GC 就会释放相关的内存。</p>
<h4 id="静态语言在编译期规定"><a class="header" href="#静态语言在编译期规定">静态语言在编译期规定</a></h4>
<p>对于 C/C++/Golang之类的编译语言,在智能指针出现之前,程序库对代码使用完毕的相关资源 API 的调用方或者被调用方是否负责释放内存有明确的规定。存在这些规则是因为编译器不会在这些语言中强制限定所有权。在
C++中不使用智能指针仍然有可能出现问题。在C++中,存在多个变量指向堆上的某个值是完全没问题的(尽管我们不建议这么做) ,这就是所谓的别名。由于具有指向资源的多个指针或别名的灵活性,程序员会遇到各种各样的问题,其中之一就是
C++中的迭代器失效问题。</p>
<blockquote>
<p>具体而言,当给定作用域中资源的其他不可变别名相对存在至少一个可变别名时,就会出现问题</p>
</blockquote>
<h3 id="rust的所有权规则"><a class="header" href="#rust的所有权规则">Rust的所有权规则</a></h3>
<p>Rust 试图为程序中值的所有权设定适当的语义。Rust 的所有权规则遵循以下原则。</p>
<ul>
<li>使用 let 语句创建值或资源,并将其分配给变量时,该变量将成为资源的所有者。</li>
<li>当值从一个变量重新分配给另一个变量时, 值的所有权将转移至另一个变量, 原来的变量将失效以便另作他用。</li>
<li>值和变量在其作用域的末尾会被清理、释放。</li>
</ul>
<h3 id="揣摩所有权含义"><a class="header" href="#揣摩所有权含义">揣摩所有权含义</a></h3>
<p>需要注意的是,Rust 中的值只有一个所有者,即创建它们的变量。其理念很简单,但是它的含义值得揣摩：</p>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_basics.rs

#[derive(Debug)]
struct Foo(u32);

fn main() {
    // 根据所有权规则, foo 是 Foo 实例的所有者
    let foo = Foo(2048);
    /*
        bar 成为Foo 实例的新所有者, 而旧的 foo 是一个废弃变量.
        经过此变动之后不能在其他任何地方使用
    */
    let bar = foo; // value moved here
    /*
        每当我们将变量分配给某个其他变量或从变量读取数据时,Rust 会默认移动变量指向的值。
        所有权规则可以防止你通过多个访问点来修改值,这可能导致访问已被释放的变量.
        即使在单线程上下文中,使用允许多个值的可变别名的语言也是如此
    */
    println!(&quot;Foo is {:?}&quot;, foo);  // value borrowed here after move
    println!(&quot;Bar is {:?}&quot;, bar);
}
</code></pre></pre>
<p>每当我们将变量分配给某个其他变量或从变量读取数据时,Rust 会默认移动变量指向的值。所有权规则可以防止你通过多个访问点来修改值,这可能导致访问已被释放的变量,即使在单线程上下文中,使用允许多个值的可变别名的语言也是如此</p>
<h3 id="作用域所有权考虑因素"><a class="header" href="#作用域所有权考虑因素">作用域：所有权考虑因素</a></h3>
<blockquote>
<p>为了分析某个值何时超出作用域,所有权规则还会考虑变量的作用域</p>
</blockquote>
<ol>
<li>在 Rust 的背景下, 所有权与作用域协同工作。</li>
<li>因此,作用域只不过是变量和值存在的环境。你声明的每个变量都与作用域有关。</li>
<li>代码中的作用域是由一对花括号表示的。无论何时使用块表达式都会创建一个作用域,即任何以花括号开头和结尾的表达式。</li>
<li>此外,作用域支持互相嵌套,并且可以在子作用域中访问父作用域的元素,但反过来不行</li>
</ol>
<h4 id="多作用域的情况分析"><a class="header" href="#多作用域的情况分析">多作用域的情况分析</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// scopes.rs

/*
由于函数可以创建新的作用域, 因此 main 函数引入了根级别作用域 0,
在代码中定义为 level_0_str
*/
fn main() {
    let level_0_str = String::from(&quot;foo&quot;);
    /*
        在 0 级作用域中, 创建了一个新的作用域,即作用域 1,
        并且带有一个花括号,其中包含变量level_1_number。
    */
    {
        let level_1_number = 9;
        /*
            在 1 级作用域中, 创建了一个块表达式, 它成为 2 级作用域。
            在其中, 声明了另一个变量 level_2_vector,
            以便可以将 level_1_number 添加到其中,
            而level_1_number 来自其父级作用域 1
        */
        {
            let mut level_2_vector = vec![1, 2, 3];
            level_2_vector.push(level_1_number);    // can access
        } // level_2_vector goes out of scope here 

        level_2_vector.push(4);    // no longer exists
    } // level_1_number goes out of scope here
} // level_0_str goes out of scope here
</code></pre></pre>
<h4 id="作用域是推断所有权时的一个重要属性"><a class="header" href="#作用域是推断所有权时的一个重要属性">作用域是推断所有权时的一个重要属性</a></h4>
<blockquote>
<p>作用域还会被用来推断后续介绍的借用和生命周期。</p>
</blockquote>
<ol>
<li>当作用域结束时,拥有值的任何变量都会运行相关代码以取消分配该值,并且其自身在作用域之外是无效的。</li>
<li>特别是对在堆上分配的值,drop 方法会被放在作用域结束标记}之前调用。</li>
<li>这类似于在 C 语言中调用 free 函数,但这里是隐式的, 并且可以避免程序员忘记释放值。</li>
<li>drop 方法来自 Drop 特征,它是为 Rust 中大部分堆分配类型实现的,可以轻松地自动释放资源。</li>
</ol>
<h3 id="引入移动和复制语义"><a class="header" href="#引入移动和复制语义">引入移动和复制语义</a></h3>
<blockquote>
<p>结合作用域判断一下下列代码是否正确</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_primitives.rs

fn main() {
    let foo = 4623;
    /*
        4623 的所有权不会从 foo 转移到 bar,但 bar 会获得4623 的单独副本。
        看起来基元类型在 Rust 中会被特殊对待,它们会被移动而不是复制。
        这意味着根据我们在 Rust 中使用的类型,存在不同的所有权语义,这将引入移动和复制语义的概念
    */
    let bar = foo;
    println!(&quot;{:?} {:?}&quot;, foo, bar); 
}
</code></pre></pre>
<h4 id="语义是什么意思"><a class="header" href="#语义是什么意思">语义是什么意思</a></h4>
<p>以移动语义为例，在 Rust
中,变量绑定默认具有移动语义。但这究竟意味着什么?要理解这一点,我们需要考虑如何在程序中使用变量。我们创建值或资源并将它们分配给变量,以便在程序中可以方便地引用它们。这些变量是指向值所在内存地址的名称。现在,诸如读取、赋值、添加及将它们传递给函数等对变量的操作,在访问变量指向值的方式上可能具有不同的语义或含义。在静态类型语言中,这些语义大致分为移动语义和复制语义。</p>
<h4 id="移动语义变量访问或重新分配时默认"><a class="header" href="#移动语义变量访问或重新分配时默认">移动语义：变量访问或重新分配时默认</a></h4>
<blockquote>
<p>通过变量访问或重新分配给变量时移动到接收项的值表示移动语义。</p>
</blockquote>
<p>由于Rust 的仿射类型系统,它默认会采用移动语义。仿射类型系统的一个突出特点是值或资源只能使用一次,而 Rust 通过所有权规则展示此属性。</p>
<h4 id="复制语义"><a class="header" href="#复制语义">复制语义</a></h4>
<p>默认情况下,通过变量分配或访问,以及从函数返回时复制的值(例如按位复制)具有复制语义。这意味着该值可以使用任意次数,每个值都是全新的。</p>
<h4 id="使用copy特征更改语义"><a class="header" href="#使用copy特征更改语义">使用Copy特征更改语义</a></h4>
<p>Rust 中的移动语义有时会受到限制。幸运的是,通过实现 Copy 特征可以更改类型的行为以遵循复制语义。基元和其他仅适用于堆栈的数据类型在默认情况下实现了上述特征,这也是前面的基元代码能够正常工作的原因</p>
<pre><pre class="playground"><code class="language-rust  editable">// making_copy_types.rs

#[derive(Copy, Debug)]  // the trait `Clone` is not implemented for `Dummy`
struct Dummy;

fn main() {
    let a = Dummy;
    let b = a;
    println!(&quot;{:?}&quot;, a);
    println!(&quot;{:?}&quot;, b);
}
</code></pre></pre>
<h4 id="copy-特征依赖于clone-特征"><a class="header" href="#copy-特征依赖于clone-特征">Copy 特征依赖于Clone 特征</a></h4>
<blockquote>
<p>Clone 是 Copy 的父级特征, 任何实现 Copy 特征的类型必须实现 Clone。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// making_copy_types.rs

// 可以在派生注释中的 Copy 旁边添加 Clone 特征来让该示例通过编译
#[derive(Copy, Clone, Debug)]
struct Dummy;

fn main() {
    let a = Dummy;
    let b = a;
    println!(&quot;{:?}&quot;, a);
    println!(&quot;{:?}&quot;, b);
}
</code></pre></pre>
<h3 id="区别一下copy与clone-trait"><a class="header" href="#区别一下copy与clone-trait">区别一下Copy与Clone trait</a></h3>
<blockquote>
<p>Copy 和 Clone 特征传达了在代码中使用类型时如何进行复制的原理。</p>
</blockquote>
<table><thead><tr><th align="center">特征</th><th align="center">复制方式</th><th align="center">复制内容</th><th align="center">使用场景</th></tr></thead><tbody>
<tr><td align="center">Copy</td><td align="center">隐式，自动化特征</td><td align="center">堆栈</td><td align="center">可以在堆栈上单独表示的小型值</td></tr>
<tr><td align="center">Clone</td><td align="center">显式调用clone</td><td align="center">堆+栈</td><td align="center">在堆上还包含一个值作为其表示的一部分</td></tr>
</tbody></table>
<h4 id="copy"><a class="header" href="#copy">Copy</a></h4>
<ol>
<li>Copy 特征通常用于可以在堆栈上完全表示的类型, 也就是说它们自身没有任何部分位于堆上。</li>
<li>如果出现了这种情况,那么 Copy 将是开销很大的操作,因为它必须从堆中复制值。这直接影响到赋值运算符的工作方式。</li>
<li>如果类型实现了 Copy,则从一个变量到另一个变量的赋值操作将隐式复制数据。</li>
</ol>
<h4 id="clone"><a class="header" href="#clone">Clone</a></h4>
<p>Clone 特征用于显式复制, 并附带 clone 方法, 类型可以实现该方法以获取自身的副本</p>
<p>Clone 有一个名为 clone 的方法,用于获取接收者的不可变引用,即&amp;self,并返回相同类型的新值。用户自定义类型或任何需要提供能够复制自身的包装器类型,应通过实现clone 方法来实现 Clone 特征</p>
<blockquote>
<p>一个通过 Clone 特征复制类型的示例</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// explicit_copy.rs

// 在 derive 属性中添加了一个 Clone 特征。
#[derive(Clone, Debug)]
struct Dummy {
    items: u32,
}

fn main() {
    let a = Dummy { items: 54 };
    // 有了Clone, 我们就可以在 a 上调用 clone 方法来获得它的新副本
    let b = a.clone();
    println!(&quot;a: {:?}, b: {:?}&quot;, a, b);
}
</code></pre></pre>
<h3 id="copy与clone的使用原则"><a class="header" href="#copy与clone的使用原则">Copy与Clone的使用原则</a></h3>
<h4 id="何时在类型上实现-copy"><a class="header" href="#何时在类型上实现-copy">何时在类型上实现 Copy</a></h4>
<blockquote>
<p>可以在堆栈上单独表示的小型值如下所示。</p>
</blockquote>
<ul>
<li>如果类型仅依赖于在其上实现了 Copy 特征的其他类型, 则 Copy 特征是为其隐式实现的。</li>
<li>Copy 特征隐式影响赋值运算符的工作方式。 使用 Copy 特征构建自定义外部可见类型需要考虑它是否会对赋值运算符产生影响。 如果在开发的早期阶段,
你的类型是Copy,后续将它移除之后则会影响使用该类型进行赋值的所有环节。你可以通过这种方式轻松地破坏 API。</li>
</ul>
<h4 id="何时在类型上实现-clone"><a class="header" href="#何时在类型上实现-clone">何时在类型上实现 Clone。</a></h4>
<ul>
<li>Clone 特征只是声明一个 clone 方法,需要被显式调用。</li>
<li>如果你的类型在堆上还包含一个值作为其表示的一部分, 那么可选择实现 Clone 特征,这也需要向复制堆数据的用户明确表示。</li>
<li>如果要实现智能指针类型(例如引用计数类型) ,那么应该在类型上实现 Clone 特征,以便仅复制堆栈上的指针。</li>
</ul>
<h3 id="所有权使用场景"><a class="header" href="#所有权使用场景">所有权使用场景</a></h3>
<blockquote>
<p>重要的是我们能够识别它和编译器给出的错误提示信息</p>
</blockquote>
<h4 id="let绑定示例"><a class="header" href="#let绑定示例">let绑定示例</a></h4>
<h4 id="将参数传递给函数"><a class="header" href="#将参数传递给函数">将参数传递给函数</a></h4>
<blockquote>
<p>如果将参数传递给函数,那么相同的所有权规则也同样有效</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_functions.rs

fn take_the_n(n: u8) {}

fn take_the_s(s: String) {}

fn main() {
    let n = 5;
    let s = String::from(&quot;string&quot;);
    // take_the_n 函数能够正常工作,是因为 u8(基元类型)实现了 Copy 特征
    take_the_n(n);
    /*
        String 并没有实现 Copy 特征,因此值的所有权在 take_the_s 函数中会发生移动。
        当函数返回时,相关值的作用域也随之结束,并且会在 s 上调用 drop 方法,
        这会释放 s 所使用的堆内存。
        因此,在函数调用结束后 s 将失效
        使用clone即可通过编译：take_the_s(s.clone())
    */
    take_the_s(s);

    println!(&quot;n is {}&quot;, n);
    println!(&quot;s is {}&quot;, s);
}
</code></pre></pre>
<blockquote>
<p>如果我们只需要变量 s 的读取访问权限,那么可以让该代码正常工作的另一种方法是将字符串 s 传递回 main 函数</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_functions_back.rs

fn take_the_n(n: u8) {}

// 添加了一个返回类型
fn take_the_s(s: String) -&gt; String {
    println!(&quot;inside function: {}&quot;, s);
    // 并将传递的字符串返回给调用者
    s
}

fn main() {
    let n = 5;
    let s = String::from(&quot;string&quot;);

    take_the_n(n);
    let s = take_the_s(s);

    println!(&quot;n is {}&quot;, n);
    println!(&quot;s is {}&quot;, s);
}
</code></pre></pre>
<h4 id="match表达式"><a class="header" href="#match表达式">match表达式</a></h4>
<blockquote>
<p>在 match 表达式中,移动类型默认也会被移动</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_match.rs

#[derive(Debug)]
enum Food {
    Cake,
    Pizza,
    Salad,
}

#[derive(Debug)]
struct Bag {
    food: Food,
}

fn main() {
    let bag = Bag { food: Food::Cake };
    match bag.food {
        Food::Cake =&gt; println!(&quot;I got cake&quot;),
        a =&gt; println!(&quot;I got {:?}&quot;, a) // value partially moved here
    }

    println!(&quot;{:?}&quot;, bag); // value borrowed here after partial move
}
</code></pre></pre>
<h4 id="impl代码块"><a class="header" href="#impl代码块">impl代码块</a></h4>
<blockquote>
<p>impl 代码块中,任何以 self 作为第一个参数的方法都将获取调用该方法的值的所有权。这意味着对值调用方法后,你无法再次使用该值</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_methods.rs

struct Item(u32);

impl Item {
    fn new() -&gt; Self {
        Item(1024)
    }
    /*
        以 self 作为第 1 个参数的实例方法。
        在调用之后, 它将在方法内移动, 并在函数作用域结束时被释放。
        后续我们将不能再使用它
    */
    fn take_item(self) {
        // does nothing
    }
}

fn main() {
    let it = Item::new(); // move occurs because `it` has type `Item`, which does not implement the `Copy` trait
    it.take_item(); // `it` moved due to this method call
    println!(&quot;{}&quot;, it.0); // value borrowed here after move
}
</code></pre></pre>
<h4 id="闭包"><a class="header" href="#闭包">闭包</a></h4>
<blockquote>
<p>闭包接收不同的值取决于在其内部使用变量的方式</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_closures.rs

#[derive(Debug)]
struct Foo;

fn main() {
    let a = Foo;

    /*
        Foo 的所有权在闭包中已经默认移动到了 b,
        用户将无法再次访问 a。
    */
    // let closure = move || {
    let closure = || {
        let b = a;
    };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<h2 id="借用-通过引用规避所有权规则限制"><a class="header" href="#借用-通过引用规避所有权规则限制">借用: 通过引用规避所有权规则限制</a></h2>
<h3 id="为何需要借用引用"><a class="header" href="#为何需要借用引用">为何需要借用/引用</a></h3>
<p>Rust的所有权规则非常严格, 因为它只允许我们使用类型一次。 如果函数只需要对值的读取访问权限,那么我们需要再次从函数返回值,或者在它传递给函数之前复制它。如果类型没有实现 Clone 特征,那么后者可能无法实现其目的。
复制类型看起来似乎很容易绕过所有权规则,但是由于 Clone 总是复制类型,可能会调用内存分配器 API,这是一种涉及系统调用,并且开销高昂的操作,因此它无法满足零成本抽象承诺的所有要点。 随着移动语义和所有权规则的实施,在 Rust
中编写程序很快就会变得困难重重。幸运的是,我们引入了借用和引用类型的概念,它们放宽了规则所施加的限制,但仍然能够在编译期确保兼容所有权规则。</p>
<p>借用的概念是规避所有权规则的限制。进行借用时,你不会获取值的所有权,而是根据需要提供数据。这是通过借用值,即获取值的引用来实现的。为了借用值,我们需要将运算符&amp;放在变量之前,&amp;表示指向变量的地址。</p>
<h3 id="借用-or-引用"><a class="header" href="#借用-or-引用">借用 or 引用？</a></h3>
<h3 id="两种借用方式"><a class="header" href="#两种借用方式">两种借用方式</a></h3>
<h4 id="不可变借用"><a class="header" href="#不可变借用">不可变借用：&amp;</a></h4>
<blockquote>
<p>当我们在类型之前使用运算符&amp;时,就会创建一个不可变借用。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_basics.rs

#[derive(Debug)]
struct Foo;

fn main() {
    let foo = Foo;
    /*
        注意变量 foo 之前的&amp;。我们借用 foo 并将借用结果分配给 bar。
        bar 的类型为&amp;Foo, 这是一种引用类型。
        作为一个不可变借用,我们不能通过 bar 改变 Foo 中的值
     */
    let bar = &amp;foo;
    println!(&quot;Foo is {:?}&quot;, foo);
    println!(&quot;Bar is {:?}&quot;, bar);
}
</code></pre></pre>
<h4 id="可变借用mut"><a class="header" href="#可变借用mut">可变借用：&amp;mut</a></h4>
<blockquote>
<p>可以使用&amp;mut 运算符对某个值进行可变借用。 通过可变借用, 你可以改变该值。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust  editable">// mutable_borrow.rs

fn main() {
    // 可变借用需要可变变量，所以这里会报错，可以加上mut
    let a = String::from(&quot;Owned string&quot;);
    /*
        用&amp;mut a 创建了一个该值的可变借用。
        这并没有将 a 移动到 b
        只是可变地对它借用。
    */
    let a_ref = &amp;mut a;
    a_ref.push('!');
}
</code></pre></pre>
<blockquote>
<p>可变借用可以改变值,但是不能销毁该值,因为它不是所有者。
如果a 在借用它的代码行之前被销毁,则借用失效</p>
</blockquote>
<p><a id="Note-1"></a>Note-1</p>
<pre><pre class="playground"><code class="language-rust  editable">// exclusive_borrow.rs

fn main() {
    let mut a = String::from(&quot;Owned string&quot;);
    let a_ref = &amp;mut a;
    a_ref.push('!');
    println!(&quot;{}&quot;, a);
}
</code></pre></pre>
<pre><code class="language-admonish bug">(存疑🤨，待修正🤔️)
</code></pre>
<h3 id="借用规则"><a class="header" href="#借用规则">借用规则</a></h3>
<blockquote>
<p>通过引用来维护单一的所有权语义。这些规则如下所示</p>
</blockquote>
<ol>
<li>一个引用的生命周期可能不会超过其被引用的时间。 这是显而易见的, 因为如果它的生命周期超过其被借用的时间,那么它将指向一个垃圾值(被销毁的值) 。</li>
<li>如果存在一个值的可变借用,那么不允许其他引用(可变借用或不可变借用)在该作用域下指向相同的值。可变借用是一种独占性借用。</li>
<li>如果不存在指向某些东西的可变借用, 那么在该作用域下允许出现对同一值的任意数量的不可变借用</li>
</ol>
<h3 id="如果违反借用规则"><a class="header" href="#如果违反借用规则">如果违反借用规则</a></h3>
<h4 id="函数中的借用"><a class="header" href="#函数中的借用">函数中的借用</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// borrowing_functions.rs

// 接收可变借用作为参数
fn take_the_n(n: &amp;mut u8) {
    *n += 2;
}

fn take_the_s(s: &amp;mut String) {
    s.push_str(&quot;ing&quot;);
}

fn main() {
    // 变量绑定必须是可变
    let mut n = 5;
    let mut s = String::from(&quot;Borrow&quot;);
    // 因为函数内做了修改，所以调用时也需要使用可变借用
    take_the_n(&amp;mut n);
    take_the_s(&amp;mut s);

    println!(&quot;n changed to {}&quot;, n);
    println!(&quot;s changed to {}&quot;, s);
}
</code></pre></pre>
<h4 id="匹配中的借用"><a class="header" href="#匹配中的借用">匹配中的借用</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// ownership_match.rs

#[derive(Debug)]
enum Food {
    Cake,
    Pizza,
    Salad
}

#[derive(Debug)]
struct Bag {
    food: Food
}

fn main() {
    let bag = Bag { food: Food::Cake };
    match bag.food {
        Food::Cake =&gt; println!(&quot;I got cake&quot;),
        // 以 ref 作为前缀。
        // 关键字 ref 可以通过引用来匹配元素,而不是根据值来捕获它们。
        ref a =&gt; println!(&quot;I got {:?}&quot;, a)
    }
    
    println!(&quot;{:?}&quot;, bag);
}
</code></pre></pre>
<h4 id="从函数返回引用"><a class="header" href="#从函数返回引用">从函数返回引用：</a></h4>
<pre><pre class="playground"><code class="language-rust  editable">// return_func_ref.rs

fn get_a_borrowed_value() -&gt; &amp;u8 { // expected named lifetime parameter
    let x = 1;
    &amp;x
}

fn main() {
    let value = get_a_borrowed_value();
}
</code></pre></pre>
<h3 id="基于借用规则的方法类型"><a class="header" href="#基于借用规则的方法类型">基于借用规则的方法类型</a></h3>
<blockquote>
<p>借用规则还规定了如何定义类型的固有方法和特征的实例方法。以下是它们接收实例的方式,并且是根据限制由少到多排列的。</p>
</blockquote>
<ul>
<li>&amp;self 方法:这些方法只对其成员具有不可变的访问权限。</li>
<li>&amp;mut self 方法:这些方法能够可变地借用 self 实例。</li>
<li>self 方法:这些方法拥有调用它的实例的所有权,并且类型在后续调用时将失效。</li>
</ul>
<p>对于自定义类型,相同的借用规则也适用于其作用域成员。</p>
<h2 id="生命周期针对引用附加的信息"><a class="header" href="#生命周期针对引用附加的信息">生命周期：针对引用附加的信息</a></h2>
<h2 id="参考资源"><a class="header" href="#参考资源">参考资源</a></h2>
<ul>
<li><a href="https://www.ditsing.com/object-lifetime-and-ownership/">Object lifetime and ownership</a></li>
<li><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">What is Ownership? - The Rust Programming Language</a></li>
<li>&lt;精通rust(第二版)&gt;-5.7 内存安全三原则</li>
<li><a href="https://www.zhihu.com/question/58863427">go没有虚拟机怎么运行gc的？ - 知乎</a></li>
</ul>
<p><a href="../../templates/footer.html"></a>
<a href="../../templates/avatar.jpeg"></a>
{{#template ../../templates/footer.md, path=../../templates author=KuanHsiaoKuo}}</p>

            </main>

            <script src="https://utteranc.es/client.js"
                    repo="RustMagazine/rust_magazine_2022"
                    issue-term="title"
                    theme="github-light"
                    crossorigin="anonymous"
                    async></script>

            <nav class="nav-wrapper" aria-label="Page navigation">
                <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../../layer1_underlying_abstract/1_virtual_memory/memory_manage_safety.html" class="mobile-nav-chapters previous"
                       title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../layer1_underlying_abstract/2_type_system/type_system.html" class="mobile-nav-chapters next"
                       title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                <div style="clear: both"></div>
            </nav>
        </div>
    </div>

    <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../../layer1_underlying_abstract/1_virtual_memory/memory_manage_safety.html" class="nav-chapters previous" title="Previous chapter"
               aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            <a rel="next" href="../../layer1_underlying_abstract/2_type_system/type_system.html" class="nav-chapters next" title="Next chapter"
               aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
    </nav>

</div>

    <script type="text/javascript">
        window.playground_copyable = true;
    </script>
    <script src="../../ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../editor.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mode-rust.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
<script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
<script src="../../book.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JS scripts -->
    <script type="text/javascript" src="../../mermaid.min.js"></script>
    <script type="text/javascript" src="../../mermaid-init.js"></script>
    <script type="text/javascript" src="../../smart-anchor.js"></script>
    <script type="text/javascript" src="../../sidebar.js"></script>
</body>
</html>
