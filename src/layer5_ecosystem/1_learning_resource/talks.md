# 漫话Rust

<!--ts-->
* [漫话Rust](#漫话rust)
   * [话题](#话题)
      * [为什么觉得 Rust 难上手，尤其是生命周期？ - 知乎](#为什么觉得-rust-难上手尤其是生命周期---知乎)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Sat Jul 23 05:11:45 UTC 2022 -->

<!--te-->

## 话题

### 为什么觉得 Rust 难上手，尤其是生命周期？ - 知乎

- [为什么觉得 Rust 难上手，尤其是生命周期？ - 知乎](https://www.zhihu.com/question/537491826)

```admonish quote title='把技巧掺杂在上手过程里'
因为其他语言上手真的就只是上手而已，你还得买《Effective Xxxx》甚至《More Effective Xxxx》，以及《Xxx并发编程》《深入理解Xxx虚拟机》等等各种书籍来学习各种避坑、省力、debug技巧。而Rust的上手是把这些技巧直接掺在上手过程里了，编译器以及配套工具（比如错误提示里的help，fmt、clippy）逼着你把代码写对，上手Rust等于同时被迫学会了这一堆技巧。
```

~~~admonish quote title='区分编译期抽象和运行期抽象'
1. 学习 rust 上手难一般是因为缺乏丰富的 Cpp 经验。因此，大家会对【胖指针】【瘦指针】【虚表 vtable 】等基础概念缺少深刻的理解。而这些概念正是区分 rust 中【编译期间-抽象 — 单态化】与【运行期间-抽象 — `trait Object` 】的认知“门槛”。
2. 另一方面，学习lifetime 上手难是因为大家已经习惯了“颐指气使”地向计算机“发号施令”和下达指示了。
3. 但是， lifetime  完全是另一码事。就【生命周期】而言， rustc 的角色是【仲裁者】，而不是【执行者】。

>【生命周期·标注】被设计用来：由 @程序员 向【仲裁者 rustc 】表述自己的代码设计意图（这些意图通过直接扫描代码不容易被揣测出来）。然后，再由【仲裁者】判断你的代码意图是否可行，因为代码首先得足够安全。

所以，你不能命令 rustc ：我要求某某变量一定得活多长时间（一切皆可操控，那是 Cpp）；而是，询问 rustc ：我如此设计代码，想让某某变量活这么长时间，你看行得通吗？若 rustc 判定行不通，那么一个编译错误就等着你了。

比如说，函数的【生命周期_泛型参数】是被用来将  
1. 引用类型的函数入参的生命周期与  
2. 引用类型的函数返回值的生命周期关联起来。

以便，在对代码做【静态分析】时，编译器能够根据（已知）入参推断出函数返回值的生命周期。

> 这是帮助编译器理解咱们代码的“脚注”，而不是给编译器下达的“指示”。得和 `rustc` “商量”着来。
~~~

```admonish quote title='对C++不熟悉'
最直接的原因就是对C++不熟悉，如果你明白移动语义，完美转发，智能指针这些东西。Rust也不过是强制我们在正确使用C++里面的某些工具而已。
```